We have seen that functions are a method of abstraction that describe compound operations independent of the particular values of their arguments. That is, in square,  
我们已经知道，函数是一种抽象方法，它描述独立于参数特定值的复合运算。也就是说，在 square 中，

```python
>>> def square(x):
        return x * x
```

we are not talking about the square of a particular number, but rather about a method for obtaining the square of any number. Of course, we could get along without ever defining this function, by always writing expressions such as  
>我们讨论的不是某个特定数的平方，而是一种求任意数平方的方法。当然，我们可以不定义这个函数，而是始终写出如下表达式：

```python
>>> 3 * 3
9
>>> 5 * 5
25
```

and never mentioning square explicitly. This practice would suffice for simple computations such as square, but would become arduous for more complex examples such as abs or fib. In general, lacking function definition would put us at the disadvantage of forcing us to work always at the level of the particular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of higher-level operations. Our programs would be able to compute squares, but our language would lack the ability to express the concept of squaring.  
>并且从未明确提及 square 。这种做法对于像 square 这样的简单计算来说还算足够，但对于像 abs 或 fib 这样更复杂的例子来说，就会变得很费劲。一般来说，缺乏函数定义会让我们陷入劣势，迫使我们总是在特定运算的层面上工作，而这些运算恰好是语言中的原语（在本例中是乘法），而不是更高级的运算。我们的程序可以计算平方，但我们的语言却缺乏表达平方概念的能力。

One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the names directly. Functions provide this ability. As we will see in the following examples, there are common programming patterns that recur in code, but are used with a number of different functions. These patterns can also be abstracted, by giving them names.  
>我们应该要求一门强大的编程语言具备的一项能力是：能够通过为常见模式赋予名称来构建抽象，然后直接根据这些名称进行操作。函数就提供了这种能力。正如我们将在以下示例中看到的那样，一些常见的编程模式会在代码中反复出现，但会与许多不同的函数一起使用。这些模式也可以通过赋予名称来实现抽象。

To express certain general patterns as named concepts, we will need to construct functions that can accept other functions as arguments or return functions as values. Functions that manipulate functions are called higher-order functions. This section shows how higher-order functions can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language.  
>为了将某些通用模式表达为命名概念，我们需要构造一些函数，这些函数可以接受其他函数作为参数，或返回函数作为值。操作函数的函数称为高阶函数。本节将展示高阶函数如何作为强大的抽象机制，从而极大地提升我们语言的表达能力。

### 1.6.1   Functions as Arguments  
1.6.1 函数作为参数

Consider the following three functions, which all compute summations. The first, sum_naturals, computes the sum of natural numbers up to n:  
>考虑以下三个函数，它们都用于计算和。第一个函数 sum_naturals 计算到 n 的自然数之和：

```python
>>> def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
>>> sum_naturals(100)
5050

```

The second, sum_cubes, computes the sum of the cubes of natural numbers up to n.  
第二个函数 sum_cubes 计算不超过 n 的自然数的立方和。

```python
>>> def sum_cubes(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k*k*k, k + 1
        return total

>>> sum_cubes(100)
25502500
```

The third, pi_sum, computes the sum of terms in the series  
>第三个 pi_sum 计算系列中的项之和

![](https://www.composingprograms.com/img/pi_sum.png)

which converges to pi very slowly.  
>它收敛到 pi 非常慢。

```python
>>> def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
        return total

>>> pi_sum(100)
3.1365926848388144

```
These three functions clearly share a common underlying pattern. They are for the most part identical, differing only in name and the function of k used to compute the term to be added. We could generate each of the functions by filling in slots in the same template:  
>这三个函数显然具有共同的底层模式。它们大部分内容相同，仅在名称和用于计算待加项的 k 函数上有所不同。我们可以通过在同一模板中填充槽位来生成每个函数：

```python
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total
```

The presence of such a common pattern is strong evidence that there is a useful abstraction waiting to be brought to the surface. Each of these functions is a summation of terms. As program designers, we would like our language to be powerful enough so that we can write a function that expresses the concept of summation itself rather than only functions that compute particular sums. We can do so readily in Python by taking the common template shown above and transforming the "slots" into formal parameters:  
>这种常见模式的存在，有力地证明了一个有用的抽象概念有待挖掘。这些函数中的每一个都是对项的求和。作为程序设计者，我们希望我们的语言足够强大，以便我们能够编写一个能够表达求和概念本身的函数，而不仅仅是计算特定和的函数。在 Python 中，我们可以轻松地做到这一点，只需采用上面所示的通用模板，并将“槽”转换为形式参数即可：

In the example below, summation takes as its two arguments the upper bound n together with the function term that computes the kth term. We can use summation just as we would any function, and it expresses summations succinctly. Take the time to step through this example, and notice how binding cube to the local names term ensures that the result 1*1*1 + 2*2*2 + 3*3*3 = 36 is computed correctly. In this example, frames which are no longer needed are removed to save space.  
>在下面的例子中， summation 将上界 n 和计算第 k 项的函数 term 作为其两个参数。我们可以像使用任何函数一样使用 summation ，它能够简洁地表达求和。请花点时间逐步完成此示例，并注意如何将 cube 绑定到局部名称 term 以确保正确计算结果 1*1*1 + 2*2*2 + 3*3*3 = 36 。在此示例中，我们删除了不再需要的框架以节省空间。

![[Pasted image 20250421103846.png]]


Using an identity function that returns its argument, we can also sum natural numbers using exactly the same summation function.  
>使用返回其参数的 identity 函数，我们还可以使用完全相同的 summation 函数对自然数进行求和。

```python
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k + 1
        return total
>>> def identity(x):
        return x
>>> def sum_naturals(n):
        return summation(n, identity)
>>> sum_naturals(10)
55

```

The summation function can also be called directly, without definining another function for a specific sequence.  
>还可以直接调用 summation 函数，而无需为特定序列定义另一个函数。

```python
>>> summation(10, square)
385
```

We can define pi_sum using our summation abstraction by defining a function pi_term to compute each term. We pass the argument 1e6, a shorthand for 1 * 10^6 = 1000000, to generate a close approximation to pi.  
>我们可以使用 summation 抽象来定义 pi_sum ，即定义一个函数 pi_term 来计算每个项。我们传递参数 1e6 （ 1 * 10^6 = 1000000 的简写），以生成接近 π 的近似值。

```python

>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
>>> def pi_sum(n):
        return summation(n, pi_term)
>>> pi_sum(1e6)
3.141592153589902
```
### 1.6.2   Functions as General Methods  
1.6.2 函数作为通用方法`

We introduced user-defined functions as a mechanism for abstracting patterns of numerical operations so as to make them independent of the particular numbers involved. With higher-order functions, we begin to see a more powerful kind of abstraction: some functions express general methods of computation, independent of the particular functions they call.  
>我们引入了用户定义函数，作为一种抽象数值运算模式的机制，使其与所涉及的具体数字无关。通过高阶函数，我们开始看到一种更强大的抽象：一些函数表达了通用的计算方法，与它们调用的特定函数无关。

Despite this conceptual extension of what a function means, our environment model of how to evaluate a call expression extends gracefully to the case of higher-order functions, without change. When a user-defined function is applied to some arguments, the formal parameters are bound to the values of those arguments (which may be functions) in a new local frame.  
>尽管函数的概念有所扩展，但我们关于如何求值调用表达式的环境模型可以优雅地扩展到高阶函数的情况，而无需任何改变。当用户定义的函数应用于某些参数时，形式参数会在新的局部框架中绑定到这些参数（可能是函数）的值。

Consider the following example, which implements a general method for iterative improvement and uses it to compute the [golden ratio](http://www.geom.uiuc.edu/~demo5337/s97b/art.htm). The golden ratio, often called "phi", is a number near 1.6 that appears frequently in nature, art, and architecture.  
>请考虑以下示例，它实现了一种迭代改进的通用方法，并用它来计算黄金分割率。黄金分割率，通常称为“phi”，是一个接近 1.6 的数字，在自然界、艺术和建筑中经常出现。

An iterative improvement algorithm begins with a guess of a solution to an equation. It repeatedly applies an update function to improve that guess, and applies a close comparison to check whether the current guess is "close enough" to be considered correct.  
>迭代改进算法始于对方程解的 guess 。它会反复应用 update 函数来改进该猜测，并应用 close 比较来检查当前 guess 是否“足够接近”以被视为正确解。

```python
>>> def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess

```
This improve function is a general expression of repetitive refinement. It doesn't specify what problem is being solved: those details are left to the update and close functions passed in as arguments.  
>此 improve 函数是重复细化的一般表达。它并未指定要解决的问题：这些细节留给作为参数传入的 update 和 close 函数处理。


Among the well-known properties of the golden ratio are that it can be computed by repeatedly summing the inverse of any positive number with 1, and that it is one less than its square. We can express these properties as functions to be used with improve.  
>黄金分割率的几个众所周知的性质包括：它可以通过将任意正数的倒数与 1 反复求和来计算，并且它比它的平方少 1。我们可以将这些性质表示为与 improve 一起使用的函数。

```python
>>> def golden_update(guess):
        return 1/guess + 1
>>> def square_close_to_successor(guess):
        return approx_eq(guess * guess, guess + 1)
```

Above, we introduce a call to approx_eq that is meant to return True if its arguments are approximately equal to each other. To implement, approx_eq, we can compare the absolute value of the difference between two numbers to a small tolerance value.  
>上面我们引入了对 approx_eq 的调用，当其参数近似相等时，该调用返回 True 。为了实现 approx_eq ，我们可以将两个数字之差的绝对值与一个较小的容差值进行比较。

```python
>>> def approx_eq(x, y, tolerance=1e-15):
        return abs(x - y) < tolerance
```

Calling improve with the arguments golden_update and square_close_to_successor will compute a finite approximation to the golden ratio.  
>使用参数 golden_update 和 square_close_to_successor 调用 improve 将计算黄金分割率的有限近似值。

```python
>>> improve(golden_update, square_close_to_successor)
1.6180339887498951
```


By tracing through the steps of evaluation, we can see how this result is computed. First, a local frame for improve is constructed with bindings for update, close, and guess. In the body of improve, the name close is bound to square_close_to_successor, which is called on the initial value of guess. Trace through the rest of the steps to see the computational process that evolves to compute the golden ratio.  
>通过追溯求值步骤，我们可以看到这个结果是如何计算出来的。首先，构建 improve 的局部框架，并绑定 update 、 close 和 guess 。在 improve 的主体中，名称 close 绑定到 square_close_to_successor ，后者在 guess 的初始值上被调用。追溯其余步骤，了解计算黄金分割率的演化过程。


```python
def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess
def golden_update(guess):
    return 1/guess + 1
def square_close_to_successor(guess):
    return approx_eq(guess * guess,
                     guess + 1)
def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance

phi = improve(golden_update,square_close_to_successor)     
```

![[Pasted image 20250421142036.png]]

This example illustrates two related big ideas in computer science. First, naming and functions allow us to abstract away a vast amount of complexity. While each function definition has been trivial, the computational process set in motion by our evaluation procedure is quite intricate. Second, it is only by virtue of the fact that we have an extremely general evaluation procedure for the Python language that small components can be composed into complex processes. Understanding the procedure of interpreting programs allows us to validate and inspect the process we have created.  
>这个例子阐释了计算机科学中两个相关的重要理念。首先，命名和函数使我们能够抽象出大量的复杂性。虽然每个函数定义都很简单，但我们的求值过程所启动的计算过程却相当复杂。其次，正是由于我们拥有一个极其通用的 Python 语言求值过程，才使得我们能够将小组件组合成复杂的过程。理解解释程序的过程使我们能够验证和检查我们所创建的流程。

As always, our new general method improve needs a test to check its correctness. The golden ratio can provide such a test, because it also has an exact closed-form solution, which we can compare to this iterative result.  
>与往常一样，我们的新通用方法 improve 需要进行测试来检验其正确性。黄金分割率可以提供这样的测试，因为它也有一个精确的闭式解，我们可以将其与此迭代结果进行比较。

```python
>>> from math import sqrt
>>> phi = 1/2 + sqrt(5)/2
>>> def improve_test():
        approx_phi = improve(golden_update, square_close_to_successor)
        assert approx_eq(phi, approx_phi), 'phi differs from its approximation'

>>> improve_test()

```
For this test, no news is good news: improve_test returns None after its assert statement is executed successfully.  
>对于此测试，没有消息就是好消息： improve_test 在其 assert 语句成功执行后返回 None 。

### 1.6.3   Defining Functions III: Nested Definitions  
1.6.3 定义函数 III：嵌套定义

The above examples demonstrate how the ability to pass functions as arguments significantly enhances the expressive power of our programming language. Each general concept or equation maps onto its own short function. One negative consequence of this approach is that the global frame becomes cluttered with names of small functions, which must all be unique. Another problem is that we are constrained by particular function signatures: the update argument to improve must take exactly one argument. Nested function definitions address both of these problems, but require us to enrich our environment model.  
>以上示例展示了将函数作为参数传递的能力如何显著增强编程语言的表达能力。每个通用概念或方程式都映射到其自身的短函数上。这种方法的一个负面后果是，全局框架会因小函数的名称而变得杂乱无章，而这些函数的名称都必须是唯一的。另一个问题是，我们受到特定函数签名的限制： improve 的 update 参数必须恰好接受一个参数。嵌套函数定义解决了这两个问题，但需要我们丰富环境模型。

Let's consider a new problem: computing the square root of a number. In programming languages, "square root" is often abbreviated as sqrt. Repeated application of the following update converges to the square root of a:  
>让我们考虑一个新问题：计算一个数的平方根。在编程语言中，“平方根”通常缩写为 sqrt 。反复应用以下更新操作将收敛到 a 的平方根：

```python
>>> def average(x, y):
        return (x + y)/2
>>> def sqrt_update(x, a):
        return average(x, a/x)
```

This two-argument update function is incompatible with improve (it takes two arguments, not one), and it provides only a single update, while we really care about taking square roots by repeated updates. The solution to both of these issues is to place function definitions inside the body of other definitions.  
>这个双参数更新函数与 improve 不兼容（它接受两个参数，而不是一个），而且它只提供一次更新，而我们真正关心的是通过重复更新来求平方根。解决这两个问题的方法是将函数定义放在其他定义的主体内部。

```python

>>> def sqrt(a):
        def sqrt_update(x):
            return average(x, a/x)
        def sqrt_close(x):
            return approx_eq(x * x, a)
        return improve(sqrt_update, sqrt_close)
```

Like local assignment, local def statements only affect the current local frame. These functions are only in scope while sqrt is being evaluated. Consistent with our evaluation procedure, these local def statements don't even get evaluated until sqrt is called.  
>与局部赋值类似，局部 def 语句仅影响当前局部框架。这些函数仅在 sqrt 被求值时处于作用域内。与我们的求值过程一致，这些局部 def 语句甚至直到 sqrt 被调用时才会被求值。

`Lexical scope` Locally defined functions also have access to the name bindings in the scope in which they are defined. In this example, sqrt_update refers to the name a, which is a formal parameter of its enclosing function sqrt. This discipline of ==sharing names among nested definitions is called `lexical scoping`==. Critically, the inner functions have access to the names in the environment where they are defined (not where they are called).  
>词法作用域。局部定义的函数也可以访问其定义作用域中的名称绑定。在本例中， sqrt_update 引用了名称 a ，它是其封闭函数 sqrt 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。关键在于，内部函数可以访问其定义环境（而非调用环境）中的名称。

We require two extensions to our environment model to enable lexical scoping.  
>我们需要对环境模型进行两个扩展以实现词汇作用域。

1. Each user-defined function has a parent environment: the environment in which it was defined.  
    >每个用户定义的函数都有一个父环境：即定义该函数的环境。
2. When a user-defined function is called, its local frame extends its parent environment.  
    >当调用用户定义函数时，其本地框架会扩展其父环境。

Previous to sqrt, all functions were defined in the global environment, and so they all had the same parent: the global environment. By contrast, when Python evaluates the first two clauses of sqrt, it create functions that are associated with a local environment. In the call  
>在 sqrt 之前，所有函数都是在全局环境中定义的，因此它们都具有相同的父级：全局环境。相比之下，当 Python 执行 sqrt 的前两个子句时，它会创建与局部环境关联的函数。在调用中

```python
>>> sqrt(256)
16.0
```
the environment first adds a local frame for sqrt and evaluates the def statements for sqrt_update and sqrt_close.  
>环境首先为 sqrt 添加一个局部框架，并评估 sqrt_update 和 sqrt_close 的 def 语句。

```python
def average(x, y):
    return (x + y)/2

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance

def sqrt(a):
    def sqrt_update(x):
        return average(x, a/x)
    def sqrt_close(x):
        return approx_eq(x * x, a)
    return improve(sqrt_update, sqrt_close)

result = sqrt(256)
```

![[Pasted image 20250421143313.png]]

Function values each have a new annotation that we will include in environment diagrams from now on, a _parent_. The parent of a function value is the first frame of the environment in which that function was defined. Functions without parent annotations were defined in the global environment. When a user-defined function is called, the frame created has the same parent as that function.  
>每个函数值都有一个新的注释，我们将从现在开始将其包含在环境图中，即父级。函数值的父级是定义该函数的环境的第一个框架。没有父级注释的函数是在全局环境中定义的。当调用用户定义的函数时，创建的框架与该函数具有相同的父级。

Subsequently, the name sqrt_update resolves to this newly defined function, which is passed as an argument to improve. Within the body of improve, we must apply our update function (bound to sqrt_update) to the initial guess x of 1. This final application creates an environment for sqrt_update that begins with a local frame containing only x, but with the parent frame sqrt still containing a binding for a.  
>随后，名称 sqrt_update 解析为这个新定义的函数，并将其作为参数传递给 improve 。在 improve 的主函数中，我们必须将 update 函数（绑定到 sqrt_update ）应用于初始猜测 x 1。最终的应用为 sqrt_update 创建一个环境，该环境以仅包含 x 的本地框架开始，但其父框架 sqrt 仍然包含 a 的绑定。

![[Pasted image 20250421143519.png]]
The most critical part of this evaluation procedure is the transfer of the parent for sqrt_update to the frame created by calling sqrt_update. This frame is also annotated with [parent=f1].  
>此评估过程中最关键的部分是将 sqrt_update 的父级转移到通过调用 sqrt_update 创建的框架。此框架也带有 [parent=f1] 注释。

**Extended Environments**. An environment can consist of an arbitrarily long chain of frames, which always concludes with the global frame. Previous to this sqrt example, environments had at most two frames: a local frame and the global frame. By calling functions that were defined within other functions, via nested def statements, we can create longer chains. The environment for this call to sqrt_update consists of three frames: the local sqrt_update frame, the sqrt frame in which sqrt_update was defined (labeled f1), and the global frame.  
>扩展环境。环境可以由任意长的框架链组成，该链始终以全局框架结尾。在此 sqrt 示例之前，环境最多包含两个框架：局部框架和全局框架。通过嵌套 def 语句调用在其他函数中定义的函数，我们可以创建更长的框架链。此 sqrt_update 调用的环境由三个框架组成：局部 sqrt_update 框架、定义 sqrt_update 的 sqrt 框架（标记为 f1 ）以及全局框架。

The return expression in the body of sqrt_update can resolve a value for a by following this chain of frames. Looking up a name finds the first value bound to that name in the current environment. Python checks first in the sqrt_update frame -- no a exists. Python checks next in the parent frame, f1, and finds a binding for a to 256.  
>sqrt_update 主体中的返回表达式可以通过跟踪此框架链来解析 a 的值。查找名称会找到当前环境中与该名称绑定的第一个值。Python 首先在 sqrt_update 框架中检查——不存在 a 。Python 接下来在父框架 f1 中检查，并找到 a 到 256 的绑定。

Hence, we realize two key advantages of lexical scoping in Python.  
因此，我们认识到 Python 中词法作用域的两个主要优点。

- The names of a local function do not interfere with names external to the function in which it is defined, because the local function name will be bound in the current local environment in which it was defined, rather than the global environment.  
    >本地函数的名称不会干扰定义该函数的函数外部的名称，因为本地函数名称将绑定在定义它的当前本地环境中，而不是全局环境中。
- A local function can access the environment of the enclosing function, because the body of the local function is evaluated in an environment that extends the evaluation environment in which it was defined.  
    >局部函数可以访问封闭函数的环境，因为局部函数的主体是在扩展其定义评估环境的环境中进行评估的。

The sqrt_update function carries with it some data: the value for a referenced in the environment in which it was defined. Because they "enclose" information in this way, locally defined functions are often called `closures`.  
>sqrt_update 函数带有一些数据：即在其定义环境中引用的 a 的值。由于局部定义的函数以这种方式“封装”信息，因此它们通常被称为闭包。

### 1.6.4   Functions as Returned Values  
1.6.4 函数作为返回值


We can achieve even more expressive power in our programs by creating functions whose returned values are themselves functions. An important feature of lexically scoped programming languages is that locally defined functions ==maintain their parent environment ==when they are returned. The following example illustrates the utility of this feature.  
>通过创建返回值本身也是函数的函数，我们可以在程序中实现更强大的表达能力。词法作用域编程语言的一个重要特性是，局部定义的函数在返回时会保留其父环境。以下示例说明了此功能的实用性。

Once many simple functions are defined, ==function composition== is a natural method of combination to include in our programming language. That is, given two functions f(x) and g(x), we might want to define h(x) = f(g(x)). We can define function composition using our existing tools:  
>一旦定义了多个简单函数，函数组合就成为一种自然的组合方法，可以融入到我们的编程语言中。也就是说，给定两个函数 f(x) 和 g(x) ，我们可能想要定义 h(x) = f(g(x)) 。我们可以使用现有的工具来定义函数组合：

```python
>>> def compose1(f, g):
        def h(x):
            return f(g(x))
        return h
```
The environment diagram for this example shows how the names f and g are resolved correctly, even in the presence of conflicting names.  
此示例的环境图显示了即使存在名称冲突，名称 f 和 g 也能正确解析。

```python
'''Function composition'''
def square(x):
    return x * x

def successor(x):
    return x + 1

def compose1(f, g):
    def h(x):
        return f(g(x))
    return h

def f(x):
    """Never called."""
    return -x

square_successor = compose1(square, successor)
result = square_successor(12)
```

![[Pasted image 20250421151104.png]]
The 1 in compose1 is meant to signify that the composed functions all take a single argument. This naming convention is not enforced by the interpreter; the 1 is just part of the function name.  
>compose1 中的 1 表示组合函数均采用单个参数。解释器不强制执行此命名约定；1 只是函数名称的一部分。

At this point, we begin to observe the benefits of our effort to define precisely the environment model of computation. No modification to our environment model is required to explain our ability to return functions in this way.  
>此时，我们开始观察到我们努力精确定义计算环境模型的好处。无需修改我们的环境模型，就能解释我们以这种方式返回函数的能力。



### 1.6.6   Currying 
1.6.6 柯里化

```python
# 原始函数
def add(a, b):
    return a + b

# 柯里化版本
def curried_add(a):
    def inner(b):
        return a + b
    return inner

add_five = curried_add(5)  # 返回一个函数
result = add_five(3)       # 8
```


We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument. More specifically, given a function f(x, y), we can define a function g such that g(x)(y) is equivalent to f(x, y). Here, g is a higher-order function that takes in a single argument x and returns another function that takes in a single argument y. This transformation is called _currying_.  
>我们可以使用高阶函数将一个接受多个参数的函数转换为一个`函数链`，每个函数只接受一个参数。更具体地说，给定一个函数 f(x, y) ，我们可以定义一个函数 g ，使得 g(x)(y) 等价于 f(x, y) 。这里， g 是一个高阶函数，它接受一个参数 x ，并返回另一个接受一个参数 y 的函数。这种转换称为柯里化。

As an example, we can define a curried version of the pow function:  
例如，我们可以定义 pow 函数的柯里化版本：

```python
>>> def curried_pow(x):
        def h(y):
            return pow(x, y)
        return h

>>> curried_pow(2)(3)
8
```


Some programming languages, such as Haskell, only allow functions that take a single argument, so the programmer must curry all multi-argument procedures. In more general languages such as Python, currying is useful when we require a function that takes in only a single argument. For example, the _map_ pattern applies a single-argument function to a sequence of values. In later chapters, we will see more general examples of the `map pattern`, but for now, we can implement the pattern in a function:  
>某些编程语言（例如 Haskell）只允许函数接受单个参数，因此程序员必须对所有多参数过程进行柯里化。在更通用的语言（例如 Python）中，当我们需要一个只接受单个参数的函数时，柯里化非常有用。例如，映射模式将一个单参数函数应用于一个值序列。在后面的章节中，我们将看到更通用的映射模式示例，但现在我们可以在一个函数中实现该模式：

```python
>>> def map_to_range(start, end, f):
        while start < end:
            print(f(start))
            start = start + 1
```
We can use map_to_range and curried_pow to compute the first ten powers of two, rather than specifically writing a function to do so:  
>我们可以使用 map_to_range 和 curried_pow 来计算 2 的前十个幂，而不必专门编写一个函数来执行此操作：

```python
>>> map_to_range(0, 10, curried_pow(2))
1
2
4
8
16
32
64
128
256
512
```

We can similarly use the same two functions to compute powers of other numbers. Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.  
>类似地，我们可以使用这两个函数来计算其他数字的幂。柯里化让我们无需为每个需要计算幂的数字编写一个特定的函数。

In the above examples, we manually performed the currying transformation on the pow function to obtain curried_pow. Instead, we can define functions to automate currying, as well as the inverse _uncurrying_ transformation:  
>在上面的例子中，我们手动对 pow 函数执行了柯里化转换，得到了 curried_pow 。其实，我们可以定义函数来自动执行柯里化，以及逆向反柯里化转换：

```python
>>> def curry2(f):
        """Return a curried version of the given two-argument function."""
        def g(x):
            def h(y):
                return f(x, y)
            return h
        return g
        
>>> def uncurry2(g):
        """Return a two-argument version of the given curried function."""
        def f(x, y):
            return g(x)(y)
        return f

>>> pow_curried = curry2(pow)
>>> pow_curried(2)(5)
32
>>> map_to_range(0, 10, pow_curried(2))
1
2
4
8
16
32
64
128
256
512
>>> uncurry2(pow_curried)(2, 5)
32
```


The curry2 function takes in a two-argument function f and returns a single-argument function g. When g is applied to an argument x, it returns a single-argument function h. When h is applied to y, it calls f(x, y). Thus, curry2(f)(x)(y) is equivalent to f(x, y). The uncurry2 function reverses the currying transformation, so that uncurry2(curry2(f)) is equivalent to f.  
>curry2 函数接受双参数函数 f 并返回单参数函数 g 。当 g 应用于参数 x 时，它会返回单参数函数 h 。当 h 应用于 y 时，它会调用 f(x, y) 。因此， curry2(f)(x)(y) 等同于 f(x, y) 。 uncurry2 函数反转了柯里化转换，因此 uncurry2(curry2(f)) 等同于 f 。



### 1.6.7   Lambda Expressions  
1.6.7 Lambda 表达式



So far, each time we have wanted to define a new function, we needed to give it a name. But for other types of expressions, we don't need to associate intermediate values with a name. That is, we can compute a*b + c*d without having to name the subexpressions a*b or c*d, or the full expression. In Python, we can create function values on the fly using lambda expressions, which evaluate to unnamed functions. A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.  
>到目前为止，每次我们想要定义一个新函数时，都需要为其命名。但对于其他类型的表达式，我们无需将中间值与名称关联。也就是说，我们可以计算 a*b + c*d 而无需命名子表达式 a*b 或 c*d ，也无需命名完整表达式。在 Python 中，我们可以使用 lambda 表达式动态创建函数值，这些表达式的计算结果为未命名函数。lambda 表达式的计算结果为一个具有单个返回表达式作为其主体的函数。不允许使用赋值语句和控制语句。

```python
>>> def compose1(f, g):
        return lambda x: f(g(x))
```

We can understand the structure of a lambda expression by constructing a corresponding English sentence:  
我们可以通过构建相应的英语句子来理解 lambda 表达式的结构：

     lambda            x            :          f(g(x))     
	"A function that    takes x    and returns     f(g(x))"

The result of a lambda expression is called a lambda function. It has no intrinsic name (and so Python prints `<lambda>` for the name), but otherwise it behaves like any other function.  
>Lambda 表达式的结果称为 Lambda 函数。它没有内在名称（因此 Python 会打印 `<lambda>` 作为名称），但除此之外，它的行为与其他函数相同。

```python
>>> s = lambda x: x * x
>>> s
<function <lambda> at 0xf3f490>
>>> s(12)
144
```

In an environment diagram, the result of a lambda expression is a function as well, named with the greek letter λ (lambda). Our compose example can be expressed quite compactly with lambda expressions.  
>在环境图中，lambda 表达式的结果也是一个函数，以希腊字母 λ（lambda）命名。我们的 Compose 示例可以用 Lambda 表达式非常简洁地表达。

```python
def compose1(f, g):
    return lambda x: f(g(x))

f = compose1(lambda x: x * x,
             lambda y: y + 1)
result = f(12)
```

![[Pasted image 20250421181101.png]]

Some programmers find that using unnamed functions from lambda expressions to be shorter and more direct. However, compound lambda expressions are notoriously illegible, despite their brevity. The following definition is correct, but many programmers have trouble understanding it quickly.  
>一些程序员发现，在 lambda 表达式中使用未命名函数更简洁、更直接。然而，复合 lambda 表达式虽然简洁，但却非常难以理解。以下定义是正确的，但许多程序员难以快速理解。

```python
>>> compose1 = lambda f,g: lambda x: f(g(x))
```

In general, Python style prefers explicit def statements to lambda expressions, but allows them in cases where a simple function is needed as an argument or return value.  
>一般来说，Python 风格更喜欢使用显式 def 语句而不是 lambda 表达式，但在需要简单函数作为参数或返回值的情况下允许使用它们。

Such stylistic rules are merely guidelines; you can program any way you wish. However, as you write programs, think about the audience of people who might read your program one day. When you can make your program easier to understand, you do those people a favor.  
>这些风格规则仅仅是指导原则；您可以按照自己的想法编写程序。但是，在编写程序时，请考虑一下将来可能会阅读您程序的读者。当您使程序更易于理解时，您就为这些人提供了帮助。



### 1.6.8   Abstractions and First-Class Functions  
1.6.8 抽象和一等函数



We began this section with the observation that user-defined functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we've seen how higher-order functions permit us to manipulate these general methods to create further abstractions.  
>本节伊始，我们观察到用户==定义函数是一种至关重要的抽象机制==，因为它们允许我们将通用的计算方法表达为编程语言中的显式元素。现在，我们已经了解了高阶函数如何允许我们操作这些通用方法来创建进一步的抽象。



In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the "rights and privileges" of `first-class elements` are:  
>一般来说，编程语言会对计算元素的操作方式施加限制。限制最少的元素被称为具有一等地位的元素。一等元素的一些“权利和特权”如下：

1. They may be bound to names.  
    >它们可能与名称绑定。
2. They may be passed as arguments to functions.  
    >它们可以作为参数传递给函数。
3. They may be returned as the results of functions. 
    >它们可以作为函数的结果返回。
4. They may be included in data structures.  
    >它们可能包含在数据结构中。

Python awards functions full first-class status, and the resulting gain in expressive power is enormous.  
>Python 赋予函数完全的一流地位，其表达能力也因此获得巨大的提升。

### 1.6.9   Function Decorators  
1.6.9 函数装饰器


Python provides special syntax to apply higher-order functions as part of executing a def statement, called a decorator. Perhaps the most common example is a trace.  
Python 提供了特殊的语法，用于在执行 def 语句时应用高阶函数，这被称为装饰器。最常见的例子或许就是 trace。
```python
>>> def trace(fn):
        def wrapped(x):
            print('-> ', fn, '(', x, ')')
            return fn(x)
        return wrapped

>>> @trace
    def triple(x):
        return 3 * x

>>> triple(12)
->  <function triple at 0x102a39848> ( 12 )
36
```

In this example, A higher-order function trace is defined, which returns a function that precedes a call to its argument with a print statement that outputs the argument. The def statement for triple has an annotation, @trace, which affects the execution rule for def. As usual, the function triple is created. However, the name triple is not bound to this function. Instead, the name triple is bound to the returned function value of calling trace on the newly defined triple function. In code, this decorator is equivalent to:  
>在此示例中，定义了一个高阶函数 trace ，该函数返回一个函数，该函数在对其参数的调用之前带有一个输出该参数的 print 语句。 triple 的 def 语句具有注解 @trace ，它会影响 def 的执行规则。照例，函数 triple 被创建。但是，名称 triple 并未绑定到此函数。相反，名称 triple 绑定到了对新定义的 triple 函数调用 trace 的返回函数值。在代码中，此装饰器等效于：
```python
>>> def triple(x):
        return 3 * x
        
>>> triple = trace(triple)
```

In the projects associated with this text, decorators are used for tracing, as well as selecting which functions to call when a program is run from the command line.  
在与本文相关的项目中，装饰器用于跟踪，以及选择从命令行运行程序时要调用的函数。

**Extra for experts.** The decorator symbol @ may also be followed by a call expression. The expression following @ is evaluated first (just as the name trace was evaluated above), the def statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the def statement. A [short tutorial on decorators](http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html) by Ariel Ortiz gives further examples for interested students.  
额外补充。装饰器符号 @ 后面也可以跟一个调用表达式。首先对 @ 后面的表达式进行求值（就像上面对名称 trace 进行求值一样），然后对 def 语句进行求值，最后将装饰器表达式的求值结果应用于新定义的函数，并将结果绑定到 def 语句中的名称。Ariel Ortiz 的装饰器简短教程为感兴趣的学生提供了更多示例。