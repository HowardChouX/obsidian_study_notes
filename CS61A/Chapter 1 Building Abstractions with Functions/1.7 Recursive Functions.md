### 1.7.5   Example: Partitions  
1.7.5 示例：分区

The number of partitions of a positive integer n, using parts up to size m, is the number of ways in which n can be expressed as the sum of positive integer parts up to m in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.  
>将正整数 n 分割成大小不超过 m 的部分，其数量等于将 n 表示为按升序排列的不超过 m 个正整数部分之和的方式数。例如，将 6 分割成大小不超过 4 的部分，其数量为 9。

1. 6 = 2 + 4
2. 6 = 1 + 1 + 4
3. 6 = 3 + 3
4. 6 = 1 + 2 + 3
5. 6 = 1 + 1 + 1 + 3
6. 6 = 2 + 2 + 2
7. 6 = 1 + 1 + 2 + 2
8. 6 = 1 + 1 + 1 + 1 + 2
9. 6 = 1 + 1 + 1 + 1 + 1 + 1

We will define a function count_partitions(n, m) that returns the number of different partitions of n using parts up to m. This function has a simple solution as a tree-recursive function, based on the following observation:  
>我们将定义一个函数 count_partitions(n, m) ，它返回 n 的不同分区数，分区数最多为 m 。该函数有一个简单的解决方案，即树形递归函数，基于以下观察：

The number of ways to partition n using integers up to m equals  
>使用最多 m 个整数对 n 进行分区的方法数等于

1. the number of ways to partition n-m using integers up to m, and  
    >使用最大为 m 的整数对 n-m 进行分区的方法数，以及
2. the number of ways to partition n using integers up to m-1.  
    >使用最大为 m-1 的整数对 n 进行分区的方法数。

To see why this is true, observe that all the ways of partitioning n can be divided into two groups: those that include at least one m and those that do not. Moreover, each partition in the first group is a partition of n-m, followed by m added at the end. In the example above, the first two partitions contain 4, and the rest do not.  
>要理解其原因，请观察所有 n 的分区方式，它们可以分为两组：一组至少包含一个 m ，另一组不包含。此外，第一组中的每个分区都是 n-m 的分区，后面紧跟着 m 。在上面的例子中，前两个分区包含 4，其余分区不包含。

Therefore, we can recursively reduce the problem of partitioning n using integers up to m into two simpler problems: (1) partition a smaller number n-m, and (2) partition with smaller components up to m-1.  
>因此，我们可以递归地将使用最多 m 的整数对 n 进行分区的问题简化为两个更简单的问题：（1）分区一个较小的数字 n-m ，（2）使用最多 m-1 的较小组件进行分区。

To complete the implementation, we need to specify the following base cases:  
为了完成实施，我们需要指定以下基本情况：

1. There is one way to partition 0: include no parts.  
    >分割 0 有一种方法：不包括任何部分。
2. There are 0 ways to partition a negative n.  
    >有 0 种方法可以分割负数 n 。
3. There are 0 ways to partition any n greater than 0 using parts of size 0 or less.  
    >有 0 种方法可以使用大小为 0 或更小的部分来划分大于 0 的任何 n 。

```python
>>> def count_partitions(n, m):
        """Count the ways to partition n using parts up to m."""
        if n == 0:
            return 1
        elif n < 0:
            return 0
        elif m == 0:
            return 0
        else:
            return count_partitions(n-m, m) + count_partitions(n, m-1)

>>> count_partitions(6, 4)
9
>>> count_partitions(5, 5)
7
>>> count_partitions(10, 10)
42
>>> count_partitions(15, 15)
176
>>> count_partitions(20, 20)
627

```

We can think of a tree-recursive function as exploring different possibilities. In this case, we explore the possibility that we use a part of size m and the possibility that we do not. The first and second recursive calls correspond to these possibilities.  
我们可以将树状递归函数视为探索不同可能性的过程。在本例中，我们探索使用大小为 m 的部分的可能性，以及不使用部分的可能性。第一次和第二次递归调用分别对应于这两种可能性。

### 一、递归终止条件解析

代码中的边界条件对应不同划分场景的数学定义：

1. ​**`n == 0` 返回 1**​  
    当目标数 `n` 被完全划分完毕（剩余值为0），视为找到一种有效划分方式。例如 `n=2, m=2` 时，`2-2=0` 对应一个有效划分 `[2]`
    
2. ​**`n < 0` 返回 0**​  
    无效划分情况，如尝试用比 `n` 更大的数划分（如 `n=3, m=5` 时，`3-5=-2` 无意义）
3. ​**`m == 0` 返回 0**​  
    最大加数为0时无法构成有效划分，属于逻辑终止条件

---

### 二、递归分解逻辑

​**核心公式**​：`count_partition(n, m) = count_partition(n-m, m) + count_partition(n, m-1)`  
这体现了两种子问题的组合：

1. ​**包含 `m` 的划分**​（`count_partition(n-m, m)`）  
    固定当前最大加数为 `m`，将问题转化为对剩余值 `n-m` 的划分（仍允许继续使用 `m`）。  
    _示例_：`n=5, m=3`，包含3的划分对应 `5-3=2` 的划分（即 `[3,2]` 或 `[3,1,1]` 等）
    
2. ​**不包含 `m` 的划分**​（`count_partition(n, m-1)`）  
    排除当前最大加数 `m`，将问题转化为使用更小加数（最大为 `m-1`）的划分。  
    _示例_：`n=5, m=3`，不包含3的划分即 `n=5, m=2` 的所有可能性（如 `[2,2,1]`。
    

---

### 三、底层数学原理

该递归算法本质是对**整数划分的生成树**进行深度优先遍历：

- ​**分治策略**​：通过缩小 `n` 和 `m` 的值将原问题拆解为更小的子问题。
- ​**动态规划特性**​：隐含了子问题的重叠性（如多次计算 `count_partition(2,2)`），可通过记忆化优化效率
- ​**组合数学映射**​：与整数分拆函数 `p(n)` 相关，表示将 `n` 写成正整数之和的不同方式数

---

### 四、实例验证（以 `n=4, m=4` 为例）

| 递归调用栈            | 计算过程                                  | 对应划分            |
| ---------------- | ------------------------------------- | --------------- |
| `count(4,4)`     | `count(0,4)+count(4,3)`               | [4] 和所有最大数≤3的划分 |
| `→ count(0,4)`   | 返回1（基础情况）                             | [4]             |
| `→ count(4,3)`   | `count(1,3)+count(4,2)`               | 含3的划分和最大数≤2的划分  |
| `→ → count(1,3)` | `count(-2,3)+count(1,2)` → 0+1        | [3,1]           |
| `→ → count(4,2)` | `count(2,2)+count(4,1)`               | 含2的划分和全1划分      |
| 最终结果：​**5种划分**​  | [4], [3,1], [2,2], [2,1,1], [1,1,1,1] | 4<br><br>8      |
