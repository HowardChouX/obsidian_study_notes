We have identified in Python some of the elements that must appear in any powerful programming language:  
我们在 Python 中确定了任何强大的编程语言都必须出现的一些元素：

1. Numbers and arithmetic operations are primitive(原始的) built-in data values and functions.  
    >数字和算术运算是原始的内置数据值和函数。
2. Nested function application provides a means of _combining_ operations.  
    >嵌套函数应用提供了一种_组合_操作的方法。
3. Binding names to values provides a limited means of _abstraction_.  
    >将名称绑定到值提供了一种有限的抽象方法。

Now we will learn about `function definitions`, ==a much more powerful abstraction technique by which a name can be bound to compound operation==, which can then be referred to as a unit.  
现在我们将学习函数定义 ，这是一种更强大的抽象技术，通过它可以将名称绑定到复合操作，然后可以将其称为一个单元。

We begin by examining how to express the idea of _squaring_. We might say, "To square something, multiply it by itself." This is expressed in Python as  
>我们首先来研究如何表达平方的概念。我们可能会说：“要计算某个数的平方，就是将其乘以自身。” 这在 Python 中表示为

```python
>>> def square(x):
        return mul(x, x)
```

which defines a new function that has been given the name square. This user-defined function is not built into the interpreter. It represents the compound operation of multiplying something by itself. The x in this definition is called a `formal parameter`, which provides a name for the thing to be multiplied. The definition creates this user-defined function and associates it with the name square.  
>它定义了一个名为 square 的新函数。此用户定义函数并非解释器内置函数。它表示将某个数乘以自身这个复合运算。此定义中的 x 称为形式参数 ，它为要乘以的数提供了一个名称。该定义创建了这个用户定义函数，并将其与名称 square 关联。

**How to define a function.** Function definitions consist of a def statement that indicates a `<name>` and a comma-separated list of named `<formal parameters>`, then a return statement, called the function body, that specifies the `<return expression>` of the function, which is an expression to be evaluated whenever the function is applied:  
>如何定义函数。** 函数定义由 def 组成 语句指示 `<name>` 和以逗号分隔的命名列表`<formal parameters>` ，然后是 return 语句，称为函数体，它指定函数的 `<return expression>` ，它是每次应用函数时要计算的表达式：

```python
def <name>(<formal parameters>):
    return <return expression>
```

The second line _must_ be indented — most programmers use four spaces to indent. The return expression is not evaluated right away; it is stored as part of the newly defined function and evaluated only when the function is eventually applied.  
>第二行必须缩进——大多数程序员使用四个空格来缩进。返回表达式不会立即求值；它被存储为新定义函数的一部分，仅在函数最终被应用时才被求值。

Having defined square, we can apply it with a call expression:  
>定义了 square 后，我们可以使用调用表达式来应用它：

```python
>>> square(21)
441
>>> square(add(2, 5))
49
>>> square(square(3))
81
```

We can also use square as a building block in defining other functions. For example, we can easily define a function sum_squares that, given any two numbers as arguments, returns the sum of their squares:  
>我们还可以使用 square 作为构建块来定义其他函数。例如，我们可以轻松定义一个函数 sum_squares ，它接受​​任意两个数字作为参数，返回它们的平方和：

```python
>>> def sum_squares(x, y):
        return add(square(x), square(y))

>>> sum_squares(3, 4)
25

```
User-defined functions are used in exactly the same way as built-in functions. Indeed, one cannot tell from the definition of sum_squares whether square is built into the interpreter, imported from a module, or defined by the user.  
>用户定义函数的使用方式与内置函数完全相同。事实上，我们无法从 sum_squares 的定义中判断 square 内置于解释器中、从模块导入或由用户定义。

Both def statements and assignment statements bind names to values, and any existing bindings are lost. For example, g below first refers to a function of no arguments, then a number, and then a different function of two arguments.  
>def 语句和赋值语句都会将名称绑定到值，并且所有现有的绑定都会丢失。例如，下面的 g 首先引用一个不带参数的函数，然后引用一个数字，最后引用另一个带两个参数的函数。

```python
>>> def g():
        return 1
>>> g()
1
>>> g = 2
>>> g
2
>>> def g(h, i):
        return h + i
>>> g(1, 2)
3
```

### 1.3.1   Environments  
1.3.1 环境

Our subset of Python is now complex enough that the meaning of programs is non-obvious. What if a formal parameter has the same name as a built-in function? Can two functions share names without confusion? To resolve such questions, we must describe environments in more detail.  
>我们的 Python 子集现在已经足够复杂，以至于程序的含义并不明显。如果一个形式参数与内置函数同名会怎么样？两个函数可以共享名称而不会造成混淆吗？为了解决这些问题，我们必须更详细地描述环境。

An environment in which an expression is evaluated consists of a sequence of `frames`, depicted as boxes. Each frame contains `bindings`, each of which associates a name with its corresponding value. There is a single `global frame`. Assignment and import statements add entries to the first frame of the current environment. So far, our environment consists only of the global frame.  
>表达式求值的环境由一系列 _框架_ ，用方框表示。每个框架包含_绑定_ ，每个绑定将一个名称与其对应的值关联起来。只有一个全局 框架。赋值和导入语句将条目添加到 当前环境。到目前为止，我们的环境仅由全局框架组成。

![[Pasted image 20250420212043.png]]

This _environment diagram_ shows the bindings of the current environment, along with the values to which names are bound. The environment diagrams in this text are interactive: you can step through the lines of the small program on the left to see the state of the environment evolve on the right. You can also click on the "Edit code in Online Python Tutor" link to load the example into the [Online Python Tutor](http://composingprograms.com/tutor.html), a tool created by [Philip Guo](http://www.pgbovine.net/) for generating these environment diagrams. You are encouraged to create examples yourself and study the resulting environment diagrams.  
>此环境图显示了当前环境的绑定，以及名称所绑定的值。本文中的环境图是交互式的：您可以单步执行左侧小程序的各行代码，以查看右侧环境状态的演变。您还可以点击“在在线 Python 教程中编辑代码”链接，将示例加载到[在线 Python 教程](http://composingprograms.com/tutor.html)中。在线 Python 教程是由 [Philip Guo](http://www.pgbovine.net/) 创建的用于生成这些环境图的工具。我们鼓励您自行创建示例并研究生成的环境图。

Functions appear in environment diagrams as well. An import statement binds a name to a built-in function. A def statement binds a name to a user-defined function created by the definition. The resulting environment after importing mul and defining square appears below:  
>函数也会出现在环境图中。 import 语句将名称绑定到内置函数。 def 语句将名称绑定到由定义创建的用户定义函数。导入 mul 并定义 square 后生成的环境如下所示：

![[Pasted image 20250420212003.png]]
Each function is a line that starts with func, followed by the function name and formal parameters. Built-in functions such as mul do not have formal parameter names, and so ... is always used instead.  
>每个函数占一行，以 func 开头，后跟函数名称和形式参数。内置函数（例如 mul ）没有形式参数名称，因此始终使用 ... 代替。

The name of a function is repeated twice, once in the frame and again as part of the function itself. The name appearing in the function is called the _intrinsic name_. The name in a frame is a _bound name_. There is a difference between the two: different names may refer to the same function, but that function itself has only one intrinsic name.  
>函数名称会重复两次，一次在框架中，另一次作为函数本身的一部分。函数中出现的名称称为_内在名称_ 。框架中的名称称为_绑定名称_ 。两者之间有一个区别：不同的名称可能指向同一个函数，但该函数本身只有一个内在名称。

The name bound to a function in a frame is the one used during evaluation. The intrinsic name of a function does not play a role in evaluation. Step through the example below using the _Forward_ button to see that once the name max is bound to the value 3, it can no longer be used as a function.  
>绑定到框架中函数的名称是求值期间使用的名称。函数的固有名称在求值中不起作用。使用 _“前进”_ 按钮逐步执行下面的示例，您会发现，一旦名称 max 绑定到值 3，它不再能用作函数。
![[Pasted image 20250420212240.png]]


The error message TypeError: 'int' object is not callable is reporting that the name max (currently bound to the number 3) is an integer and not a function. Therefore, it cannot be used as the operator in a call expression.  
>错误消息 TypeError: 'int' object is not callable 报告名称 max （当前绑定到数字 3）是一个整数，而不是函数。因此，它不能用作调用表达式中的运算符。

**Function Signatures.** Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined function square takes only x; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function's signature.  
>**函数签名。** 函数的参数数量各不相同。为了追踪这些要求，我们绘制每个函数，并显示函数名称及其形式参数。用户定义函数 square 仅接受 x ；提供更多或更少的参数都会导致错误。函数形式参数的描述称为函数签名。

The function max can take an arbitrary number of arguments. It is rendered as max(...). Regardless of the number of arguments taken, all built-in functions will be rendered as `<name>`(...), because these primitive functions were never explicitly defined.  
>函数 max 可以接受任意数量的参数。它会被渲染为 max(...) 。无论接受的参数数量是多少，所有内置函数都会被渲染为 `<name>`(...) ，因为这些原始函数从未被明确定义过。

### 1.3.2   Calling User-Defined Functions  
1.3.2 调用用户定义函数

To evaluate a call expression whose operator names a user-defined function, the Python interpreter follows a computational process. As with any call expression, the interpreter evaluates the operator and operand expressions, and then applies the named function to the resulting arguments.  
>为了求值一个运算符指向用户定义函数的调用表达式，Python 解释器遵循一个计算过程。与任何调用表达式一样，解释器先求值运算符和操作数表达式，然后将指定的函数应用于结果参数。

Applying a user-defined function introduces a second local frame, which is only accessible to that function. To apply a user-defined function to some arguments:  
>应用用户定义函数会引入第二个局部框架，该框架仅供该函数访问。要将用户定义函数应用于某些参数，请执行以下操作：

1. Bind the arguments to the names of the function's formal parameters in a new `local frame`.  
    >将参数绑定到函数形式参数的名称中 局部框架。
2. Execute the body of the function in the environment that starts with this frame.  
    >在以此框架开始的环境中执行函数主体。

The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else. Each instance of a function application has its own independent local frame.  
>函数体求值的环境由两个框架组成：首先是包含形式参数绑定的局部框架，然后是包含其他所有内容的全局框架。函数应用的每个实例都有自己独立的局部框架。

To illustrate an example in detail, several steps of the environment diagram for the same example are depicted below. After executing the first import statement, only the name mul is bound in the global frame.  
>为了详细地说明示例，下面描述了同一示例的环境图的几个步骤。执行第一个 import 语句后，只有名称 mul 绑定在全局框架中。

![[Pasted image 20250420213523.png]]

First, the definition statement for the function square is executed. Notice that the entire def statement is processed in a single step. The body of a function is not executed until the function is called (not when it is defined).  
>首先，执行函数 square 的定义语句。请注意，整个 def 语句在一个步骤中处理。函数主体直到函数被调用时才会执行（而不是在定义时）。


![[Pasted image 20250420213545.png]]


Next, The square function is called with the argument -2, and so a new frame is created with the formal parameter x bound to the value -2.  
>接下来，使用参数 -2 调用 square 函数，因此创建一个新框架，其形式参数 x 绑定到值 -2 。

![[Pasted image 20250420213632.png]]
Then, the name x is looked up in the current environment, which consists of the two frames shown. In both occurrences, x evaluates to -2, and so the square function returns 4.  
>然后，在当前环境（由所示的两个框架组成）中查找名称 x 。在两次查找中， x 的计算结果均为 -2 ，因此 square 函数返回 4。

![[Pasted image 20250420213700.png]]

The "Return value" in the square() frame is not a name binding; instead it indicates the value returned by the function call that created the frame.  
>square() 框架中的“返回值”不是名称绑定；而是表示创建该框架的函数调用返回的值。

Even in this simple example, two different environments are used. The top-level expression square(-2) is evaluated in the global environment, while the return expression mul(x, x) is evaluated in the environment created for by calling square. Both x and mul are bound in this environment, but in different frames.  
>即使在这个简单的示例中，也使用了两个不同的环境。顶级表达式 square(-2) 在全局环境中求值，而返回表达式 mul(x, x) 在通过调用 square 创建的环境中求值。 x 和 mul 都绑定在此环境中，但位于不同的框架中。

The order of frames in an environment affects the value returned by looking up a name in an expression. We stated previously that a name is evaluated to the value associated with that name in the current environment. We can now be more precise:  
>环境中帧的顺序会影响在表达式中查找名称所返回的值。我们之前提到，名称会被求值为当前环境中与该名称关联的值。现在我们可以更精确地表达：

**Name Evaluation.** A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.  
>**名称求值。** 名称的求值结果是在当前环境中找到该名称的最早帧中与该名称绑定的值。

Our conceptual framework of environments, names, and functions constitutes a _model of evaluation_; while some mechanical details are still unspecified (e.g., how a binding is implemented), our model does precisely and correctly describe how the interpreter evaluates call expressions. In Chapter 3 we will see how this model can serve as a blueprint for implementing a working interpreter for a programming language.  
>我们的环境、名称和功能的概念框架构成了一个 _求值模型_ ；虽然一些机制细节尚未明确（例如，绑定是如何实现的），但我们的模型确实精准且正确地描述了解释器如何求值调用表达式。在第三章中，我们将了解如何将此模型作为实现编程语言可用解释器的蓝图。

### 1.3.3   Example: Calling a User-Defined Function  
1.3.3 示例：调用用户定义函数

Let us again consider our two simple function definitions and illustrate the process that evaluates a call expression for a user-defined function.  
>让我们再次考虑我们的两个简单的函数定义，并说明评估用户定义函数的调用表达式的过程。

![[Pasted image 20250420214218.png]]

Python first evaluates the name sum_squares, which is bound to a user-defined function in the global frame. The primitive numeric expressions 5 and 12 evaluate to the numbers they represent.  
>Python 首先计算名称 sum_squares ，该名称绑定到全局框架中的一个用户定义函数。原始数值表达式 5 和 12 的计算结果为它们所表示的数字。

Next, Python applies sum_squares, which introduces a local frame that binds x to 5 and y to 12.  
>接下来，Python 应用 sum_squares ，它引入一个局部框架，将 x 绑定到 5，将 y 绑定到 12。

![[Pasted image 20250420214301.png]]



The body of sum_squares contains this call expression:  
>sum_squares 的主体包含此调用表达式：

  add     (  square(x)  ,  square(y)  )
________     _________     _________
operator     operand 0     operand 1

All three subexpressions are evaluated in the current environment, which begins with the frame labeled sum_squares(). The operator subexpression add is a name found in the global frame, bound to the built-in function for addition. The two operand subexpressions must be evaluated in turn, before addition is applied. Both operands are evaluated in the current environment beginning with the frame labeled sum_squares.  
>所有三个子表达式均在当前环境中求值，该环境从标有 sum_squares() 的框架开始。运算符子表达式 add 是在全局框架中找到的名称，绑定到内置函数 加法。两个操作数子表达式必须依次求值，然后 执行加法运算。两个操作数均在当前环境中求值 从标有 sum_squares 的框架开始。

In operand 0, square names a user-defined function in the global frame, while x names the number 5 in the local frame. Python applies square to 5 by introducing yet another local frame that binds x to 5.  
>在 operand 0 中， square 在全局框架中命名了一个用户定义函数，而 x 在局部框架中命名了数字 5。Python 通过引入另一个将 x 绑定到 5 的局部框架，将 square 应用于 5。

![[Pasted image 20250420214942.png]]
Using this environment, the expression mul(x, x) evaluates to 25.  
>使用此环境，表达式 mul(x, x) 的计算结果为 25。

Our evaluation procedure now turns to operand 1, for which y names the number 12. Python evaluates the body of square again, this time introducing yet another local frame that binds x to 12. Hence, operand 1 evaluates to 144.  
>我们的求值过程现在转向 operand 1 ，其中 y 表示数字 12。Python 再次求值 square 的主体，这次引入另一个将 x 绑定到 12 的局部框架。因此， operand 1 的求值结果为 144。

![[Pasted image 20250420215010.png]]


Finally, applying addition to the arguments 25 and 144 yields a final return value for sum_squares: 169.  
>最后，对参数 25 和 144 进行加法运算，得出 sum_squares 的最终返回值：169。

![[Pasted image 20250420215051.png]]

This example illustrates many of the fundamental ideas we have developed so far. Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called, even if the same function is called twice.  
>这个例子演示了我们迄今为止所发展的许多基本思想。名称与值绑定，这些值分布在多个独立的局部框架中，以及一个包含共享名称的全局框架中。每次调用函数时都会引入一个新的局部框架，即使同一个函数被调用两次。

All of this machinery exists to ensure that names resolve to the correct values at the correct times during program execution. This example illustrates why our model requires the complexity that we have introduced. All three local frames contain a binding for the name x, but that name is bound to different values in different frames. Local frames keep these names separate.  
>所有这些机制的存在都是为了确保在程序执行期间，名称在正确的时间解析为正确的值。此示例说明了为什么我们的模型需要引入上述复杂性。所有三个局部框架都包含名称 x 的绑定，但该名称在不同的框架中绑定到不同的值。局部框架将这些名称分开。

### 1.3.4   Local Names  
1.3.4 本地名称

One detail of a function's implementation that should not affect the function's behavior is the implementer's choice of names for the function's formal parameters. Thus, the following functions should provide the same behavior:  
>函数实现中一个不应该影响函数行为的细节是实现者对函数形参名称的选择。因此，以下函数应该提供相同的行为：


```python
>>> def square(x):
        return mul(x, x)
>>> def square(y):
        return mul(y, y)
```

This principle -- that the meaning of a function should be independent of the parameter names chosen by its author -- has important consequences for programming languages. The simplest consequence is that the ==parameter names of a function must remain local to the body of the function==.  
>这一原则——函数的含义应该与其作者选择的参数名称无关——对编程语言有着重要的影响。最简单的结论是，函数的参数名称必须局限于函数体本身。

If the parameters were not local to the bodies of their respective functions, then the parameter x in square could be confused with the parameter x in sum_squares. Critically, this is not the case: the binding for x in different local frames are unrelated. The model of computation is carefully designed to ensure this independence.  
>如果参数不是其各自函数体的本地参数，则 square 中的参数 x 可能会与 sum_squares 。关键在于，事实并非如此：不同局部框架中 x 的绑定是互不相关的。计算模型经过精心设计，以确保这种独立性。

We say that the `scope` of a local name is limited to the body of the user-defined function that defines it. When a name is no longer accessible, it is out of scope. This scoping behavior isn't a new fact about our model; it is a consequence of the way environments work.  
>我们说局部名称的作用域仅限于定义它的用户定义函数体。当名称不再可访问时，它就超出了作用域。这种作用域行为并非我们模型的新特性；它是环境工作方式的必然结果。

### 1.3.5   Choosing Names
1.3.5 选择名称

The interchangeability of names does not imply that formal parameter names do not matter at all. On the contrary, well-chosen function and parameter names are essential for the human interpretability of function definitions!  
>名称的可互换性并不意味着形式参数名称完全不重要。相反，精心选择的函数和参数名称对于函数定义的可解释性至关重要！

The following guidelines are adapted from the [style guide for Python code](http://www.python.org/dev/peps/pep-0008), which serves as a guide for all (non-rebellious) Python programmers. A shared set of conventions smooths communication among members of a developer community. As a side effect of following these conventions, you will find that your code becomes more internally consistent.  
>以下指南改编自 [《Python 代码风格指南》](http://www.python.org/dev/peps/pep-0008) ，该指南面向所有（非叛逆的）Python 程序员。一套共享的规范能够促进开发者社区成员之间的沟通顺畅。遵循这些规范的附带好处是，你会发现你的代码在内部更加一致。

1. Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.  
    >函数名称应小写，单词之间用下划线分隔。鼓励使用描述性名称。
2. Function names typically evoke operations applied to arguments by the interpreter (e.g., print, add, square) or the name of the quantity that results (e.g., max, abs, sum).  
    >函数名称通常会引起解释器对参数应用的操作（例如， print 、 add 、 square ）或产生的数量的名称（例如， max 、 abs 、 sum ）。
3. Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.  
    >参数名称应小写，单词之间用下划线分隔。建议使用单个单词命名。
4. Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.  
    >参数名称应该体现该参数在函数中的作用，而不仅仅是允许的参数类型。
5. Single letter parameter names are acceptable when their role is obvious, but avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid confusion with numerals.  
    >当其作用明显时，单字母参数名称是可以接受的，但要避免使用“l”（小写 ell）、“O”（大写 oh）或“I”（大写 i），以免与数字混淆。

There are many exceptions to these guidelines, even in the Python standard library. Like the vocabulary of the English language, Python has inherited words from a variety of contributors, and the result is not always consistent.  
>即使在 Python 标准库中，这些准则也存在许多例外。就像英语词汇一样，Python 继承了来自不同贡献者的词汇，其结果并不总是一致的。

### 1.3.6   Functions as Abstractions  
1.3.6 函数作为抽象

Though it is very simple, sum_squares exemplifies the most powerful property of user-defined functions. The function sum_squares is defined in terms of the function square, but relies only on the relationship that square defines between its input arguments and its output values.  
>虽然 sum_squares 非常简单，但它体现了用户定义函数最强大的特性。函数 sum_squares 是根据函数 square 定义的，但仅依赖于以下关系： square 在其输入参数和输出值之间进行定义。

We can write sum_squares without concerning ourselves with _how_ to square a number. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far as sum_squares is concerned, square is not a particular function body, but rather an abstraction of a function, a so-called `functional abstraction`. At this level of abstraction, any function that computes the square is equally good.  
>我们可以写出 sum_squares ，而不必考虑_如何_计算一个数的平方。平方计算的细节可以省略，留到以后再考虑。事实上，就 sum_squares 而言， square 并非一个特定的函数体，而是一个函数的抽象，即所谓的函数抽象。在这个抽象层次上，任何计算平方的函数都同样有效。

Thus, considering only the values they return, the following two functions for squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.  
>因此，仅考虑返回值，以下两个用于计算数字平方的函数应该是没有区别的。它们都接受一个数值参数，并返回该数值的平方作为返回值。

```python
>>> def square(x):
        return mul(x, x)
>>> def square(x):
        return mul(x, x-1) + x

```
In other words, a function definition should be able to suppress details. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a "`black box`". A programmer should not need to know how the function is implemented in order to use it. The Python Library has this property. Many developers use the functions defined there, but few ever inspect their implementation.  
>换句话说，函数定义应该能够隐藏细节。函数的使用者可能并非自己编写该函数，而是从其他程序员那里获取的，就像一个“黑盒”。程序员不应该需要知道该函数是如何实现的才能使用它。Python 库就具备这种特性。许多开发人员使用那里定义的函数，但很少有人检查它们的实现。

**Aspects of a functional abstraction.** To master the use of a functional abstraction, it is often useful to consider its three core attributes. The _`domain`_ of a function is the set of arguments it can take. The _`range`_ of a function is the set of values it can return. The _`intent`_ of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). ==Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.  ==
>**函数式抽象的各个方面。** 掌握函数式抽象的用法 抽象，考虑它的三个核心属性通常是有用的。 函数的定义域是它可以接受的参数集合。函数的值域是它可以返回的值的集合。函数的意图是它计算的输入和输出之间的关系（以及它可能产生的任何副作用）。通过定义域、值域和意图来理解函数抽象，对于在复杂程序中正确使用它们至关重要。

For example, any square function that we use to implement sum_squares should have these attributes:  
>例如，我们用来实现 sum_squares 的任何 square 函数 应该具有以下属性：

- The _domain_ is any single real number.  
    >_定义域_是任意单个实数。
- The _range_ is any non-negative real number.  
    >_范围_是任何非负实数。
- The _intent_ is that the output is the square of the input.  
    >_目的_是使输出为输入的平方。

These attributes do not specify how the intent is carried out; that detail is abstracted away.  
>这些属性没有指定如何执行意图；该细节被抽象掉了。

### 1.3.7   Operators 
1.3.7 运算符


Mathematical operators (such as + and -) provided our first example of a method of combination, but we have yet to define an evaluation procedure for expressions that contain these operators.  
>数学运算符（例如 + 和 - ）提供了我们组合方法的第一个示例，但我们尚未为包含这些运算符的表达式定义评估过程。

Python expressions with infix operators each have their own evaluation procedures, but you can often think of them as short-hand for call expressions. When you see  
>带有中缀运算符的 Python 表达式各自都有自己的求值过程，但你通常可以将它们视为调用表达式的简写。当你看到
```python

>>> 2 + 3
5
```

simply consider it to be short-hand for  
>简单地认为它是

```python

>>> add(2, 3)
5
```

Infix notation can be nested, just like call expressions. Python applies the normal mathematical rules of operator precedence, which dictate how to interpret a compound expression with multiple operators.  
>中缀表示法可以嵌套，就像调用表达式一样。Python 应用运算符优先级的常规数学规则，该规则规定了如何解释包含多个运算符的复合表达式。

```python
>>> 2 + 3 * 4 + 5
19
```

evaluates to the same result as  
>计算结果与

```python
>>> add(add(2, mul(3, 4)), 5)
19
```

The nesting in the call expression is more explicit than the operator version, but also harder to read. Python also allows subexpression grouping with parentheses, to override the normal precedence rules or make the nested structure of an expression more explicit.  
>调用表达式中的嵌套比运算符版本更明确，但也更难阅读。Python 还允许使用括号对子表达式进行分组，以覆盖常规的优先级规则或使表达式的嵌套结构更明确。

```python
>>> (2 + 3) * (4 + 5)
45
```

evaluates to the same result as  
>计算结果与

```python
>>> mul(add(2, 3), add(4, 5))
45

```
When it comes to division, Python provides two infix operators: / and //. The former is normal division, so that it results in a _floating point_, or decimal value, even if the divisor evenly divides the dividend:  
>对于除法，Python 提供了两个中缀运算符： / 和 // 。前者是普通除法，因此即使除数整除被除数，其结果也是_浮点数_或十进制值：

```python
>>> 5 / 4
1.25
>>> 8 / 4
2.0
```

The // operator, on the other hand, rounds the result down to an integer:  
>另一方面， // 运算符将结果向下舍入为整数：

```python
>>> 5 // 4
1
>>> -5 // 4
-2
```

These two operators are shorthand for the truediv and floordiv functions.  
这两个运算符分别是 truediv 和 floordiv 的简写 功能。

```python
>>> from operator import truediv, floordiv
>>> truediv(5, 4)
1.25
>>> floordiv(5, 4)
1
```

You should feel free to use infix operators and parentheses in your programs. Idiomatic Python prefers operators over call expressions for simple mathematical operations.  
>你可以在程序中随意使用中缀运算符和括号。对于简单的数学运算，惯用的 Python 语言更倾向于使用运算符而不是调用表达式。