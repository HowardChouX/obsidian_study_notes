A programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about computational processes. Programs serve to communicate those ideas among the members of a programming community. Thus, programs must be written for people to read, and only incidentally for machines to execute.  
>编程语言不仅仅是一种指示计算机执行任务的手段。它也是一个框架，让我们能够组织关于计算过程的思想。程序的作用是让编程社区的成员交流这些思想。因此，程序必须是为了人们阅读而编写的，而只是为了偶尔让机器执行。

When we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three such mechanisms:  
>当我们描述一种语言时，我们应该特别注意该语言提供的将简单概念组合成更复杂概念的方法。每种强大的语言都有三种这样的机制：

- **primitive expressions and statements**, which represent the simplest building blocks that the language provides,  
    >**原始表达式和语句** ，代表语言提供的最简单的构建块，
- **means of combination**, by which compound elements are built from simpler ones, and  
    >**组合方法** ，即由简单元素构成复合元素，以及
- **means of abstraction**, by which compound elements can be named and manipulated as units.  
    >**抽象手段** ，通过该手段可以将复合元素命名并作为单位进行操作。

In programming, we deal with two kinds of elements: functions and data. (Soon we will discover that they are really not so distinct.) Informally, data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.  
>在编程中，我们处理两种元素：函数和数据。（很快我们就会发现它们其实并没有那么明显的区别。）通俗地说，数据是我们想要操作的东西，而函数描述了操作数据的规则。因此，任何强大的编程语言都应该能够描述原始数据和原始函数，并且拥有一些组合和抽象函数和数据的方法。
---

### 1.2.1   Expressions 
1.2.1 表达式

Having experimented with the full Python interpreter in the previous section, we now start anew, methodically developing the Python language element by element. Be patient if the examples seem simplistic — more exciting material is soon to come.  
>在上一节中尝试了完整的 Python 解释器之后，我们现在重新开始，有条不紊地逐个开发 Python 语言的各个元素。如果示例看起来过于简单，请耐心等待——更多精彩内容即将推出。

We begin with primitive expressions. One kind of primitive expression is a number. More precisely, the expression that you type consists of the numerals that represent the number in base 10.  
我们从原始表达式开始。数字就是原始表达式的一种。更准确地说，你输入的表达式由十进制表示该数字的数字组成。
```python
>>>42
42
```

Expressions representing numbers may be combined with mathematical operators to form a compound expression, which the interpreter will evaluate:  
表示数字的表达式可以与数学运算符组合形成复合表达式，解释器将对其进行评估：
```python
>>> -1 - -1
0
>>> 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/128
0.9921875
```

These mathematical expressions use infix notation, where the _operator_ (e.g., +, -, \*, or /) appears in between the operands (numbers). Python includes many ways to form compound expressions. Rather than attempt to enumerate them all immediately, we will introduce new expression forms as we go, along with the language features that they support.  
>这些数学表达式使用中_缀_表示法，其中_运算符_ （例如， + 、 - 、 * 或 / ）出现在操作数之间 （数字）。Python 包含多种构成复合表达式的方法。 尝试立即列举它们，我们将引入新的表达 形式以及它们支持的语言特性。
---

### 1.2.2   Call Expressions  
1.2.2 调用表达式


The most important kind of compound expression is a _call expression_, which applies a function to some arguments. Recall from algebra that the mathematical notion of a function is a mapping from some input arguments to an output value. For instance, the max function maps its inputs to a single output, which is the largest of the inputs. The way in which Python expresses function application is the same as in conventional mathematics.  
>最重要的复合表达式是_调用表达式_ ，它将一个函数应用于一些参数。回想一下代数，函数的数学概念是从一些输入参数到输出值的映射。例如， max 函数将其输入映射到单个输出，该输出是所有输入中最大的一个。Python 表达函数应用的方式与传统数学相同。

```python
>>> max(7.5, 9.5)
9.5
```

This call expression has subexpressions: the _operator_ is an expression that precedes parentheses, which enclose a comma-delimited list of _operand_ expressions.  
>这个调用表达式有子表达式： _运算符_是一个位于括号之前的表达式，括号内包含一个逗号分隔的_操作数_列表 表達式。

![](https://www.composingprograms.com/img/call_expression.png)

The operator specifies a _function_. When this call expression is evaluated, we say that the function max is _called_ with _arguments_ 7.5 and 9.5, and _returns_ a _value_ of 9.5.  
>运算符指定一个_函数_ 。当这个调用表达式被求值时，我们说函数 max 被_调用_ ， _参数分别_为 7.5 和 9.5，并且 _返回__值_ 9.5。

The order of the arguments in a call expression matters. For instance, the function pow raises its first argument to the power of its second argument.  
调用表达式中参数的顺序很重要。例如，函数 pow 将其第一个参数的第二个参数的幂进行取整。

```python
>>> pow(100, 2)
10000
>>> pow(2, 100)
1267650600228229401496703205376

```
Function notation has three principal advantages over the mathematical convention of infix notation. First, functions may take an arbitrary number of arguments:  
>与数学中缀表示法相比，函数表示法主要有三个优点。首先，函数可以接受任意数量的参数：

```python
>>> max(1, -2, 3, -4)
3
```

No ambiguity can arise, because the function name always precedes its arguments.  
>不会出现歧义，因为函数名称始终位于其参数之前。

Second, function notation extends in a straightforward way to _nested_ expressions, where the elements are themselves compound expressions. In nested call expressions, unlike compound infix expressions, the structure of the nesting is entirely explicit in the parentheses.  
>其次，函数符号以直接的方式扩展到嵌套 表达式，其中元素本身是复合表达式。在嵌套 调用表达式与复合中缀表达式不同，其结构 括号中的嵌套非常明确。

```python
>>> max(min(1, -2), min(pow(3, 5), -4))
-2
```

There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Python interpreter can evaluate. However, humans quickly get confused by multi-level nesting. An important role for you as a programmer is to structure expressions so that they remain interpretable by yourself, your programming partners, and other people who may read your expressions in the future.  
>原则上，这种嵌套的深度以及 Python 解释器能够执行的表达式的整体复杂度没有限制。然而，多层嵌套很容易让人感到困惑。作为一名程序员，你的一个重要职责是构建表达式，使其能够被你本人、你的编程伙伴以及将来可能阅读你的表达式的其他人理解。

Third, mathematical notation has a great variety of forms: multiplication appears between terms, exponents appear as superscripts, division as a horizontal bar, and a square root as a roof with slanted siding. Some of this notation is very hard to type! However, all of this complexity can be unified via the notation of call expressions. While Python supports common mathematical operators using infix notation (like + and -), any operator can be expressed as a function with a name.  
>第三，数学符号的形式多种多样：乘法出现在项之间，指数以上标的形式出现，除法以水平线的形式出现，平方根则像一个带有倾斜墙板的屋顶。有些符号很难输入！然而，所有这些复杂性都可以通过调用表达式的符号来统一。虽然 Python 使用中缀符号支持常见的数学运算符（例如 + 和 - ），但任何运算符都可以表示为带有名称的函数。

---

### 1.2.3   Importing Library Functions  
1.2.3 导入库函数

Python defines a very large number of functions, including the operator functions mentioned in the preceding section, but does not make all of their names available by default. Instead, it organizes the functions and other quantities that it knows about into modules, which together comprise the Python Library. To use these elements, one imports them. For example, the math module provides a variety of familiar mathematical functions:  
Python 定义了大量函数，包括上一节提到的运算符函数，但默认情况下不会提供所有函数的名称。相反，它将已知的函数和其他数量组织到模块中，这些模块共同构成了 Python 库。要使用这些元素，需要导入它们。例如， math 模块提供了各种我们熟悉的数学函数：
```python
>>> from math import sqrt
>>> sqrt(256)
16.0
```
and the operator module provides access to functions corresponding to infix operators:  
并且 operator 模块提供对与中缀运算符对应的函数的访问：

```python
>>> from operator import add, sub, mul
>>> add(14, 28)
42
>>> sub(100, mul(7, add(8, 4)))
16
```


An import statement designates a module name (e.g., operator or math), and then lists the named attributes of that module to import (e.g., sqrt). Once a function is imported, it can be called multiple times.  
>import 语句指定模块名称（例如， operator 或 math )，然后列出要导入的模块的命名属性（例如， sqrt ). 函数一旦被导入，就可以多次调用。

There is no difference between using these operator functions (e.g., add) and the operator symbols themselves (e.g., +). Conventionally, most programmers use symbols and infix notation to express simple arithmetic.  
>使用这些运算符函数（例如 add ）和运算符符号本身（例如 + ）之间没有区别。通常，大多数程序员使用符号和中缀表示法来表达简单的算术运算。

The [Python 3 Library Docs](http://docs.python.org/py3k/library/index.html) list the functions defined by each module, such as the [math module](http://docs.python.org/py3k/library/math.html). However, this documentation is written for developers who know the whole language well. For now, you may find that experimenting with a function tells you more about its behavior than reading the documentation. As you become familiar with the Python language and vocabulary, this documentation will become a valuable reference source.  
>[Python 3 库文档](http://docs.python.org/py3k/library/index.html)列出了每个模块（例如 [math 模块）](http://docs.python.org/py3k/library/math.html) 定义的函数。然而，本文档是为熟悉 Python 的开发者编写的。目前，您可能会发现，实际操作函数比阅读文档更能了解其行为。随着您逐渐熟悉 Python 

---

### 1.2.4   Names and the Environment  
1.2.4 名称和环境



A critical aspect of a programming language is the means it provides for using names to refer to computational objects. If a value has been given a name, we say that the name _binds_ to the value.  
>编程语言的一个关键方面是它提供的使用名称引用计算对象的方法。如果一个值被赋予了名称，我们就说该名称与该值绑_ 。

In Python, we can establish new bindings using the assignment statement, which contains a name to the left of = and a value to the right:  
>在 Python 中，我们可以使用赋值语句建立新的绑定，该语句在 = 左侧包含一个名称，在右侧包含一个值：

```python
>>> radius = 10
>>> radius
10
>>> 2 * radius
20
```


Names are also bound via import statements.  
>名称也通过 import 语句绑定。

```python
>>> from math import pi
>>> pi * 71 / 223
1.0002380197528042
```

The = symbol is called the _assignment_ operator in Python (and many other languages). Assignment is our simplest means of _abstraction_, for it allows us to use simple names to refer to the results of compound operations, such as the area computed above. In this way, complex programs are constructed by building, step by step, computational objects of increasing complexity.  
>在 Python（以及许多其他语言）中， = 符号被称为赋值运算符。赋值是我们最简单的抽象方法，因为它允许我们 使用简单的名称来引用复合运算的结果，例如 area 如上所述进行计算。通过这种方式，复杂的程序是通过逐步构建越来越复杂的计算对象来构建的。

The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an ==environment==.  
>将名称绑定到值，然后通过以下方式检索这些值的可能性 名称意味着解释器必须维护某种内存来保存 跟踪名称、值和绑定。这种内存被称为环境 。

Names can also be bound to functions. For instance, the name max is bound to the max function we have been using. Functions, unlike numbers, are tricky to render as text, so Python prints an identifying description instead, when asked to describe a function:  
>名称也可以绑定到函数。例如，名称 max 绑定到了我们一直在使用的 max 函数。与数字不同，函数很难渲染为文本，因此当被要求描述函数时，Python 会打印一个标识性描述：

```python

>>> max
<built-in function max>

```
We can use assignment statements to give new names to existing functions.  
>我们可以使用赋值语句为现有函数赋予新名称。

```python
>>> f = max
>>> f
<built-in function max>
>>> f(2, 3, 4)
4

```
And successive assignment statements can rebind a name to a new value.  
>并且连续的赋值语句可以将名称重新绑定到新值。

```python
>>> f = 2
>>> f
2
```

In Python, names are often called _variable names_ or _variables_ because they can be bound to different values in the course of executing a program. When a name is bound to a new value through assignment, it is no longer bound to any previous value. One can even bind built-in names to new values.  
>在 Python 中，名称通常被称为变量名或变量 ，因为它们在程序执行过程中可以绑定到不同的值。当名称通过赋值绑定到新值时，它不再绑定到任何先前的值。甚至可以将内置名称绑定到新值。

```python
>>> max = 5
>>> max
5
```

After assigning max to 5, the name max is no longer bound to a function, and so attempting to call max(2, 3, 4) will cause an error.  
>将 max 分配给 5 后，名称 max 不再绑定到函数，因此尝试调用 max(2, 3, 4) 将导致错误。

When executing an assignment statement, Python evaluates the expression to the right of = before changing the binding to the name on the left. Therefore, one can refer to a name in right-side expression, even if it is the name to be bound by the assignment statement.  
>执行赋值语句时，Python 会先计算 = 右侧的表达式，然后再将绑定更改为左侧的名称。因此，即使右侧表达式中的名称是赋值语句要绑定的名称，也可以引用该名称。

```python
>>> x = 2
>>> x = x + 1
>>> x
3
```
We can also assign multiple values to multiple names in a single statement, where names on the left of = and expressions on the right of = are separated by commas.  
>我们还可以在单​​个语句中将多个值分配给多个名称，其中 = 左侧的名称和 = 右侧的表达式用逗号分隔。

```python
>>> area, circumference = pi * radius * radius, 2 * pi * radius
>>> area
314.1592653589793
>>> circumference
62.83185307179586
```

Changing the value of one name does not affect other names. Below, even though the name area was bound to a value defined originally in terms of radius, the value of area has not changed. Updating the value of area requires another assignment statement.  
>更改一个名称的值不会影响其他名称。下面，即使名称 area 绑定到最初根据以下方式定义的值 radius ， area 的值未发生改变。正在更新 area 需要另一个赋值语句。

```python
>>> radius = 11
>>> area
314.1592653589793
>>> area = pi * radius * radius
380.132711084365
```

With multiple assignment, _all_ expressions to the right of = are evaluated before _any_ names to the left are bound to those values. As a result of this rule, swapping the values bound to two names can be performed in a single statement.  
>使用多重赋值时， = 右侧的所有表达式都会先求值，然后左侧的任何名称才会绑定到这些值。根据此规则，可以在单个语句中交换绑定到两个名称的值。

```python
>>> x, y = 3, 4.5
>>> y, x = x, y
>>> x
4.5
>>> y
3
```

### 1.2.5   Evaluating Nested Expressions  
1.2.5 评估嵌套表达式

One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating ==nested call expressions==, the interpreter is itself following a procedure.  
>本章的目标之一是将程序化思考的问题分离出来。为了举例说明，我们假设在执行嵌套调用表达式时，解释器本身也在遵循一个过程。

To evaluate a call expression, Python will do the following:  
>为了评估调用表达式，Python 将执行以下操作：

1. Evaluate the operator and operand subexpressions, then  
    >计算运算符和操作数子表达式，然后
2. Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.  
    >将运算符子表达式的值作为函数应用于操作数子表达式的值作为参数。

Even this simple procedure illustrates some important points about processes in general. The first step dictates that in order to accomplish the evaluation process for a call expression we must first evaluate other expressions. Thus, the evaluation procedure is _recursive_ in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.  
>即使这个简单的过程也阐明了关于一般过程的一些重要要点。第一步规定，为了完成调用表达式的求值过程，我们必须首先求值其他表达式。因此，求值过程本质上是递归的 ；也就是说，它包含调用规则本身作为其步骤之一。

For example, evaluating  例如，评估

```python
>>> sub(pow(2, add(1, 10)), pow(2, 5))
2016
```

requires that this evaluation procedure be applied four times. If we draw each expression that we evaluate, we can visualize the hierarchical structure of this process.  
>要求这个求值过程应用四次。如果我们画出每个求值的表达式，就能直观地看到这个过程的层次结构。

![](https://www.composingprograms.com/img/expression_tree.png)

This illustration is called an ==expression tree==. In computer science, trees conventionally grow from the top down. The objects at each point in a tree are called nodes; in this case, they are expressions paired with their values.  
>此图称为表达式树 。在计算机科学中，树通常自上而下生长。树中每个点的对象称为节点；在这种情况下，它们是与其值配对的表达式。

Evaluating its ==root==, the full expression at the ==top==, requires first evaluating the branches that are its subexpressions. The leaf expressions (that is, nodes with no branches stemming from them) represent either functions or numbers. The interior nodes have two parts: the call expression to which our evaluation rule is applied, and the result of that expression. Viewing evaluation in terms of this tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels.  
>要求出它的根，即位于顶部的完整表达式，首先需要求出其子表达式的分支。叶表达式（即没有分支的节点）表示函数或数字。内部节点包含两部分：应用求值规则的调用表达式，以及该表达式的结果。从这棵树的角度来看待求值，我们可以想象操作数的值向上渗透，从终端节点开始，然后在越来越高的层级上进行组合。

Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not call expressions, but primitive expressions such as numerals (e.g., 2) and names (e.g., add). We take care of the primitive cases by stipulating that  
>接下来，我们注意到，重复执行第一步，我们最终需要求值的不是调用表达式，而是原始表达式，例如数字（例如 2）和名称（例如 add ）。我们通过规定以下内容来处理原始情况：

- A numeral evaluates to the number it names,  
    >一个数字的计算结果就是它所指的数字，
- A name evaluates to the value associated with that name in the current environment.  
    >名称的计算结果为当前环境中与该名称关联的值。

Notice the important role of an environment in determining the meaning of the symbols in expressions. In Python, it is meaningless to speak of the value of an expression such as  
>注意环境在确定表达式中符号含义方面的重要作用。在 Python 中，讨论如下表达式的值是没有意义的：

```python
>>> add(x, 1)
```

without specifying any information about the environment that would provide a meaning for the name x (or even for the name add). Environments provide the context in which evaluation takes place, which plays an important role in our understanding of program execution.  
>无需指定任何与环境相关的信息，这些信息无法为名称 x （甚至名称 add ）提供含义。环境提供了执行的上下文，这对于我们理解程序的执行起着重要作用。

This evaluation procedure does not suffice to evaluate all Python code, only call expressions, numerals, and names. For instance, it does not handle assignment statements. Executing  
>此求值过程不足以求值所有 Python 代码，仅能调用表达式、数字和名称。例如，它不处理赋值语句。执行

```python
>>> x = 3
```

does not return a value nor evaluate a function on some arguments, since the purpose of assignment is instead to bind a name to a value. In general, statements are not evaluated but _executed_; they do not produce a value but instead make some change. Each type of expression or statement has its own evaluation or execution procedure.  
>不会返回值，也不会对某些参数执行函数求值，因为赋值的目的是将名称绑定到值。通常，语句不会被求值，而是会被执行 ；它们不会产生值，而是会进行一些更改。每种类型的表达式或语句都有其自身的求值或执行过程。

A pedantic note: when we say that "a numeral evaluates to a number," we actually mean that the Python interpreter evaluates a numeral to a number. It is the interpreter which endows meaning to the programming language. Given that the interpreter is a fixed program that always behaves consistently, we can say that numerals (and expressions) themselves evaluate to values in the context of Python programs.  
需要注意的是：当我们说“一个数字求值为一个数字”时，实际上是指 Python 解释器将一个数字求值为一个数字。正是解释器赋予了编程语言意义。鉴于解释器是一个始终行为一致的固定程序，我们可以说，在 Python 程序的上下文中，数字（和表达式）本身求值为值。

### 1.2.6   The Non-Pure Print Function  
1.2.6 非纯打印功能



Throughout this text, we will distinguish between two types of functions.  
>在本文中，我们将区分两种类型的函数。

**Pure functions.** Functions have some input (their arguments) and return some output (the result of applying them). ==The built-in function==  
**纯函数。** 函数有一些输入（它们的参数），并返回一些输出（应用它们的结果）。内置函数

```python
>>> abs(-2)
2
```

can be depicted as a small machine that takes input and produces output.  
>可以将其描绘成一个接受输入并产生输出的小型机器。

![](https://www.composingprograms.com/img/function_abs.png)

The function abs is _pure_. Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.  
>函数 abs 是纯函数。纯函数的特性是，除了返回一个值之外，调用它们不会产生任何效果。此外，纯函数在使用相同参数调用两次时，必须始终返回相同的值。

**Non-pure functions.** In addition to returning a value, applying a non-pure function can generate _side effects_, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.  
>**非纯函数。** 除了返回值之外，应用非纯函数还会产生副作用 ，从而改变解释器或计算机的状态。一种常见的副作用是使用 print 函数，除了返回值之外，还会生成额外的输出。

```python
>>> print(1, 2, 3)
1 2 3
```

While print and abs may appear to be similar in these examples, they work in fundamentally different ways. The value that print returns is always None, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value None. In the case of print, the function itself is printing output as a side effect of being called.  
>虽然 print 和 abs 在这些示例中看起来相似，但它们的工作方式却截然不同。 print 返回的值始终是 None ，这是一个特殊的 Python 值，不代表任何内容。交互式 Python 解释器不会自动打印值 None 。对于 print ，函数本身会打印输出，这是被调用的副作用。

![](https://www.composingprograms.com/img/function_print.png)

A nested expression of calls to print highlights the non-pure character of the function.  
>对 print 的嵌套调用表达式凸显了该函数的非纯特性。

```python
>>> print(print(1), print(2))
1
2
None None
```
If you find this output to be unexpected, draw an expression tree to clarify why evaluating this expression produces this peculiar output.  
>如果您发现此输出是意外的，请绘制一个表达式树来阐明为什么评估此表达式会产生这种特殊的输出。

Be careful with print! The fact that it returns None means that it _should not_ be the expression in an assignment statement.  
>小心使用 print ！它返回 None 意味着 不应是赋值语句中的表达式。

```python
>>> two = print(2)
2
>>> print(two)
None
```

Pure functions are restricted in that they cannot have side effects or change behavior over time. Imposing these restrictions yields substantial benefits. First, pure functions can be composed more reliably into compound call expressions. We can see in the non-pure function example above that print does not return a useful result when used in an operand expression. On the other hand, we have seen that functions such as max, pow and sqrt can be used effectively in nested expressions.  
>纯函数的限制在于它们不能产生副作用，也不能随时间改变行为。施加这些限制会带来显著的好处。首先，纯函数可以更可靠地组合成复合调用表达式。我们可以在上面的非纯函数示例中看到， print 在操作数表达式中使用时不会返回有用的结果。在 另一方面，我们已经看到诸如 max 、 pow 和 sqrt 之类的函数 可以在嵌套表达式中有效使用。

Second, pure functions tend to be simpler to test. A list of arguments will always lead to the same return value, which can be compared to the expected return value. Testing is discussed in more detail later in this chapter.  
>其次，纯函数测试起来更容易。一系列参数总是会返回相同的值，可以将其与预期返回值进行比较。本章稍后将更详细地讨论测试。

Third, Chapter 4 will illustrate that pure functions are essential for writing concurrent programs, in which multiple call expressions may be evaluated simultaneously.  
>第三，第 4 章将说明纯函数对于编写 并发程序，其中可以同时评估多个调用表达式。

By contrast, Chapter 2 investigates a range of non-pure functions and describes their uses.  
>相比之下，第 2 章研究了一系列非纯函数并描述了它们的用途。

For these reasons, we concentrate heavily on creating and using pure functions in the remainder of this chapter. The print function is only used so that we can see the intermediate results of computations.  
>出于这些原因，本章的其余部分将重点介绍纯函数的创建和使用。 print 函数仅用于查看计算的中间结果。