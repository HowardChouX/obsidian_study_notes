The expressive power of the functions that we can define at this point is very limited, because we have not introduced a way to make comparisons and to perform different operations depending on the result of a comparison. _Control statements_ will give us this ability. They are statements that control the flow of a program's execution based on the results of logical comparisons.  
>目前我们能定义的函数的表达能力非常有限，因为我们还没有引入一种进行比较的方法，以及根据比较结果执行不同操作的方法。 _控制语句_ 将赋予我们这种能力。它们是控制 根据逻辑比较的结果来执行程序。

Statements differ fundamentally from the expressions that we have studied so far. They have no value. Instead of computing something, executing a control statement determines what the interpreter should do next.  
>语句与我们目前为止学习过的表达式有着根本的不同。它们没有值。执行控制语句并不计算某些内容，而是决定解释器下一步该做什么。

### 1.5.1   Statements  
1.5.1 语句

So far, we have primarily considered how to evaluate expressions. However, we have seen three kinds of statements already: assignment, def, and return statements. These lines of Python code are not themselves expressions, although they all contain expressions as components.  
>到目前为止，我们主要讨论了如何对表达式求值。不过，我们已经了解了三种语句：赋值、 def 和 return 语句。这些 Python 代码行本身不是表达式，尽管它们都包含表达式作为组成部分。

Rather than being evaluated, statements are _executed_. Each statement describes some change to the interpreter state, and executing a statement applies that change. As we have seen for return and assignment statements, executing statements can involve evaluating subexpressions contained within them.  
>语句不是被求值，而是_被执行_ 。每个语句都描述了解释器状态的一些变化，执行语句会应用这些变化。正如我们在 return 和赋值语句中看到的，执行语句可能涉及求值其中包含的子表达式。

Expressions can also be executed as statements, in which case they are evaluated, but their value is discarded. Executing a pure function has no effect, but executing a non-pure function can cause effects as a consequence of function application.  
>表达式也可以作为语句执行，在这种情况下，它们会被求值，但其值会被丢弃。执行纯函数不会产生任何效果，但执行非纯函数可能会因函数应用而产生效果。

Consider, for instance,  例如，考虑一下，

```python
>>> def square(x):
        mul(x, x) # Watch out! This call doesn't return a value.

```
This example is valid Python, but probably not what was intended. The body of the function consists of an expression. An expression by itself is a valid statement, but the effect of the statement is that the mul function is called, and the result is discarded. If you want to do something with the result of an expression, you need to say so: you might store it with an assignment statement or return it with a return statement:  
>此示例是有效的 Python 代码，但可能并非预期。函数主体由一个表达式组成。表达式本身是有效的语句，但该语句的效果是调用 mul 函数，并丢弃结果。如果您想对表达式的结果执行某些操作，则需要明确说明：您可以使用赋值语句存储它，或使用 return 语句返回它：

```python
>>> def square(x):
        return mul(x, x)
```

Sometimes it does make sense to have a function whose body is an expression, when a non-pure function like print is called.  
>有时，当调用非纯函数（如 print ）时，函数主体是表达式是有意义的。

```python
>>> def print_square(x):
        print(square(x))
```

At its highest level, the Python interpreter's job is to execute programs, composed of statements. However, much of the interesting work of computation comes from evaluating expressions. Statements govern the relationship among different expressions in a program and what happens to their results.  
>从最高层次来看，Python 解释器的工作是执行由语句组成的程序。然而，许多有趣的计算工作来自于对表达式的求值。语句控制着程序中不同表达式之间的关系以及它们的结果如何处理。

### 1.5.2   Compound Statements  
1.5.2 复合语句

In general, Python code is a sequence of statements. A simple statement is a single line that doesn't end in a colon. A compound statement is so called because it is composed of other statements (simple and compound). Compound statements typically span multiple lines and start with a one-line header ending in a colon, which identifies the type of statement. Together, a header and an indented suite of statements is called a clause. A compound statement consists of one or more clauses:  
>通常，Python 代码由一系列语句组成。简单语句是一行不以冒号结尾的语句。复合语句之所以如此命名，是因为它由其他语句（简单语句和复合语句）组成。复合语句通常跨越多行，并以一行以冒号结尾的语句头开头，该语句头标识了语句的类型。语句头和一组缩进的语句合称为子句。复合语句由一个或多个子句组成：

```python
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```

We can understand the statements we have already introduced in these terms.  
>我们可以用这些术语来理解我们已经介绍过的陈述。

- Expressions, return statements, and assignment statements are simple statements.  
    >表达式、返回语句和赋值语句都是简单语句。
- A def statement is a compound statement. The suite that follows the def header defines the function body.  
    >def 语句是复合语句。 def 标头定义函数主体。

Specialized evaluation rules for each kind of header dictate when and if the statements in its suite are executed. We say that the header controls its suite. For example, in the case of def statements, we saw that ==the return expression is not evaluated immediately, but instead stored for later use when the defined function is eventually called==.  
>每种头文件都有专门的求值规则，规定了其语句套件中的语句何时以及是否执行。我们称头文件控制其语句套件。例如，在 def 语句中，我们看到返回表达式不会立即被求值，而是被存储起来，以便在最终调用定义的函数时使用。

We can also understand multi-line programs now.  
>我们现在也可以理解多行程序了。

- To execute a sequence of statements, execute the first statement. If that statement does not redirect control, then proceed to execute the rest of the sequence of statements, if any remain.  
    >要执行语句序列，请先执行第一个语句。如果该语句未重定向控制，则继续执行语句序列的其余部分（如果还有剩余）。

This definition exposes the essential structure of a recursively defined _sequence_: a sequence can be decomposed into its first element and the rest of its elements. The "rest" of a sequence of statements is itself a sequence of statements! Thus, we can recursively apply this execution rule. This view of sequences as recursive data structures will appear again in later chapters.  
>这个定义揭示了递归定义的本质结构 _序列_ ：序列可以分解为其第一个元素和其余元素。语句序列的“其余部分”本身也是一个语句序列！因此，我们可以递归地应用此执行规则。这种将序列视为递归数据结构的观点将在后续章节中再次出现。

The important consequence of this rule is that statements are executed in order, but later statements may never be reached, because of redirected control.  
>该规则的重要结果是语句按顺序执行，但由于控制重定向，后面的语句可能永远不会被执行。

**Practical Guidance.** When indenting a suite, all lines must be indented the same amount and in the same way (use spaces, not tabs). Any variation in indentation will cause an error.  
>**实用指南。** 缩进代码组时，所有行必须以相同的缩进量和方式缩进（使用空格，而不是制表符）。任何缩进量的变化都会导致错误。

### 1.5.3   Defining Functions II: Local Assignment  
1.5.3 定义函数二：局部赋值

Originally, we stated that the body of a user-defined function consisted only of a return statement with a single return expression. In fact, functions can define a sequence of operations that extends beyond a single expression.  
>最初，我们指出用户定义函数的主体仅由一个 return 语句和一个返回表达式组成。实际上，函数可以定义一系列超出单个表达式的操作。

Whenever a user-defined function is applied, the sequence of clauses in the suite of its definition is executed in a local environment — an environment starting with a local frame created by calling that function. A return statement redirects control: the process of function application terminates whenever the first return statement is executed, and the value of the return expression is the returned value of the function being applied.  
>每当应用用户定义函数时，其定义套件中的子句序列都会在局部环境中执行 - 该环境以通过调用该函数创建的局部框架开始。 return 语句重定向控制：函数应用程序的进程终止 每当执行第一个 return 语句时， return 表达式是所应用函数的返回值。

Assignment statements can appear within a function body. For instance, this function returns the absolute difference between two quantities as a percentage of the first, using a two-step calculation:  
>赋值语句可以出现在函数体中。例如，此函数使用两步计算，返回两个量之间的绝对差，以第一个量的百分比表示：

![[Pasted image 20250421095220.png]]

The effect of an assignment statement is to bind a name to a value in the _first_ frame of the current environment. As a consequence, assignment statements within a function body cannot affect the global frame. The fact that functions can only manipulate their local environment is critical to creating _modular_ programs, in which pure functions interact only via the values they take and return.  
>赋值语句的作用是将名称绑定到 当前环境的_第一个_框架。因此，函数体中的赋值语句不能影响全局框架。函数只能操作其局部环境这一事实对于创建_模块化_程序至关重要，在模块化程序中，纯函数仅通过其接受和返回的值进行交互。

Of course, the percent_difference function could be written as a single expression, as shown below, but the return expression is more complex.  
>当然， percent_difference 函数可以写成单个表达式，如下所示，但返回表达式更为复杂。

```python
>>> def percent_difference(x, y):
        return 100 * abs(x-y) / x
>>> percent_difference(40, 50)
25.0
```

So far, local assignment hasn't increased the expressive power of our function definitions. It will do so, when combined with other control statements. In addition, local assignment also plays a critical role in clarifying the meaning of complex expressions by assigning names to intermediate quantities.  
>到目前为止，局部赋值还没有提升函数定义的表达能力。但当它与其他控制语句结合使用时，就会有所提升。此外，局部赋值还通过为中间量赋值，在阐明复杂表达式的含义方面发挥着至关重要的作用。

### 1.5.4   Conditional Statements  
1.5.4 条件语句


Python has a built-in function for computing absolute values.  
>Python 有一个用于计算绝对值的内置函数。

```python
>>> abs(-2)
2
```


We would like to be able to implement such a function ourselves, but we have no obvious way to define a function that has a comparison and a choice. We would like to express that if x is positive, abs(x) returns x. Furthermore, if x is 0, abs(x) returns 0. Otherwise, abs(x) returns -x. In Python, we can express this choice with a `conditional statement`.  
>我们希望能够自己实现这样的函数，但我们没有明显的方法来定义一个包含比较和选择的函数。我们希望表达的是，如果 x 为正，则 abs(x) 返回 x 。此外，如果 x 为 0，则 abs(x) 返回 0。否则， abs(x) 返回 -x . 在 Python 中，我们可以用条件语句来表达这种选择。


![[Pasted image 20250421095734.png]]


**Conditional statements**. A conditional statement in Python consists of a series of headers and suites: a required if clause, an optional sequence of elif clauses, and finally an optional else clause:  
>**条件语句** 。Python 中的条件语句由一系列头和语句套件组成：必需的 if 子句、可选的 elif 子句，最后是可选的 else 子句：

```python
if <expression>:
    <suite>
elif <expression>:
    <suite>
else:
    <suite>
```

When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.  
>执行条件语句时，每个子句都会按顺序考虑。执行条件子句的计算过程如下。

1. Evaluate the header's expression.  
    >评估标题的表达式。
2. If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.  
    >如果为真，则执行该语句。然后，跳过条件语句中所有后续子句。

If the else clause is reached (which only happens if all if and elif expressions evaluate to false values), its suite is executed.  
>如果达到 else 子句（仅当所有 if 和 elif 都满足时才会发生这种情况） 如果表达式的计算结果为假值，则执行其子句。

**Boolean contexts**. Above, the execution procedures mention "a false value" and "a true value." The expressions inside the header statements of conditional blocks are said to be in _boolean contexts_: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including 0, None, and the _boolean_ value False. All other numbers are true values. In Chapter 2, we will see that every built-in kind of data in Python has both true and false values.  
>**布尔上下文** 。上文中，执行过程提到了“假值”和“真值”。条件块头部语句中的表达式被称为_布尔上下文_ ：它们的真值对控制流很重要，但除此之外，它们的值不会被赋值或返回。Python 包含几个假值，包括 0、 None 和_布尔_值 False 。所有其他数字均为真值。在第二章中，我们将看到 Python 中每种内置数据都既有真值，也有假值。

**Boolean values**. Python has two boolean values, called True and False. Boolean values represent truth values in logical expressions. The built-in comparison operations, >, <, >=, <=, \=\=, !=, return these values.  
>**布尔值** 。Python 有两个布尔值，分别为 True 和 布尔值表示逻辑表达式中的真值。内置比较运算 >, <, >=, <=, \=\=, != 返回这些值。

```python
>>> 4 < 2
False
>>> 5 >= 5
True
```

This second example reads "5 is greater than or equal to 5", and corresponds to the function ge in the operator module.  
第二个示例读作“5 大于或等于 5”，对应于 operator 模块中的函数 ge 。

```python
>>> 0 == -0
True
```

This final example reads "0 equals -0", and corresponds to eq in the operator module. Notice that Python distinguishes assignment (=) from equality comparison (\=\=), a convention shared across many programming languages.  
>最后一个例子是“0 等于 -0”，对应于 operator 模块。请注意，Python 区分赋值 ( = ) 和相等性比较 ( == )，这是许多编程语言共享的惯例。

**Boolean operators**. Three basic logical operators are also built into Python:  
>**布尔运算符** 。Python 还内置了三个基本逻辑运算符：

```python
>>> True and False
False
>>> True or False
True
>>> not False
True
```

Logical expressions have corresponding evaluation procedures. These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called _short-circuiting_.  
>逻辑表达式有相应的求值程序。这些程序 利用逻辑表达式的真值有时可以 无需评估所有子表达式即可确定，此功能称为 _短路_ 。

To evaluate the expression `<left> and <right>`:  
>要计算表达式 `<left> and <right>` ：

1. Evaluate the subexpression `<left>`.  
    >计算子表达式 `<left>` 。
2. If the result is a false value v, then the expression evaluates to v.  
    >如果结果为假值 v ，则表达式的计算结果为 v 。
3. Otherwise, the expression evaluates to the value of the subexpression `<right>`.  
    >否则，表达式计算子表达式的值 `<right>` .

To evaluate the expression `<left> or <right>`:  
>要计算表达式 `<left> or <right>` ：

1. Evaluate the subexpression `<left>`.  
    >计算子表达式 `<left>` 。
2. If the result is a true value v, then the expression evaluates to v.  
    >如果结果为真值 v ，则表达式的计算结果为 v 。
3. Otherwise, the expression evaluates to the value of the subexpression `<right>`.  
    >否则，表达式计算子表达式的值 `<right>` .

To evaluate the expression not` <exp>`:  
>要计算表达式 not `<exp>` ：

1. Evaluate `<exp>`; The value is True if the result is a false value, and False otherwise.  
    >评估 `<exp>` ；如果结果为假值，则值为 True ，并且 否则， False 。

These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with is, not followed by an underscore (e.g., isfinite, isdigit, isinstance, etc.).  
>这些值、规则和运算符为我们提供了一种组合比较结果的方法。执行比较并返回布尔值的函数通常以 is 开头，而不是后跟下划线（例如 isfinite ， isdigit 、 isinstance 等）。

### 1.5.5   Iteration 
1.5.5 迭代

In addition to selecting which statements to execute, control statements are used to express repetition. If each line of code we wrote were only executed once, programming would be a very unproductive exercise. Only through repeated execution of statements do we unlock the full potential of computers. We have already seen one form of repetition: a function can be applied many times, although it is only defined once. Iterative control structures are another mechanism for executing the same statements many times.  
>除了选择要执行的语句外，控制语句还用于表示重复。如果我们编写的每一行代码都只执行一次，编程将是一项非常低效的工作。只有通过重复执行语句，我们才能释放计算机的全部潜力。我们已经了解了一种重复的形式：一个函数可以多次应用，尽管它只定义一次。迭代控制结构是另一种多次执行相同语句的机制。

Consider the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:  
>考虑斐波那契数列，其中每个数字都是前两个数字之和：

0, 1, 1, 2, 3, 5, 8, 13, 21, ...

Each value is constructed by repeatedly applying the sum-previous-two rule. The first and second are fixed to 0 and 1. For instance, the eighth Fibonacci number is 13.  
>每个值都是通过重复应用“前两个和”规则构建的。第一个值和第二个值固定为 0 和 1。例如，第八个斐波那契数是 13。

We can use a while statement to enumerate n Fibonacci numbers. We need to track how many values we've created (k), along with the kth value (curr) and its predecessor (pred). Step through this function and observe how the Fibonacci numbers evolve one by one, bound to curr.  
>我们可以使用 while 语句枚举 n 个斐波那契数列。我们需要跟踪已创建的值的数量 ( k )，以及第 k 个值 ( curr ) 及其前一个值 ( pred )。单步执行此函数，观察斐波那契数列如何逐个演变，最终逼近 curr 。

![[Pasted image 20250421101329.png]]


Remember that commas seperate multiple names and values in an assignment statement. The line:  
>请记住，赋值语句中逗号分隔多个名称和值。以下代码行：

```python
pred, curr = curr, pred + curr
```

has the effect of rebinding the name pred to the value of curr, and simultanously rebinding curr to the value of pred + curr. All of the expressions to the right of = are evaluated before any rebinding takes place.  
>其效果是将名称 pred 重新绑定到值 curr ，同时将 curr 重新绑定到值 pred + curr 。在执行任何重新绑定之前，会先计算 = 右侧的所有表达式的值。

This order of events -- evaluating everything on the right of = before updating any bindings on the left -- is essential for correctness of this function.  
>此事件顺序 —— 在更新左侧的任何绑定之前评估 = 右侧的所有内容 —— 对于此功能的正确性至关重要。

A while clause contains a header expression followed by a suite:  
>while 子句包含一个标题表达式，后跟一个套件：

```python
while <expression>:
    <suite>
```

To execute a while clause:  
>要执行 while 子句：

1. Evaluate the header's expression.  
    >评估标题的表达式。
2. If it is a true value, execute the suite, then return to step 1.  
    >如果是真值，则执行该套件，然后返回步骤 1。

In step 2, the entire suite of the while clause is executed before the header expression is evaluated again.  
>在步骤 2 中，在再次评估标题表达式之前，将执行整个 while 子句套件。

In order to prevent the suite of a while clause from being executed indefinitely, the suite should always change some binding in each pass.  
>为了防止 while 子句的套件被无限期地执行，该套件应该在每次执行中始终更改一些绑定。

A while statement that does not terminate is called an infinite loop. Press `<Control>`-C to force Python to stop looping.  
>无法终止的 while 语句称为无限循环。按 `<Control>`-C 可强制 Python 停止循环。

### 1.5.6   Testing 
1.5.6 测试

_Testing_ a function is the act of verifying that the function's behavior matches expectations. Our language of functions is now sufficiently complex that we need to start testing our implementations.  
>_测试_函数是验证函数行为是否符合预期的行为。我们的函数语言现在已经足够复杂，我们需要开始测试我们的实现。

A _test_ is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.  
>_测试_是一种系统地执行此验证的机制。测试通常采用另一个函数的形式，其中包含对被测函数的一个或多个示例调用。然后，根据预期结果验证返回值。与大多数旨在通用的函数不同，测试涉及选择和验证具有特定参数值的调用。测试还可以作为文档：它们演示如何调用函数以及哪些参数值合适。

**Assertions.** Programmers use assert statements to verify expectations, such as the output of a function being tested. An assert statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.  
>**断言。** 程序员使用 assert 语句来验证预期结果，例如被测试函数的输出。 assert 语句包含一个布尔表达式，后跟一行带引号的文本（单引号或双引号均可，但需保持一致），当表达式计算结果为假时，将显示该文本。

```python
>>> assert fib(8) == 13, 'The 8th Fibonacci number should be 13'
```

When the expression being asserted evaluates to a true value, executing an assert statement has no effect. When it is a false value, assert causes an error that halts execution.  
>当被断言的表达式计算结果为真值时，执行断言语句没有任何效果。当其计算结果为假值时， assert 会导致错误并停止执行。

A test function for fib should test several arguments, including extreme values of n.  
>fib 的测试函数应该测试几个参数，包括 n 的极值。

```python
>>> def fib_test():
        assert fib(2) == 1, 'The 2nd Fibonacci number should be 1'
        assert fib(3) == 1, 'The 3rd Fibonacci number should be 1'
        assert fib(50) == 7778742049, 'Error at the 50th Fibonacci number'
```
When writing Python in files, rather than directly into the interpreter, tests are typically written in the same file or a neighboring file with the suffix _test.py.  
>当在文件中编写 Python 代码而不是直接在解释器中编写代码时，测试 通常写在同一个文件或带有后缀的相邻文件中 _test.py .

**Doctests.** Python provides a convenient method for placing simple tests directly in the docstring of a function. The first line of a docstring should contain a one-line description of the function, followed by a blank line. A detailed description of arguments and behavior may follow. In addition, the docstring may include a sample interactive session that calls the function:  
>**文档测试。Python** 提供了一种便捷的方法，可以将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应该包含一行函数描述，后面跟着一个空行。接下来可以包含参数和行为的详细描述。此外，文档字符串还可以包含一个调用该函数的示例交互式会话：

```python
>>> def sum_naturals(n):
        """Return the sum of the first n natural numbers.

        >>> sum_naturals(10)
        55
        >>> sum_naturals(100)
        5050
        """
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total

```
Then, the interaction can be verified via the [doctest module](http://docs.python.org/py3k/library/doctest.html). Below, the globals function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions.  
>然后，可以通过 [doctest 模块](http://docs.python.org/py3k/library/doctest.html)验证交互。下面， globals 函数返回全局环境的表示形式，解释器需要它来评估表达式。

```python
>>> from doctest import testmod
>>> testmod()
TestResults(failed=0, attempted=2)
```
To verify the doctest interactions for only a single function, we use a doctest function called run_docstring_examples. This function is (unfortunately) a bit complicated to call. Its first argument is the function to test. The second should always be the result of the expression globals(), a built-in function that returns the global environment. The third argument is True to indicate that we would like "verbose" output: a catalog of all tests run.  
>为了验证单个函数的 doctest 交互，我们使用 doctest 函数调用了 run_docstring_examples 。该函数 （不幸的是）调用起来有点复杂。它的第一个参数是函数 进行测试。第二个应该始终是表达式的结果 globals() 是一个内置函数，用于返回全局环境。第三个参数是 True ，表示我们需要“详细”的输出：所有运行测试的目录。

```python
>>> from doctest import run_docstring_examples
>>> run_docstring_examples(sum_naturals, globals(), True)
Finding tests in NoName
Trying:
    sum_naturals(10)
Expecting:
    55
ok
Trying:
    sum_naturals(100)
Expecting:
    5050
ok
```

When the return value of a function does not match the expected result, the run_docstring_examples function will report this problem as a test failure.  
>当函数的返回值与预期结果不匹配时， run_docstring_examples 函数会将此问题报告为测试失败。

When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:  
>在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest：

python3 -m doctest <python_source_file>

The key to effective testing is to write (and run) tests immediately after implementing new functions. It is even good practice to write some tests before you implement, in order to have some example inputs and outputs in your mind. A test that applies a single function is called a _unit test_. Exhaustive unit testing is a hallmark of good program design.  
>有效测试的关键在于在实现新功能后立即编写（并运行）测试。在实现之前编写一些测试也是一个好习惯，这样可以在脑海中预先准备好一些示例输入和输出。仅应用单个功能的测试称为_单元测试_ 。详尽的单元测试是优秀程序设计的标志。