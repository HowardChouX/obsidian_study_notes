#### **本章学习目标**
理解视图和触发器的概念、作用，掌握视图的创建、使用和维护，掌握触发器的创建与管理。

---

### **`★★★ 7.1 视图的定义及维护`**

#### **1. 视图是什么？**
-   **通俗理解**：视图是一张**虚拟表**。它本身并不存储数据，其数据来自一个或多个底层基表（真实表）。
-   **本质**：是**存储在数据库中的一条查询语句**。当你查询视图时，数据库会执行这条语句，并返回结果。
-   **作用**：
    1.  **简化操作**：将复杂的查询（如多表连接）定义为视图，用户只需简单查询视图即可。
    2.  **数据安全**：用户只能看到视图中所定义的数据，而看不到完整的基表，保护敏感数据。
    3.  **逻辑独立性**：即使基表的逻辑结构改变了（如增加列），只要视图能屏蔽这种变化，应用程序就可以不修改。

#### **2. 创建视图**
```sql
CREATE VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION];
```
-   `column_list`：可选，为视图的列指定名称。如果省略，则使用`SELECT`语句中的列名。
-   `WITH CHECK OPTION`：**重要选项**。对视图进行增、删、改操作时，要保证操作后的数据满足视图定义中的条件。

**示例：**
```sql
-- 创建一个视图，包含计算机系学生的学号、姓名和年龄
CREATE VIEW CS_Student AS
SELECT Sno, Sname, Sage
FROM Student
WHERE Sdept = '计算机系';

-- 创建一个视图，包含学生姓名、课程名和成绩（涉及三表连接）
CREATE VIEW StudentGrade AS
SELECT S.Sname, C.Cname, SC.Grade
FROM Student S, Course C, SC
WHERE S.Sno = SC.Sno AND C.Cno = SC.Cno;
```

#### **3. 使用视图**
视图一旦创建，可以像表一样被查询。
```sql
-- 查询计算机系所有学生
SELECT * FROM CS_Student;

-- 查询计算机系年龄大于19的学生
SELECT * FROM CS_Student WHERE Sage > 19;

-- 查询所有学生的成绩情况
SELECT * FROM StudentGrade;
```

#### **4. 更新视图（受限）**
**`【重要限制】`** 并非所有视图都可以进行`INSERT`, `UPDATE`, `DELETE`操作。通常，只有满足以下条件的**可更新视图**才能修改：
-   视图来源于单个基表。
-   视图的列包含基表中所有未指定默认值的`NOT NULL`列。
-   视图定义中不包含`DISTINCT`, `GROUP BY`, `HAVING`, 聚合函数等。

**示例（可更新视图）：**
```sql
-- 更新CS_Student视图中某个学生的年龄，实际上会更新基表Student
UPDATE CS_Student SET Sage = 21 WHERE Sno = '2023001';

-- 向视图中插入数据（必须包含基表的所有必要字段，如Sdept）
-- 这个操作会失败，因为CS_Student视图不包含Sdept字段，而基表Student的Sdept字段可能不允许为NULL。
-- INSERT INTO CS_Student (Sno, Sname, Sage) VALUES ('2023010', '赵六', 20); -- 可能失败
```

#### **5. 修改和删除视图**
-   **修改视图**：使用 `CREATE OR REPLACE VIEW`（更常用）或 `ALTER VIEW`。
    ```sql
    CREATE OR REPLACE VIEW CS_Student AS
    SELECT Sno, Sname, Sage, Ssex
    FROM Student
    WHERE Sdept = '计算机系';
    ```
-   **删除视图**：
    ```sql
    DROP VIEW [IF EXISTS] view_name;
    ```

---

### **`★★ 7.2 触发器的使用`**

#### **1. 触发器是什么？**
-   **通俗理解**：触发器是**一种特殊的存储过程**，它不需要手动调用，而是在满足特定的数据库事件（`INSERT`, `UPDATE`, `DELETE`）时**自动执行**。
-   **作用**：
    1.  **数据审计**：自动记录数据的修改日志。
    2.  **复杂的数据完整性约束**：实现比外键、检查约束更复杂的业务规则。
    3.  **级联操作**：模拟外键的级联更新/删除。

#### **2. 创建触发器**
```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON table_name FOR EACH ROW
trigger_body;
```
-   **触发时机**：
    -   `BEFORE`：在事件执行**之前**触发。
    -   `AFTER`：在事件执行**之后**触发。
-   **触发事件**：`INSERT`, `UPDATE`, `DELETE`。
-   **`FOR EACH ROW`**：**行级触发器**。MySQL目前只支持行级触发器，即影响多少行数据，触发器就执行多少次。
-   **`NEW` 和 `OLD` 关键字**：**`核心难点`**
    -   在 `INSERT` 触发器中，`NEW` 用来表示将要（BEFORE）或已经（AFTER）**插入的新数据**。
    -   在 `UPDATE` 触发器中，`OLD` 用来表示修改前的原始数据，`NEW` 用来表示修改后的新数据。
    -   在 `DELETE` 触发器中，`OLD` 用来表示将要（BEFORE）或已经（AFTER）**删除的原始数据**。

**示例1：审计日志**
```sql
-- 创建一个审计表，记录对学生表的修改
CREATE TABLE Student_Audit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    Sno CHAR(10),
    action_type VARCHAR(10), -- 'INSERT', 'UPDATE', 'DELETE'
    change_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建一个AFTER INSERT触发器，当有新生入学时，记录日志
CREATE TRIGGER after_student_insert
AFTER INSERT ON Student
FOR EACH ROW
INSERT INTO Student_Audit(Sno, action_type) VALUES (NEW.Sno, 'INSERT');
```

**示例2：业务规则检查（BEFORE触发器）**
```sql
-- 在插入选课记录前，检查成绩是否在合理范围内（0-100）
CREATE TRIGGER before_sc_insert
BEFORE INSERT ON SC
FOR EACH ROW
BEGIN
    IF NEW.Grade < 0 OR NEW.Grade > 100 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '成绩必须在0到100之间'; -- 抛出错误，阻止插入
    END IF;
END;
```

**示例3：级联操作（模拟外键的ON DELETE CASCADE）**
```sql
-- 当从Student表删除一个学生时，自动从SC表删除其所有选课记录
CREATE TRIGGER after_student_delete
AFTER DELETE ON Student
FOR EACH ROW
DELETE FROM SC WHERE SC.Sno = OLD.Sno;
```

#### **3. 查看和删除触发器**
-   **查看触发器**：`SHOW TRIGGERS;`
-   **删除触发器**：`DROP TRIGGER [IF EXISTS] trigger_name;`

---

### **本章总结与复习建议**

-   **视图核心**：理解视图是**虚拟表**，核心作用是**简化查询**和**增强安全**。掌握创建和查询视图。
-   **触发器核心**：理解触发器是**自动执行**的**事件驱动**程序。关键是要分清 `BEFORE/AFTER` 和 `NEW/OLD` 的用法。
-   **应用场景**：
    -   当有一个非常复杂的`SELECT`语句被频繁使用时，考虑创建**视图**。
    -   当需要在数据变更前后自动执行某些业务逻辑（如审计、检查、同步）时，考虑创建**触发器**。

**重要提醒**：触发器功能强大，但滥用会降低数据库性能且使逻辑复杂、难以调试。应谨慎使用。

建议你在测试环境中亲手创建视图和触发器，观察其效果，这对理解它们的行为模式至关重要。如果有具体的业务场景想用视图或触发器实现，我们可以一起设计。