#### **本章学习目标**
理解糟糕数据库设计的问题，掌握函数依赖和码的概念，深入理解范式（1NF, 2NF, 3NF, BCNF）的定义和目的，并学会通过模式分解来优化数据库设计。

---

### **`★ 8.1 关系规范化的必要性`**

**为什么要规范化？** 为了避免糟糕设计带来的问题，即 **“操作异常”**。

假设我们有一个“糟糕”的 `选课` 表，它把学生、课程、系主任等信息都放在一起：
`选课(学号Sno, 学生姓名Sname, 系名Sdept, 系主任Mname, 课程号Cno, 成绩Grade)`
主键为：`(Sno, Cno)`。

这个设计会导致：

1.  **`数据冗余`**：
    -   一个学生选修多门课，他的 `Sname`, `Sdept`, `Mname` 会被重复存储多次。浪费空间。

2.  **`更新异常`**：
    -   如果某个学生转系，需要修改他的 `Sdept` 和 `Mname`。必须修改他所有的选课记录，万一漏改一条，就会导致数据**不一致**。

3.  **`插入异常`**：
    -   如果一个新系刚成立，还没有招生（即没有Sno），那么我们就无法将这个系和系主任的信息存入数据库。因为主键 `Sno` 部分为空，违反了实体完整性。

4.  **`删除异常`**：
    -   如果某个学生毕业了，删除他的所有选课记录，会把这个学生所属的系和系主任的信息也一并删除。如果我们系里只有这一个学生，那么这个系的信息就从数据库中消失了。

**规范化的目的**：通过分解关系模式，**消除这些操作异常**，使数据库设计更加合理。

---

### **`★★ 8.2 数据依赖`**

数据依赖是规范化的理论基石。它描述了关系中属性间的相互制约关系。

-   **`函数依赖`**：**最重要的一种依赖**。
    -   **定义**：设R(U)是一个关系模式，U是属性集。如果对于R的任意两个元组，在X上的属性值相等，则在Y上的属性值也必然相等，则称 **Y函数依赖于X**，记作 **X → Y**。
    -   **`通俗理解`**：知道了X的值，就能唯一确定Y的值。就像知道了`学号(Sno)`，就能唯一确定`学生姓名(Sname)`和`系名(Sdept)`。
    -   **示例**：在 `Student(Sno, Sname, Sdept)` 中，有：
        -   `Sno → Sname`（学号决定姓名）
        -   `Sno → Sdept`（学号决定所在系）
    -   **`完全函数依赖`**：如果Y函数依赖于X，并且Y不函数依赖于X的任何真子集，则称Y完全函数依赖于X。
        -   *示例：在 `SC(Sno, Cno, Grade)` 中，`Grade` 完全函数依赖于 `(Sno, Cno)`。因为只知道Sno或只知道Cno，都无法确定Grade。*
    -   **`部分函数依赖`**：如果Y函数依赖于X，但Y也函数依赖于X的某个真子集X'，则称Y部分函数依赖于X。
        -   *示例：在糟糕的 `选课` 表中，`Sname` 部分函数依赖于主键 `(Sno, Cno)`。因为实际上，`Sname` 只依赖于 `Sno`。这是导致数据冗余的主要原因。*
    -   **`传递函数依赖`**：如果X → Y，Y → Z，且Y不函数依赖于X（即Y不是X的子集），且Z不是Y的子集，则称Z传递函数依赖于X。
        -   *示例：在糟糕的 `选课` 表中，`Sno → Sdept`，`Sdept → Mname`，所以 `Mname` 传递函数依赖于 `Sno`。这是导致更新异常的根源。*

-   **`码（键）`** 的再认识：
    -   **候选码**：能唯一标识一个元组的属性集。
    -   **主码**：被选中的候选码。
    -   **主属性**：包含在任何一个候选码中的属性。
    -   **非主属性**：不包含在任何候选码中的属性。

---

### **`★★★★ 8.3 关系模式的范式`**

范式是递进的关系，高级范式必然满足低级范式的要求。我们的目标是至少达到 **第三范式**。

#### **1. 第一范式**
-   **定义**：关系模式R的**所有属性都是不可再分的基本数据项**。
-   **要求**：表中不能有“表中表”。
-   **示例**：`联系人(姓名, 电话)`，如果一个人有多个电话，把多个电话存到一个单元格里，就违反了1NF。应拆分为 `联系人(姓名, 电话)`，一个人有多条记录。

#### **2. 第二范式**
-   **前提**：关系模式R已经满足1NF。
-   **定义**：R中**每一个非主属性都完全函数依赖于R的任何一个候选码**。
-   **`核心`**：消除**非主属性**对码的**部分函数依赖**。
-   **分解“糟糕”的选课表**：
    -   原表：`选课(Sno, Sname, Sdept, Mname, Cno, Grade)`，码是`(Sno, Cno)`。
    -   **问题**：`Sname`, `Sdept`, `Mname` 只依赖于 `Sno`（码的一部分），这是部分依赖。
    -   **分解**：
        -   `学生(Sno, Sname, Sdept, Mname)` -- 码是`Sno`
        -   `选课_SC(Sno, Cno, Grade)` -- 码是`(Sno, Cno)`
    -   **效果**：消除了大部分数据冗余。但 `学生` 表中还存在 `Sdept → Mname` 的传递依赖。

#### **3. 第三范式**
-   **前提**：关系模式R已经满足2NF。
-   **定义**：R中**不存在非主属性对码的传递函数依赖**。
-   **`核心`**：消除**非主属性**对码的**传递函数依赖**。
-   **继续分解“学生”表**：
    -   原表：`学生(Sno, Sname, Sdept, Mname)`，码是`Sno`。
    -   **问题**：`Sno → Sdept`, `Sdept → Mname`，所以 `Mname` 传递依赖于 `Sno`。
    -   **分解**：
        -   `学生(Sno, Sname, Sdept)` -- 码是`Sno`
        -   `系部(Sdept, Mname)` -- 码是`Sdept`
    -   **最终分解结果**：`学生`, `系部`, `选课_SC`。这个设计消除了我们最初提到的所有操作异常。

#### **4. BC范式**
-   **更严格的定义**：关系模式R中，**每一个决定因素都包含候选码**。
-   **与3NF的关系**：BCNF一定满足3NF，但3NF不一定满足BCNF。BCNF消除了主属性对码的部分和传递依赖。
-   *示例场景较复杂，一般在3NF基础上已能解决绝大部分问题。*

---

### **`★★ 8.4 关系模式的分解算法`**

分解不是随意的，必须保证分解后的关系模式和原来的“等价”，即具有 **“无损连接性”** 和 **“函数依赖保持性”**。

-   **`无损连接分解`**：将关系模式R分解后，用自然连接操作能**精确地恢复**为原来的R，不丢失也不增加信息。
-   **`函数依赖保持`**：分解后，原模式中所有的函数依赖关系，都能由分解后的各个模式中的函数依赖**逻辑蕴涵**。

**算法（了解思想即可）**：
规范化过程通常遵循一个系统的分解算法（如基于函数依赖集的算法），其目标就是将一个低范式的关系模式，**无损连接地**且**保持函数依赖地**分解为一组3NF或BCNF的关系模式。我们前面手动分解“糟糕选课表”的过程，实际上就体现了这个算法的思想。

---

### **本章总结与复习建议**

-   **核心思想**：规范化是一个 **“模式分解”** 的过程，目的是**消除数据冗余和操作异常**。
-   **核心理论**：理解**函数依赖**（完全依赖、部分依赖、传递依赖）是理解范式的关键。
-   **核心技能**：掌握 **1NF, 2NF, 3NF** 的定义，并能**判断一个关系模式属于第几范式**，以及**如何将其分解到更高范式**。
    -   **判断步骤**：
        1.  找出候选码和所有函数依赖。
        2.  检查是否满足1NF（属性原子性）。
        3.  检查是否满足2NF（非主属性是否完全依赖于码？消除部分依赖）。
        4.  检查是否满足3NF（非主属性是否传递依赖于码？消除传递依赖）。

这一章非常抽象，建议多做习题，找一些关系模式实例来分析和分解，这是将理论内化的最好方法。如果你有具体的习题或设计案例感到困惑，我们可以一起逐步分析。