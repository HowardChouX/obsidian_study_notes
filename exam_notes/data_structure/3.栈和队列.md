# 第3章 栈和队列

## 3.1 栈

### 3.1.1 抽象数据类型定义

**栈**（stack）是一种只能在**同**一端进行插入或删除操作的线性表[8]。表中允许进行插入、删除操作的一端称为**栈顶**（top），表的另一端称为**栈底**（bottom）[8]。栈的插入操作通常称为**进栈**或**入栈**（push），栈的删除操作通常称为**退栈**或**出栈**（pop）[8]。

栈的主要特点是**后进先出**，即后进栈的元素先出栈[8]。每次进栈的元素都作为新栈顶元素，每次出栈的元素只能是当前栈顶元素[8]。栈也称为**后进先出表**或者**先进后出表**[8]。

栈的抽象数据类型定义如下[12]：
```python
ADT Stack {
    数据对象：D={a_i | 0≤i≤n-1，n≥0，元素a_i为E类型}
    数据关系：R={r} r={<a_i，a_{i+1}> | a_i，a_{i+1}∈D，i=0，…，n-2}
    基本运算：
        empty()：判断栈是否为空，若空栈返回真；否则返回假。
        push(e)：进栈操作，将元素e插入到栈中作为栈顶元素。
        pop()：出栈操作，返回栈顶元素。
        gettop()：取栈顶操作，返回当前的栈顶元素。
}
```

### 3.1.2 栈的表示和实现

栈的实现方式有两种：**顺序栈**和**链栈**[10]。

#### 1. 顺序栈
**顺序栈**使用Python列表的data属性来存放栈中元素，将data[0]端作为栈底，data[-1]端作为栈顶[10][25]。顺序栈的四要素如下[25]：
- **栈空条件**：`len(data)==0` 或者 `not data`
- **栈满条件**：由于data列表可以动态扩展，所以不必考虑栈满
- **元素e进栈操作**：将e添加到栈顶处
- **出栈操作**：删除栈顶元素并返回该元素

顺序栈类SqStack的基本运算算法包括[25]：
- `empty()`：判断栈是否为空
- `push(e)`：元素e进栈
- `pop()`：元素出栈
- `gettop()`：取栈顶元素

#### 2. 链栈
**链栈**采用链式存储结构，每个结点为LinkNode类对象，包括存储元素的数据属性data和存储后继结点的指针属性next[11]。初始时只含有一个头结点head并置`head.next`为None[11]。

链栈的四要素如下[11]：
- **栈空的条件**：`head.next==None`
- **栈满的条件**：只有在内存溢出才会出现栈满，通常不考虑这种情况
- **元素e进栈操作**：将包含该元素的结点s插入作为首结点
- **出栈操作**：返回首结点值并且删除该结点

链栈类LinkStack的基本运算算法包括[11]：
- `empty()`：判断栈是否为空
- `push(e)`：元素e进栈
- `pop()`：元素出栈
- `gettop()`：取栈顶元素

### 3.1.3 栈的应用举例

#### 1. 数制转换
数制转换是栈的典型应用之一。通过栈可以实现十进制数转换为其他进制数。

#### 2. 括号匹配检验
设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号、中括号和大括号）[9]。算法思路：遍历表达式字符串，遇到左括号时进栈，遇到右括号时检查栈顶是否匹配的左括号[9]。

#### 3. 行编辑程序
行编辑程序可以使用栈来实现文本编辑中的撤销操作。

#### 4. 迷宫求解
迷宫求解问题可以使用栈来记录走过的路径[33]。每次走到一个方块(i,j)，一次性试探所有相邻方块，将所有相邻可走方块进栈[33]。一个方块在栈中的元素为b，并保存其前驱方块（pre标识）[33]。

迷宫问题的搜索过程：用栈记录走过的路径，路径由方块和方块之间的走向（方位）构成[33]。当找到出口时，通过pre推导出迷宫路径[3]。

#### 5. 表达式求值
表达式求值包括两个步骤[1]：
1. 将中缀表达式exp转换成后缀表达式postexp
2. 对该后缀表达式求值

**中缀表达式转后缀表达式算法**[28]：
```python
while (若exp未读完) {
    从exp读取字符ch;
    ch为数字：将后续的所有数字均依次存放到postexp中;
    ch为左括号'('：将'('进栈到opor;
    ch为右括号')'：将opor栈中与值匹配的'('后进栈的运算符依次出栈并存放到postexp中,再将'('退栈;
    若ch的优先级高于栈顶运算符优先级，则将ch进栈；
    否则出栈并存放到postexp中,再将ch进opor栈;
}
字符串exp扫描完毕,则退栈opor的所有运算符并存放到postexp中
```

**后缀表达式求值算法**[21]：
```python
while (若postexp未读完) {
    从postexp读取字符ch;
    ch为'+'：从opand栈出栈两个数值a和b,计算c=b+a;将c进栈opand;
    ch为'-'：从opand栈出栈两个数值a和b,计算c=b-a;将c进栈opand;
    ch为'*'：从opand栈出栈两个数值a和b,计算c=b*a;将c进栈opand;
    ch为'/'：从opand栈出栈两个数值a和b,若a不零,计算c=b/a;将c进栈opand;
    ch为数字字符：将连续的数字串转换成数值d,将d进栈opand;
}
opand栈中唯一的数值即为表达式值
```

### 3.1.4 栈与递归的实现

递归函数的调用过程类似于多个函数的嵌套调用，只不过调用函数和被调用函数是同一个函数[30]。为了保证递归函数的正确执行，系统需设立一个**工作栈**[30]。

递归执行过程[30]：
1. 执行开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址
2. 每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址进栈
3. 每次递归调用结束后，将栈顶元素出栈，使相应的值参和局部变量恢复为调用前的值，然后转向返回地址指定的位置继续执行

用递归算法的形参值表示状态，由于递归算法执行中系统栈保存了递归调用的值参、局部变量和返回地址，所以在递归算法中一次递归调用后会自动恢复该次递归调用前的状态[37]。

## 3.2 队列

### 3.2.1 抽象数据类型定义

**队列**（queue）是一种只能在**不同**端进行插入或删除操作的线性表[18]。进行插入的一端称做**队尾**（rear），进行删除的一端称做**队头**或**队首**（front）[18]。队列的插入操作通常称为**进队**或**入队**（push），队列的删除操作通常称为**出队**或**离队**（pop）[4]。

队列的主要特点是**先进先出**，即先进队的元素先出队[4]。每次进队的元素作为新队尾元素，每次出队的元素只能是队头的元素[4]。队列也称为**先进先出表**[4]。

队列的抽象数据类型定义如下[4]：
```python
ADT Queue {
    数据对象：D={a_i | 0≤i≤n-1，n≥0}
    数据关系：R={r} r={<a_i，a_{i+1}> | a_i，a_{i+1}∈D，i=0，…，n-2}
    基本运算：
        empty()：判断队列是否为空，若队列为空，返回真，否则返回假。
        push(e)：进队，将元素e进队作为队尾元素。
        pop()：出队，从队头出队一个元素。
        gethead()：取队头，返回队头元素而不出队。
}
```

### 3.2.2 链队列

**链队列**采用链式存储结构，每个结点的类型为LinkNode，包括data属性和next属性[26]。初始时置`front=rear=None`[26]。

链队的四要素如下[26]：
- **队空条件**：`front=rear==None`，不妨仅以`front==None`作为队空条件
- **队满条件**：由于只有内存溢出时才出现队满，通常不考虑这样的情况
- **元素e进队操作**：在单链表尾部插入存放e的s结点，并让队尾指针指向它
- **出队操作**：取出队首结点的data值并将其从链队中删除

链队列类LinkQueue的基本运算算法包括[13][26]：
- `empty()`：判断队列是否为空
- `push(e)`：元素e进队
- `pop()`：出队操作
- `gethead()`：取队头元素

### 3.2.3 循环队列

**循环队列**把data数组的前端和后端连接起来，形成一个循环数组，即把存储队列元素的表从逻辑上看成一个环[18]。循环队列首尾相连，当队尾指针`rear=MaxSize-1`时，再前进一个位置就应该到达0位置，这可以利用数学上的求余运算（%）实现[4]：
- 队首指针循环进1：`front=(front+1)%MaxSize`
- 队尾指针循环进1：`rear=(rear+1)%MaxSize`

循环队列的四要素如下[15]：
- **队空条件**：`rear==front`
- **队满条件**：`(rear+1)%MaxSize==front`（相当于试探进队一次，若rear达到front，则认为队满了）
- **元素e进队**：`rear=(rear+1)%MaxSize`，将元素e放置在该位置
- **元素出队**：`front=(front+1)%MaxSize`，取出该位置的元素

循环队列类CSqQueue的基本运算算法包括[27]：
- `empty()`：判断队列是否为空
- `push(e)`：元素e进队
- `pop()`：出队元素
- `gethead()`：取队头元素

**循环队列与非循环队列的区别**[18]：
- 非循环队列存在**假溢出**问题：当队尾指针`rear=MaxSize-1`时，即使队列前端还有空闲位置，也不能再插入新元素
- 循环队列通过首尾相连的方式解决了假溢出问题，可以充分利用存储空间

## 3.3 离散事件模拟

离散事件模拟是队列的重要应用之一。在离散事件模拟中，事件按时间顺序发生，可以使用队列来管理待处理的事件。常见的离散事件模拟包括：
- **银行排队系统**：顾客到达和离开事件
- **CPU调度**：进程到达和完成事件
- **交通流量模拟**：车辆到达和离开事件

离散事件模拟的基本步骤：
1. 定义事件类型和事件处理程序
2. 使用优先队列（通常是最小堆）按事件发生时间排序
3. 初始化模拟时钟和事件队列
4. 循环处理事件：
   - 从事件队列中取出最早发生的事件
   - 推进模拟时钟到该事件发生时间
   - 执行该事件的处理程序，可能生成新事件并加入队列
5. 直到事件队列为空或达到模拟结束条件

在Python中，可以使用`heapq`模块实现优先队列（小根堆）[32]。`heapq`模块提供了堆的基本操作方法，包括：
- `heapq.heapify(list)`：把列表list调整为堆
- `heapq.heappush(heap, item)`：向堆heap中插入元素item
- `heapq.heappop(heap)`：从堆heap中弹出最小元素
- `heapq.heapreplace(heap, item)`：弹出最小元素，再插入item
- `heapq.heappushpop(heap, item)`：插入item，再弹出最小元素

通过队列和优先队列，可以高效地实现各种离散事件模拟系统，分析系统性能，优化资源配置。