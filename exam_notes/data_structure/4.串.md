# 第4章 串

## 4.1 串类型的定义

### 4.1.1 串的基本概念
**串**是由零个或多个字符组成的有限序列，记作str="a₀a₁…aₙ₋₁"（n≥0）[1]。串中所包含的字符个数n称为**串长度**，当n=0时，称为**空串**[1]。

一个串中任意连续的字符组成的子序列称为该串的**子串**。包含子串的串相应地称为**主串**[1]。若两个串的长度相等且对应字符都相等，则称两个**串相等**[1]。

**子串个数计算**：设s是一个长度为n的串，其中的字符各不相同，则s中的所有子串个数是：
- 空串是其子串，计1个
- 每个字符构成的串是其子串，计n个
- 每2个连续的字符构成的串是其子串，计n-1个
- 每3个连续的字符构成的串是其子串，计n-2个
- ...
- 每n-1个连续的字符构成的串是其子串，计2个
- s是其自身的子串，计1个

例如，s="software"的子串个数=(8×9)/2+1=37[1]。

### 4.1.2 串的抽象数据类型
串的抽象数据类型定义如下[2]：
```python
ADT String {
    数据对象：D={a_i | 0≤i≤n-1，n≥0，a_i为字符类型}
    数据关系：R={r} r={<a_i，a_{i+1}> | a_i，a_{i+1}∈D，i=0，…，n-2}
    基本运算：
        StrAssign(cstr)：由字符串常量cstr创建一个串，即生成其值等于cstr的串。
        StrCopy()：串复制，返回由当前串复制产生一个串。
        getsize()：求串长，返回当前串中字符个数。
        geti(i)：返回序号i的字符。
        seti(i，x)：设置序号i的字符为x。
        Concat(t)：串连接，返回一个当前串和串t连接后的结果。
        SubStr(i，j)：求子串，返回当前串中从第i个字符开始的j个连续字符组成的子串。
        InsStr(i，t)：串插入，返回串t插入到当前串的第i个位置后的子串。
        DelStr(i，j)：串删除，返回当前串中删去从第i个字符开始的j个字符后的结果。
        RepStr(i，j，t)：串替换，返回用串t替换当前串中第i个字符开始的j个字符后的结果。
        DispStr()：输出字符串。
}
```

### 4.1.3 串的模式匹配
设有两个串s和t，串t定位操作就是在串s中查找与子串t相等的子串[3]。通常把串s称为**目标串**，把串t称为**模式串**，因此定位也称作**模式匹配**[3]。

**模式匹配成功**是指在目标串s中找到一个模式串t。**不成功**则指目标串s中不存在模式串t[3]。

## 4.2 串的表示和实现

### 4.2.1 定长顺序存储表示（顺序串）
和顺序表一样，用一个data数组和一个整型变量size来表示一个顺序串，size表示data数组中实际字符的个数[2]。为了简单，data数组采用固定容量为MaxSize（可以模仿顺序表改为动态容量方式）[2]。

**顺序串类SqString**[2]：
```python
MaxSize=100  # 假设容量为100

class SqString:  # 顺序串类
    def __init__(self):  # 构造方法
        self.data=[None]*MaxSize  # 存放串中字符
        self.size=0  # 串中字符个数
```

**顺序串基本运算算法**：
顺序串上的基本运算算法设计与顺序表类似，仅以求子串为例说明[6]。

**求子串算法**[8]：
```python
def SubStr(self,i,j):  # 求子串的运算算法
    s=SqString()  # 新建一个空串
    assert i>=0 and i<self.size and j>0 and i+j<=self.size  # 检测参数
    for k in range(i,i+j):  # 将data[i..i+j-1]->s
        s.data[k-i]=self.data[k]
    s.size=j
    return s  # 返回新建的顺序串
```

**串比较算法**[1]：
```python
def Strcmp(s,t):  # 比较串s和t的算法
    minl=min(s.getsize(), t.getsize())  # 求s和t中最小长度
    for i in range(minl):  # 在共同长度内逐个字符比较
        if s[i]>t[i]:
            return 1
        elif s[i]<t[i]:
            return -1
    if s.getsize()==t.getsize():  # s==t
        return 0
    elif s.getsize()>t.getsize():  # s>t
        return 1
    else:  # s<t
        return -1
```

### 4.2.2 堆分配存储表示
堆分配存储表示是动态分配存储空间的方式，可以根据串的实际长度动态分配存储空间。

### 4.2.3 串的块链存储表示（链串）
**链串的结点类型LinkNode**（结点大小为1）[13]：
```python
class LinkNode:  # 链串结点类型
    def __init__(self,d=None):  # 构造方法
        self.data=d  # 存放一个字符
        self.next=None  # 指向下一个结点的指针
```

一个链串用一个头结点head来唯一标识，链串类LinkString[13]：
```python
class LinkString:  # 链串类
    def __init__(self):  # 构造方法
        self.head=LinkNode()  # 建立头结点
        self.size=0
```

**链串基本运算算法**：
链串上的基本运算算法设计与单链表类似，仅以串插入算法为例说明[15]。

**串插入算法**[16]：
```python
def InsStr(self,i,t):  # 串插入运算的算法
    s=LinkString()  # 新建一个空串
    assert i>=0 and i<self.size  # 检测参数
    p,p1=self.head.next, t.head.next
    r=s.head  # r指向新建链表的尾结点
    for k in range(i):  # 将当前链串的前i个结点复制到s
        q=LinkNode(p.data)
        r.next=q; r=q  # 将q结点插入到尾部
        p=p.next
    while p1!=None:  # 将t中所有结点复制到s
        q=LinkNode(p1.data)
        r.next=q; r=q  # 将q结点插入到尾部
        p1=p1.next
    while p!=None:  # 将当前串的余下结点复制到s
        q=LinkNode(p.data)
        r.next=q; r=q  # 将q结点插入到尾部
        p=p.next
    s.size=self.size+t.size
    r.next=None  # 尾结点的next置为空
    return s  # 返回新建的链串
```

## 4.3 串的模式匹配算法

### 4.3.1 求子串位置的定位函数Index(S, T, pos) - BF算法
**BF算法**（Brute-Force暴力匹配算法或朴素匹配算法或简单匹配算法）[20]的基本思路：
设目标串s="s₀s₁…sₙ₋₁"，模式串t="t₀t₁…tₘ₋₁"
1. **第1趟**：从s₀/t₀开始比较，若相等，则继续逐个比较后续字符。如果对应的字符全部相同且t的字符比较完，说明t是s的子串，返回t在s中的起始位置0，表示匹配成功；如果对应的字符不相同，说明第一趟匹配失败。
2. **第2趟**：从s₁/t₀开始比较，若相等，则继续逐个比较后续字符。如果对应的字符全部相同且t的字符比较完，说明t是s的子串，返回t在s中的起始位置1，表示匹配成功；如果对应的字符不相同，说明第一趟匹配失败。
3. **依次类推**。只要有一趟匹配成功，则说明t是s的子串，返回t在s中的起始位置。如果i超界都没有匹配成功，说明t不是s的子串，返回-1。

**BF算法实现**[22]：
```python
def BF(s,t):  # BF算法
    i,j=0,0
    while i<s.getsize() and j<t.getsize():  # 两串未遍历完时循环
        if s[i]==t[j]:  # 两个字符相同
            i,j=i+1,j+1  # 继续比较下一对字符
        else:
            i,j=i-j+1,0  # i从下个位置，j从头开始匹配
    if j>=t.getsize():
        return i-t.getsize()  # 返回匹配的首位置
    else:
        return -1  # 模式匹配不成功
```

**BF算法性能**[23]：
- 最好情况下的时间复杂度为O(m)，即主串的前m个字符正好等于模式串的m个字符
- 最坏情况下的时间复杂度为O(n×m)
- 平均情况下的时间复杂度为O(n×m)

### 4.3.2 模式匹配的一种改进算法 - KMP算法
**KMP算法**主要是消除了目标串指针的回溯，从而使算法效率有了某种程度的提高[24]。

**KMP算法的核心思想**：
当匹配失败时，主串指针`i`不后退，仅根据模式串的结构信息调整模式串指针`j`，使模式串向右滑动到最优位置继续匹配[25]。主串指针永不回溯[25]。

**next数组的定义**[27]：
next[j]=MAX{k | 0<k<j且"t₀t₁…tₖ₋₁"="tⱼ₋ₖtⱼ₋ₖ₊₁…tⱼ₋₁"}
- -1 当前缀非空时
- 0 当j=0时
- 其他情况

**求next数组算法**[29]：
```python
def GetNext(t,next):  # 由模式串t求出next值
    j,k=0,-1
    next[0]=-1
    while j<t.getsize()-1:
        if k==-1 or t[j]==t[k]:
            j,k=j+1,k+1  # j遍历后缀，k遍历前缀
            next[j]=k
        else:
            k=next[k]  # k置为next[k]
```

**KMP算法实现**[30]：
```python
def KMP(s,t):  # KMP算法
    next=[None]*MaxSize
    GetNext(t,next)  # 求next数组
    i,j=0,0
    while i<s.getsize() and j<t.getsize():
        if j==-1 or s[i]==t[j]:
            i,j=i+1,j+1  # i,j各增1
        else:
            j=next[j]  # i不变，j回退
    if j>=t.getsize():
        return i-t.getsize()  # 返回起始序号
    else:
        return -1  # 返回-1
```

**KMP算法性能**[31]：
- 求next数组的时间复杂度为O(m)
- 匹配过程中比较次数可记为n
- KMP算法总的时间复杂度为O(n+m)

**改进KMP算法 - nextval数组**[42]：
将next数组改为nextval数组，与next[0]一样，先置nextval[0]=-1。假设求出next[j]=k，现在失配处为sᵢ/tⱼ，即sᵢ≠tⱼ：
1. 如果有tⱼ=tₖ成立，可以直接推出sᵢ≠tₖ成立，没有必要再做sᵢ/tₖ的比较，直接置nextval[j]=nextval[k]（nextval[next[j]]），即下一步做sᵢ/t_nextval[j]的比较。
2. 如果有tⱼ≠tₖ，没有改进的，置nextval[j]=next[j]。

**求nextval数组算法**[43]：
```python
def GetNextval(t,nextval):  # 由模式串t求出nextval值
    j,k=0,-1
    nextval[0]=-1
    while j<t.getsize()-1:
        if k==-1 or t[j]==t[k]:
            j,k=j+1,k+1
            if t[j]!=t[k]:
                nextval[j]=k
            else:  # t[j]=t[k]
                nextval[j]=nextval[k]
        else:
            k=nextval[k]
```

**改进KMP算法实现**[44]：
```python
def KMPval(s,t):  # 改进后的KMP算法
    nextval=[None]*MaxSize
    GetNextval(t,nextval)  # 求nextval数组
    i,j=0,0
    while i<s.getsize() and j<t.getsize():
        if j==-1 or s[i]==t[j]:
            i,j=i+1,j+1  # i,j各增1
        else:
            j=nextval[j]  # i不变，j回退
    if j>=t.getsize():
        return(i-t.getsize())  # 返回起始序号
    else:
        return(-1)  # 返回-1
```

## 4.4 串操作应用举例

### 4.4.1 文本编辑
文本编辑是串操作的重要应用之一。在文本编辑程序中，串通常用于表示文本内容，常见的文本编辑操作包括：
1. **插入操作**：在指定位置插入文本
2. **删除操作**：删除指定位置的文本
3. **查找替换操作**：查找指定的文本并用新文本替换
4. **复制粘贴操作**：复制指定文本并粘贴到其他位置

文本编辑程序通常需要处理大量的串操作，因此高效的串实现和模式匹配算法对于提高文本编辑程序的性能至关重要。

### 4.4.2 建立词索引表
建立词索引表是串操作的另一个重要应用，主要用于信息检索系统。基本步骤包括：
1. **文本分词**：将文本内容分割成独立的词或短语
2. **词条提取**：从分词结果中提取有意义的词条
3. **建立索引**：为每个词条建立索引，记录其在文本中出现的位置
4. **索引排序**：对索引表按词条排序，便于快速查找

**索引存储结构**[50]：
索引存储结构是在采用数据表存储数据的同时，还建立附加的**索引表**。索引表中的每一项称为索引项，索引项的一般形式为（关键字，地址），其中，关键字唯一标识一个元素，地址为该关键字元素在数据表中的存储地址，整个索引表按关键字有序排列。

**索引表元素类型定义**[30]：
```python
class IdxType:  # 索引表元素类型
    def __init__(self,j=None,k=None):  # 构造方法
        self.key=k  # 关键字（对应块中的最大关键字）
        self.link=j  # 该索引块在数据表中的起始下标
```

通过建立词索引表，可以大大提高文本检索的效率，特别是在处理大规模文本数据时，索引表能够显著减少查找时间。