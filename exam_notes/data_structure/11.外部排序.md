# 第11章 外部排序

## 11.1 外存信息的存取

**外排序**是指数据存放在外存中，数据排序时涉及内、外存数据交换的排序方法[5]。存储在外存上的数据以文件为基本单位[5]。

**外存设备分类**：
1. **顺序存取设备**：例如磁带
2. **直接存取设备**：例如磁盘

本章主要讨论磁盘排序[1]。

**外排序基本过程**：
1. **生成初始归并段（顺串）**：将一个文件（含待排序数据）中的数据分段读入内存，每个段在内存中进行排序，并将有序数据段写到外存文件上，从而得到若干初始归并段[3]。
2. **多路归并**：对这些初始归并段进行多路归并，使得有序归并段逐渐扩大，最后在外存上形成整个文件的单一归并段，也就完成了这个文件的外排序[3]。

**外排序时间**：主要包含内外存数据交换时间和元素比较时间（元素移动次数相对较少）[3]。

## 11.2 外部排序的方法

### 11.2.1 生成初始归并段的方法

**1. 常规方法**：
- 内存工作区WA容量为w
- 从待排文件Fin中读取w个元素到内存
- 使用内排序算法对内存中的元素进行排序
- 将排序后的w个元素写入外存文件F₁～Fₘ
- 得到m个初始归并段，显然$m = \lceil n/w \rceil$[3]
- 通常前m-1个有序文件的长度均为w，最后一个有序文件的长度小于等于w[3]

**2. 置换-选择排序方法**：
- 从待排文件F_in中按内存工作区WA的容量w读入w个元素
- 设归并段编号i=1
- 从WA中选出关键字最小的元素R_min
- 将R_min元素输出到当前归并段F_i
- 若F_in不空，则从F_in中读入下一个元素x放在R_min所在的工作区位置代替R_min
- 在工作区中所有≥R_min的元素中选择出最小元素作为新的R_min，重复输出过程
- 直到选不出这样的R_min时，开始一个新的归并段（i=i+1）
- 若工作区已空，则初始归并段已全部产生[2]

**示例**：设磁盘文件中共有18个元素，关键字分别为(15,4,97,64,17,32,108,44,76,9,39,82,56,31,80,73,255,68)，若内存工作区可容纳5个元素，用置换-选择排序可产生2个初始归并段[3]：
- 归并段1：4,15,17,32,44,64,76,82,97,108
- 归并段2：9,31,39,56,68,73,80,255[2]

## 11.3 多路平衡归并的实现

### 11.3.1 k路平衡归并方法

**2路平衡归并**：每一趟从m个归并段得到$\lceil m/2 \rceil$个归并段[2]。

**k路平衡归并**：可以推广到k路[4]。

**示例**：m=8，k=2，$\lceil \log_2 m \rceil = 3$遍[2]。

**影响k路平衡归并效率的因素**：
1. 归并时需要读写磁盘的次数
2. 归并时需要关键字比较的次数[3]

**k路平衡归并时读写磁盘次数的计算**：
- 采用k路平衡归并时，通常k越大，读写磁盘次数会减少[4]
- 例如：m=8，假设每个归并段4个元素，k=2，读元素次数=WPL=8×4×3=96（如果每个元素占用一个物理块，读写磁盘次数=96×2=192次）[4]

**k路平衡归并时关键字比较次数的计算**：
- 采用k路平衡归并时，相应的归并树有$\lceil \log_k m \rceil + 1$层，要对数据进行$\lceil \log_k m \rceil$趟扫描[9]
- 总共需要的关键字比较次数为：$\lceil \log_k m \rceil × (u-1) × (k-1) = \lceil \log_2 m \rceil × (u-1) × (k-1) / \lceil \log_2 k \rceil$[9]
- 结论：关键字比较次数与k无关，总的内部归并时间不会随k的增大而增大[7]

### 11.3.2 利用败者树实现k路平衡归并

**败者树**用于在k个元素中选取最小关键字的元素[5]。败者树类似于堆排序中的堆[5]。

**利用败者树实现k路平衡归并的过程**：
1. 先建立败者树
2. 然后对k个输入有序段进行k路平衡归并[5]

**构建败者树**：k=5时，创建含有k个叶子结点的完全二叉树（结点个数最少）[5]。

**败者树结点表示**：每个叶子结点对应一个归并段，段号为0～4。初始时每个分支结点取值"5(-∞)"，5表示段号（此时为虚拟段号），-∞表示最小关键字。例如，某结点取值为"4(15)"，表示结点值来自4号段的关键字15对应的元素[5]。

**示例**：设有5个初始归并段，它们中各元素的关键字分别是[5]：
- F₀：{17,21,∞}
- F₁：{5,44,∞}
- F₂：{10,12,∞}
- F₃：{29,32,∞}
- F₄：{15,56,∞}

其中，∞是段结束标志。说明利用败者树进行k=5路平衡归并排序的过程[5]。

**败者树构建完毕调整产生冠军（最小者）的过程**：从F₄→F₀操作：将当前结点的关键字与父结点比较，将大的（败者）放在父结点中，小者（胜者）继续进行，直到根结点。最后将胜者放在冠军结点中[9]。

## 11.4 置换-选择排序

**置换-选择排序算法步骤**：
1. 从待排文件F_in中按内存工作区WA的容量w读入w个元素。设归并段编号i=1[2]
2. 从WA中选出关键字最小的元素R_min[2]
3. 将R_min元素输出到当前归并段F_i[2]
4. 若F_in不空，则从F_in中读入下一个元素x放在R_min所在的工作区位置代替R_min[2]
5. 在工作区中所有≥R_min的元素中选择出最小元素作为新的R_min，转步骤3，直到选不出这样的R_min[2]
6. 设i=i+1，开始一个新的归并段[2]
7. 若工作区已空，则初始归并段已全部产生；否则转步骤2[2]

**置换-选择排序的特点**：
- 可以生成比内存工作区容量更长的初始归并段
- 减少了初始归并段的数量，从而减少归并趟数
- 特别适用于内存容量较小的情况

## 11.5 最佳归并树

### 11.5.1 最佳归并树的概念

k路平衡归并适合初始归并段中的元素个数相同的情况，当初始归并段中的元素个数不同时，需要确定哪些初始归并段先归并，哪些后归并的问题[7]。

**归并方案转化**：当初始归并段和k已确定时，归并方案转化为k叉哈夫曼树的归并方案→最佳归并树[7]。

**示例**：k=2，4个初始归并段含元素个数分别是4、6、3、8[7]：
- 归并方式1：WPL=(4+6+3+8)×2=42
- 归并方式2：WPL=(3+4)×3+6×2+8=41
显然采用k叉哈夫曼树的归并方案[7]。

### 11.5.2 最佳归并树的构造

**存在的问题（假设k=3）**：WPL最小，在内存中归并时，利用败者树减少关键字比较次数[7]。

**解决方法**：加虚段（长度为0的段），每次恰好k个段进行归并[7]！

**加虚段的规则**：
1. 若$x = (m-1) \% (k-1) ≠ 0$，则需附加$(k-1)-x$个虚段，以使每次归并都可以对应k个段[7]
2. 按照哈夫曼树的构造原则（权值越小的结点离根结点越远）构造最佳归并树[4]

**最佳归并树（m个初始归并段）**是带权路径长度最短的k叉（阶）哈夫曼树，构造步骤如下[4]：
1. 计算需要添加的虚段数量
2. 将虚段（权值为0）加入初始归并段集合
3. 构造k叉哈夫曼树

**示例**：k=2时，$x = (m-1) \% 1 = 0$，所以二路归并（哈夫曼树构造中）不需要增加虚段[4]。

**示例**：设文件经预处理后，得到长度为(49,9,35,18,4,12,23,7,21,14,26)的11个初始归并段，试为4路归并设计一个读写文件次数最少的归并方案（假如每个元素占用一个物理块）[4]。

**解**：初始归并段个数m=11，k=4。$x = (m-1) \% (k-1) = 1 ≠ 0$，因此需附加：$(k-1)-x = 2$个长度为0的虚段。根据集合：(49,9,35,18,4,12,23,7,21,14,26,0,0)构造4阶哈夫曼树[4]。

**4路最佳归并树的构造过程**：WPL=(4+7)×3+(9+12+14+18+21+23+26)×2+(35+49)×1=363，最少的读写次数=2×WPL=726次[7]。

**按元素个数递增排序**：(0,0,4,7,9,12,14,18,21,23,26,35,49)[7]。

**示例**：设有6个有序文件A、B、C、D、E、F，分别含有10、35、40、50、60和200个数据元素，各文件中元素按升序排序。要求通过5次两两合并，将6个文件最终合并成一个升序文件。给出文件读写次数最少的合并过程（假设每个元素读写一次）[9]。

**解**：构造2路最佳归并树，归并过程如下：WPL=(10+35)×4+(40+50+60)×3+200×1=830。最少读写次数=2×WPL=1660[5]。

### 11.5.3 最佳归并树的应用

最佳归并树在外排序中具有重要意义：
1. **减少磁盘I/O次数**：通过优化归并顺序，最小化读写磁盘的次数
2. **提高排序效率**：减少归并趟数，降低时间复杂度
3. **节省存储空间**：合理组织归并过程，减少临时文件的产生

**最佳归并树的性质**：
- 最佳归并树是带权路径长度最短的k叉树
- 权值代表归并段的长度（元素个数）
- 树的带权路径长度WPL表示总的读写次数
- 最小读写次数=2×WPL（每个元素读一次写一次）

通过最佳归并树的构造，可以显著提高外排序的效率，特别是在处理大规模数据时，这种优化尤为重要。