# 第1章 绪论

## 1.1 什么是数据结构

数据结构是计算机存储、组织数据的方式，它研究数据的**逻辑结构**、**存储结构**以及定义在逻辑结构上的**数据运算**（或操作）[11]。数据结构可以形式化地表示为：

**ADT = 逻辑结构 + 抽象运算（功能描述）**[11]

其中：
- **逻辑结构**：描述数据元素之间的逻辑关系，如线性关系、树形关系、图形关系等
- **存储结构**：数据在计算机中的存储表示，如顺序存储、链式存储等
- **抽象运算**：对数据元素的操作集合，如插入、删除、查找等

数据结构的设计目标是**高效地实现数据操作**，使算法能够以最优的时间和空间复杂度运行[11]。

## 1.2 基本概念和术语

### 1.2.1 数据与数据元素
- **数据**：描述客观事物的符号，是计算机中可以操作的对象
- **数据元素**：数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理

### 1.2.2 数据结构类型
1. **线性结构**：数据元素之间存在一对一的关系
   - 示例：线性表、栈、队列、串等
   - 线性表是具有相同特性的数据元素的一个有限序列[3][17]

2. **树形结构**：数据元素之间存在一对多的关系
   - 树是由n（n≥0）个结点组成的有限集合[9]
   - 二叉树是每个结点最多有两个子树的树结构[48]

3. **图形结构**：数据元素之间存在多对多的关系
   - 图G由两个集合V（顶点）和E（边）组成，记为G=(V,E)[6]

### 1.2.3 存储结构类型
1. **顺序存储结构**：用一组地址连续的存储单元依次存储数据元素
   - 特点：随机存取，存储密度高[13]
   - 示例：顺序表、顺序栈、顺序队列等

2. **链式存储结构**：用任意地址的存储单元存储数据元素，通过指针表示元素间关系
   - 特点：动态分配，插入删除效率高[13]
   - 示例：单链表、双链表、链栈、链队列等[29]

### 1.2.4 抽象数据类型（ADT）
抽象数据类型是一个数学模型以及定义在该模型上的一组操作，它只描述数据的逻辑结构和运算，不涉及具体实现[11]。

## 1.3 抽象数据类型的表示与实现

### 1.3.1 ADT的表示方法
抽象数据类型通常采用以下形式描述：
```python
ADT 类型名 {
    数据对象：<数据对象的定义>
    数据关系：<数据关系的定义>
    基本运算：<基本运算的定义>
}
```

例如，线性表的抽象数据类型描述为[3]：
```python
ADT List {
    数据对象：D={a_i | 0≤i≤n-1, n≥0, a_i为E类型}
    数据关系：R={r} r={<a_i, a_{i+1}> | a_i, a_{i+1}∈D, i=0,...,n-2}
    基本运算：
        CreateList(a)：由数组a建立线性表
        Add(e)：添加元素e到末尾
        getsize()：求长度
        GetElem(i)：取第i个元素
        Insert(i,e)：在第i位置插入e
        Delete(i)：删除第i个元素
        display()：输出所有元素
}
```

### 1.3.2 ADT的实现方式
采用Python面向对象的程序设计语言实现抽象数据类型时，通常将一个抽象数据类型设计成一个Python类[11]：
- 采用类的**数据变量**表示数据的存储结构
- 将抽象运算通过类的**公有方法**实现

例如，集合ADT Set的实现[3][15]：
```python
class Set:  # 集合类
    MaxSize = 100  # 集合的最多元素个数
  
    def __init__(self):  # 构造方法
        self.data = [None] * Set.MaxSize  # data存放集合元素
        self.size = 0  # size为集合的长度
  
    def getsize(self):  # 返回集合的长度
        return self.size
  
    def get(self, i):  # 返回集合的第i个元素
        assert i >= 0 and i < self.size
        return self.data[i]
  
    def IsIn(self, e):  # 判断e是否在集合中
        for i in range(self.size):
            if self.data[i] == e:
                return True
        return False
  
    def add(self, e):  # 将元素e添加到集合中
        # 实现代码...
  
    def delete(self, e):  # 从集合中删除元素e
        # 实现代码...
  
    def Union(self, s2):  # 求并集s3=s1∪s2
        s3 = self.Copy()
        for i in range(s2.getsize()):
            e = s2.get(i)
            if not self.IsIn(e):
                s3.add(e)
        return s3
```

### 1.3.3 存储结构对算法的影响
存储结构对算法的影响主要在两方面[15]：
1. **存储结构的存储能力**：不同的存储结构具有不同的存储特性
2. **存储结构应与所选择的算法相适应**：选择适合算法操作的存储结构能提高效率

## 1.4 算法和算法分析

### 1.4.1 算法
**算法**是对特定问题求解步骤的一种描述，是指令的有限序列。算法具有以下特性：
- **有穷性**：算法必须在执行有限步骤后终止
- **确定性**：算法的每一步必须有确切的定义
- **可行性**：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现
- **输入**：算法有零个或多个输入
- **输出**：算法有一个或多个输出

### 1.4.2 算法设计的要求
算法的设计目标包括[11]：
1. **正确性**：算法应满足具体问题的需求
2. **可使用性**：算法应方便使用
3. **可读性**：算法应易于理解
4. **健壮性**：算法对非法输入应有适当的反应
5. **高时间性能与低存储量需求**：算法应具有高效率

### 1.4.3 算法效率的度量

#### 1.4.3.1 时间复杂度分析
**时间复杂度**是算法所需时间的度量，表示为问题规模n的函数。

**分析方法**：
1. **事后统计法**：编写程序统计执行时间，但受语言、环境等因素影响[14]
2. **事前估算法**：撇开具体因素，认为算法的执行时间是问题规模n的函数[14]

**基本概念**：
- **问题规模n**：算法求解问题的输入量大小
- **算法频度T(n)**：算法中所有原操作的执行次数[49]
- **基本操作**：算法中最深层循环内的原操作[49]

**时间复杂度表示**：
算法的时间复杂度T(n)是问题规模n的某个函数f(n)，记作：T(n) = O(f(n))[14]

其中"O"的形式定义为：T(n) = O(f(n))表示存在一个正的常数c，使得当n≥n₀时都满足：|T(n)| ≤ c|f(n)|[14]

**常见时间复杂度比较**：
O(1) < O(log₂n) < O(n) < O(nlog₂n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)[49]

**时间复杂度分类**：
1. **最好时间复杂度B(n)**：算法在最好情况下的时间复杂度[4]
   $$B(n) = \min\{T(I)\} \quad I∈D_n$$[4]

2. **最坏时间复杂度W(n)**：算法在最坏情况下的时间复杂度[4]
   $$W(n) = \max\{T(I)\} \quad I∈D_n$$[4]

3. **平均时间复杂度A(n)**：考虑所有可能输入的平均情况[4]
   $$A(n) = \sum_{I∈D_n} P(I)T(I)$$[4]

**示例**：查找算法的时间复杂度分析[4]
```python
def fun(a, n, k):  # 在数组a[0..n-1]中查找元素k
    i = 0
    while i < n and a[i] != k:
        i += 1
    return i
```
- 最好情况：a[0]=k，比较1次，时间复杂度为O(1)
- 最坏情况：a[n-1]=k，比较n次，时间复杂度为O(n)
- 平均情况：平均比较次数=(1+2+...+n)/n=(n+1)/2=O(n)

#### 1.4.3.2 时间性能比较
假如求同一问题有两个算法：A和B，如果算法A的平均时间复杂度为O(n)，而算法B的平均时间复杂度为O(n²)。一般情况下，认为算法A的时间性能好比算法B[4]。

### 1.4.4 算法的存储空间需求

#### 1.4.4.1 空间复杂度分析
**空间复杂度**是对一个算法在运行过程中临时占用的存储空间大小的量度，一般也作为问题规模n的函数，以数量级形式给出，记作：S(n) = O(g(n))[4]。

**空间复杂度计算原则**：
一个算法的存储量包括形参所占空间和临时变量所占空间。在对算法进行存储空间分析时，**只考察临时变量所占空间**[4]。

**为什么只考虑临时空间？**
例如以下算法[4]：
```python
def Max(a, n):
    maxi = 0
    for i in range(1, n):
        if a[i] > a[maxi]:
            maxi = i
    return a[maxi]

def Maxfun():
    b = [1, 2, 3, 4, 5]
    n = 5
    print("Max=%d" % (Max(b, n)))
```
- 如果Max函数中再考虑形参a的空间，就重复累计了执行整个算法所需的空间
- Maxfun算法中为b数组分配了相应的内存空间，其空间复杂度为O(n)

**空间复杂度示例**[11]：
1. 例1.8：空间复杂度为O(1)
   ```python
   def matrixadd(A, B, C, n):
       for i in range(n):
           for j in range(n):
               C[i].append(A[i][j] + B[i][j])
   ```

2. 例1.9：空间复杂度为O(1)
   ```python
   def fun(n):
       s = 0
       for i in range(n+1):
           for j in range(i+1):
               for k in range(j):
                   s += 1
       return s
   ```

3. 例1.10：空间复杂度为O(1)
   ```python
   def fun(a, n, k):
       i = 0
       while i < n and a[i] != k:
           i += 1
       return i
   ```

#### 1.4.4.2 空间复杂度与时间复杂度的权衡
在算法设计中，通常需要在时间复杂度和空间复杂度之间进行权衡：
- **时间换空间**：通过增加计算时间来减少存储空间的使用
- **空间换时间**：通过增加存储空间来减少计算时间

优秀的算法应该在时间和空间效率上取得平衡，根据具体应用场景选择适当的策略。

---

**总结**：数据结构与算法是计算机科学的核心基础，Niklaus Wirth提出的著名公式"数据结构+算法=程序"[12]深刻揭示了它们之间的关系。掌握数据结构的基本概念、抽象数据类型的表示与实现方法，以及算法分析技术，对于设计高效、可靠的计算机程序至关重要。