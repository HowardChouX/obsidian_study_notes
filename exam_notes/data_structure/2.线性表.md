# 第2章 线性表

## 2.1 线性表的类型定义

线性表是具有相同特性的数据元素的一个有限序列[1]。所有数据元素类型相同，线性表是有限个数据元素构成的，线性表中数据元素与位置相关，即每个数据元素有唯一的序号[4]。

线性表的逻辑结构表示：（a₀，a₁，…，aᵢ，aᵢ₊₁，…，aₙ₋₁）[4]。用图形表示的逻辑结构：线性表中每个元素aᵢ的唯一位置通过序号或者索引i表示，为了算法设计方便，将逻辑序号和存储序号统一，均假设从0开始，这样含n个元素的线性表的元素序号i满足0≤i≤n-1[4]。

线性表的抽象数据类型描述ADT List[10]：
```python
ADT List {
    数据对象：D={a_i | 0≤i≤n-1，n≥0，a_i为E类型}
    数据关系：r={<a_i，a_{i+1}> | a_i，a_{i+1}∈D，i=0，…，n-2}
    基本运算：
        CreateList(a)：由整数数组a中的全部元素建立线性表的相应存储结构。
        Add(e)：将元素e添加到线性表末尾。
        getsize()：求线性表的长度。
        GetElem(int i)：求线性表中序号为i的元素。
        SetElem(int i，E e)：设置线性表中序号i的元素值为e。
        GetNo(E e)：求线性表中第一个值为e的元素的序号。
        Insert(int i，E e)：在线性表中插入数据元素e作为第i个元素。
        Delete(int i)：在线性表中删除第i个数据元素。
        display()：输出线性表的所有元素。
}
```

## 2.2 线性表的顺序表示和实现

### 2.2.1 线性表的顺序存储结构—顺序表

长度为n的线性表存放在顺序表中[10]。data数组存放线性表元素，data数组的容量（存放最多的元素个数）为capacity，线性表中实际数据元素个数为size[10]。

顺序表的存储结构：用一组地址连续的存储单元依次存储数据元素[10]。

### 2.2.2 线性表基本运算算法在顺序表中的实现

在动态分配顺序表的空间时，初始容量设置为initcapacity，当添加或者插入元素可能需要扩大容量，在删除元素时可能需要减少容量[10]。

**整体建立顺序表**[18]：
```python
def CreateList(self, a):  # 由数组a中元素整体建立顺序表
    self.size = 0
    for i in range(0, len(a)):
        if self.size == self.capacity:  # 出现上溢出时
            self.resize(2 * self.size)  # 扩大容量
        self.data[self.size] = a[i]
        self.size += 1  # 添加后元素个数增加1
```

**顺序表基本运算算法**：
1. **Add(e)**：将元素e添加到线性表末尾[18]
2. **getsize()**：求线性表长度[4]
3. **GetElem(i)**：求线性表中序号为i的元素[4]
4. **SetElem(i, e)**：设置线性表中序号为i的元素[25]
5. **GetNo(e)**：求线性表中第一个值为e的元素的逻辑序号[24]
6. **Insert(i, e)**：在线性表中插入e作为第i个元素
7. **Delete(i)**：在线性表中删除第i个数据元素[25]
8. **display()**：输出线性表所有元素[25]

### 2.2.3 顺序表的应用算法设计示例

**例2.1**：对于含有n个整数元素的顺序表L，设计一个算法将其中所有元素逆置[18]。

**例2.3**：对于含有n个整数元素的顺序表L，设计一个算法用于删除其中所有值为x的元素[1]。

**例2.4**：有两个按元素值递增有序的整数顺序表A和B，设计一个算法将顺序表A和B的全部元素合并到一个递增有序顺序表C中[29]。

## 2.3 线性表的链式表示和实现

### 2.3.1 线性链表（单链表）

**单链表的存储结构**：每个结点为LinkNode类对象，包括存储元素的数据列表data和存储后继结点的指针属性next[26]。

如果每个结点只设置一个指向其后继结点的指针成员，这样的链表称为线性单向链接表，简称**单链表**[26]。

**单链表的基本操作**：
1. **插入结点操作**：将结点s插入到单链表中p结点的后面[31]
2. **删除结点操作**：删除单链表中p结点的后继结点[31]

**整体建立单链表的方法**：
1. **头插法建表**：从一个空表开始，依次读取数组a中的元素，将新结点插入到当前链表的表头上[19]
2. **尾插法建表**：从一个空表开始，依次读取数组a中的元素，将新结点插入到当前链表的表尾上[13]

**单链表基本运算算法**：
1. **Add(e)**：将元素e添加的线性表末尾[12]
2. **getsize()**：求线性表的长度[12]
3. **GetElem(i)**：求线性表中序号为i的元素[19]
4. **SetElem(i, e)**：设置线性表中序号为i的元素[19]
5. **GetNo(e)**：求线性表中第一个值为e的元素的逻辑序号[13]
6. **Insert(i, e)**：在线性表中插入e作为第i个元素[12]
7. **Delete(i)**：在线性表中删除第i个数据元素[12]
8. **display()**：输出线性表所有元素[12]

**单链表的应用算法设计示例**：
- **例2.6**：有一个长度大于2的整数单链表L，设计一个算法查找L中中间位置的元素[7]
- **例2.7**：有一个整数单链表L，其中可能存在多个值相同的结点，设计一个算法查找L中最大值结点的个数[31]
- **例2.8**：有一个整数单链表L，其中可能存在多个值相同的结点，设计一个算法删除L中所有最大值的结点[31]
- **例2.9**：有一个整数单链表L，设计一个算法逆置L中的所有结点[26]
- **例2.10**：有一个含2n个整数的单链表L，设计一个算法将其拆分成两个带头结点的单链表A和B[7]
- **例2.11**：有两个递增有序整数单链表A和B，设计一个算法采用二路归并方法将A和B的所有数据结点合并到递增有序单链表C中[20]
- **例2.12**：有两个递增有序整数单链表A和B，假设每个单链表中没有值相同的结点，但两个单链表中存在相同值的结点，设计一个尽可能高效的算法建立一个新的递增有序整数单链表C[14]

### 2.3.2 循环链表

**循环单链表**：形成一个环[11]。循环单链表的插入和删除结点操作与非循环单链表的相同，所以两者的许多基本运算算法是相似的[11]。

循环单链表类CLinkList[11]：
```python
class CLinkList:  # 循环单链表类
    def __init__(self):  # 构造方法
        self.head = LinkNode()  # 头结点head
        self.head.next = self.head  # 构成循环单链表
```

**循环双链表**：形成两个环，可以快速找到尾结点[17]。循环双链表的插入和删除结点操作与非循环双链表的相同[17]。

循环双链表类DCLinkList[17]：
```python
class CDLinkList:  # 循环双链表类
    def __init__(self):  # 构造方法
        self.dhead = DLinkNode()  # 头结点dhead
        self.dhead.next = self.dhead
        self.dhead.prior = self.dhead
```

**约瑟夫问题示例**（例2.16）：编写一个程序求解约瑟夫问题[11]。

### 2.3.3 双向链表

**双链表的存储结构**：每个结点为DLinkNode类对象，包括存储元素的列表data、存储前驱结点指针属性prior和后继结点的指针属性next[20]。

如果每个结点中设置两个指针成员，分别用以指向其前驱结点和后继结点，这样的链表称之为线性双向链接表，简称**双链表**[26]。

**双链表的基本操作**：
1. **插入结点操作**：将结点s插入到双链表中p结点的后面[2]
2. **删除结点操作**：删除双链表中的p结点[2]

**整体建立双链表的方法**：
1. **头插法建表**：由数组a整体建立双链表[2]
2. **尾插法建表**：由数组a整体建立双链表[5]

**双链表基本运算算法**：
许多运算算法（如求长度、取元素值和查找元素等）与单链表中相应算法是相同的，涉及结点插入和删除操作的算法需要改为按双链表的方式进行结点插入和删除[5]。

**双链表的应用算法设计示例**：
- **例2.13**：设计一个算法，删除整数双链表L中第一个值为x的结点[17]
- **例2.14**：设计一个算法，将整数双链表L中最后一个值为x的结点与其前驱结点交换[28]
- **例2.18**：有一个带头结点的循环双链表L，其结点data成员值为整数，设计一个算法，判断其所有元素是否对称[23]

## 2.4 一元多项式的表示及相加

### 2.4.1 问题描述

多项式求两个多项式相加的程序[3]。例如：
- p(x) = 2x³ + 3.2x⁵ - 6x + 10
- q(x) = 6x + 1.8x⁵ - 2x³ + x² - 2.5x⁴ - 5
- r(x) = p(x) + q(x) = 5x⁵ - 2.5x⁴ + x² + 5

### 2.4.2 问题求解

**1. 设计顺序存储结构**
每个多项式项用一个列表[cᵢ，eᵢ]（其中cᵢ为系数，eᵢ为指数）存储，一个多项式顺序表用元素为列表[cᵢ，eᵢ]的列表data存储[6]。

例如，多项式p(x)=2x³+3.2x⁵-6x+10的data列表为[[2.0, 3], [3.2, 5], [-6.0, 1], [10.0, 0]][6]。

**多项式抽象数据类型ADT PolyClass**[6]：
```python
ADT PolyClass {
    数据对象：PolyElem={(c_i，e_i) | 1≤i≤n，c_i∈float，e_i∈int};
    数据关系：r={<x_i，y_i> | x_i，y_i∈PolyElem，i=1，…，n-1}
    基本运算：
        Add(e)：将多项式项e添加到末尾。
        CreateList(fname)：从fname文件中读取数据建立多项式。
        getsize()：返回多项式的项数
        getitem(i)：返回序号为i的多项式项。
        getdata()：返回多项式。
        Sort()：对多项式按指数递减排序。
        PolyAdd(B)：返回当前多项式与多项式B的相加结果。
}
```

**2. 设计PolyList的基本运算算法**[6]：
1. **构造方法**：`__init__(self)`
2. **Add(e)**：将多项式项e添加到末尾
3. **CreateList(fname)**：从fname文件中读取多项式数据并添加到data[8]
4. **getsize()**：返回多项式的项数[8]
5. **getitem(i)**：返回序号为i的多项式项[8]
6. **getdata()**：返回多项式列表[3]
7. **Sort()**：对多项式按指数递减排序[3]
8. **PolyAdd(B)**：返回当前多项式与多项式B的相加结果[3]

**3. 多项式相加算法**[9]：
用i、j分别遍历A和B的元素，先建立一个空多项式顺序表C，在i、j都没有遍历完时循环：
- 若a元素的指数较大，将a元素添加到C中，i增加1
- 若b元素的指数较大，将b元素添加到C中，j增加1
- 若a、b元素的指数相同，求出它们的系数和k，如果k≠0，由k和a[1]新建一个元素并添加到C中，否则不新建结点，并将i、j均增加1

**4. 设计主程序**[9]：
从文件中读取多项式数据，进行排序和相加操作，将结果输出到文件中。

### 2.4.3 顺序表和链表的比较

**1. 基于空间的考虑**[5]：
- 顺序表的存储密度为1，而链表的存储密度小于1
- 顺序表需要预先分配初始空间，所有数据占用一整片地址连续的内存空间
- 链表的存储空间是动态分配的，只要内存有空闲，就不会出现上溢出

**2. 基于时间的考虑**[5]：
- 顺序表具有随机存取特性，给定序号查找对应的元素值的时间为O(1)
- 链表不具有随机存取特性，只能顺序访问，给定序号查找对应的元素值的时间为O(n)
- 在顺序表中插入和删除操作时，通常需要平均移动半个表的元素
- 在链表中插入和删除操作仅仅需要修改相关结点的指针成员，不必移动结点

**结论**：
- 若线性表的运算主要是查找，很少做插入和删除操作，宜采用顺序表作为存储结构
- 若频繁地做插入和删除操作，宜采用链表作为存储结构
- 当线性表的长度变化不大，易于事先确定的情况下，为了节省存储空间，宜采用顺序表作为存储结构
- 当线性表的长度变化较大，难以估计其存储大小时，为了节省存储空间，宜采用链表作为存储结构[5]