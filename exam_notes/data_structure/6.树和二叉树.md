# 第6章 树和二叉树

## 6.5 树与等价问题

树在等价问题中有着重要的应用，特别是在**并查集**（Union-Find）数据结构中。并查集用于处理不相交集合的合并与查询问题，是解决等价类问题的有效工具。

### 6.5.1 等价关系与等价类
- **等价关系**：具有自反性、对称性和传递性的关系
- **等价类**：等价关系将集合划分为若干个互不相交的子集，每个子集称为一个等价类

### 6.5.2 并查集的实现
并查集通常使用**树形结构**来表示集合，每个集合用一棵树表示，树的根结点作为该集合的代表元素。

**并查集的基本操作**：
1. **初始化**：每个元素单独构成一个集合
2. **查找**（Find）：查找元素所在集合的代表元素（根结点）
3. **合并**（Union）：将两个集合合并为一个集合

**并查集的优化技术**：
1. **路径压缩**：在查找操作中，将查找路径上的所有结点直接连接到根结点
2. **按秩合并**：在合并操作中，将较矮的树合并到较高的树中

## 6.6 赫夫曼树及其应用

### 6.6.1 最优二叉树（赫夫曼树）

**定义**：在$n_0$个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为**哈夫曼树**（或最优二叉树）[2]。

**带权路径长度**（Weighted Path Length, WPL）：从树根结点到某个结点之间的路径长度与该结点权的乘积称为结点的**带权路径长度**。一棵二叉树树中所有叶子结点的带权路径长度之和称为该树的带权路径长度[2]。

**哈夫曼树的构造算法**[9]：
1. 根据给定的$n_0$个权值$W=(w_1，w_2，…，w_{n_0})$，对应结点构成$n_0$棵二叉树的森林$T=(T_1，T_2，…，T_{n_0})$，其中每棵二叉树$T_i$（$1≤i≤n_0$）中都只有一个带权值为$w_i$的根结点，其左、右子树均为空。
2. 在森林$T$中选取两棵根结点权值最小的子树作为左、右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根的权值之和。称为合并，每合并一次$T$中减少一棵二叉树。
3. 重复（2）直到$T$只含一棵树为止。这棵树便是**哈夫曼树**。

**哈夫曼树的性质**：
- 哈夫曼树中没有单分支结点[9]
- 对于具有$n_0$个叶子结点的哈夫曼树，共有$2n_0-1$个结点[8]

**定理6.3**：对于具有$n_0$个叶子结点的哈夫曼树，共有$2n_0-1$个结点[8]。

**证明**：从哈夫曼树的构造过程看出，每次合并都是将两棵二叉树合并为一个，所以哈夫曼树不存在度为1的结点，即$n_1=0$[8]。
由二叉树的性质1可知$n_0=n_2+1$，即$n_2=n_0-1$
则结点总数$n=n_0+n_1+n_2=n_0+n_2=n_0+2n_0-1=2n_0-1$[8]。

### 6.6.2 赫夫曼编码

**哈夫曼编码的构造方法**[5]：
1. 构造一棵哈夫曼树。
2. 规定哈夫曼树中的左分支为0，右分支为1。
3. 从根结点到每个叶子结点所经过的分支对应的0和1组成的序列便为该结点对应字符的编码。这样的编码称为**哈夫曼编码**。

**哈夫曼编码的特点**：
- 哈夫曼编码的实质就是使用频率越高的采用越短的编码[5]
- 在一组字符的哈夫曼编码中，任一字符的哈夫曼编码不可能是另一字符哈夫曼编码的前缀[2]

**哈夫曼编码示例**：
给定4个叶子结点，权值分别为1、3、5、7，构造哈夫曼树[9]：
```
16
├──9
│  ├──4
│  │  ├──1 (a: 000)
│  │  └──3 (b: 001)
│  └──5 (c: 01)
└──7 (d: 1)
```
对应的哈夫曼编码为：
- a: 000
- b: 001
- c: 01
- d: 1[5]

**哈夫曼编码算法实现**：
```python
def CreateHCode():  # 根据哈夫曼树求哈夫曼编码
    global n0,ht,hcd  # hcd存放哈夫曼编码
    hcd=[]
    for i in range(n0):  # 遍历下标从0到n0-1的叶子结点
        code=[]  # 存放ht[i]结点的哈夫曼编码
        j=i  # 从ht[i]开始找双亲结点
        while ht[j].parent!=-1:
            if ht[j].flag:  # ht[j]结点是双亲的左孩子
                code.append("0")
            else:  # ht[j]结点是双亲的右孩子
                code.append("1")
            j=ht[j].parent
        code.reverse()  # 逆置code
        hcd.append(''.join(code))  # 将code转换为字符串并添加到hcd中
```

## 6.7 回溯法与树的遍历

回溯法是一种通过**深度优先搜索**来解决问题的算法设计方法，它通过系统地搜索问题的解空间来找到所有解或最优解。

### 6.7.1 回溯法的基本思想
回溯法采用**试错**的思想，它尝试分步去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答时，它将取消上一步甚至是上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。

### 6.7.2 回溯法与树遍历的关系
回溯法通常使用**深度优先搜索**（DFS）来遍历问题的解空间树：
1. **解空间树**：问题的解可以表示为一棵树的结构
2. **深度优先搜索**：从根结点开始，沿着树的深度遍历树的结点
3. **剪枝**：在搜索过程中，如果发现当前路径不可能得到解，则回溯到上一个结点，尝试其他路径

### 6.7.3 回溯法的应用示例
回溯法常用于解决以下问题：
1. **八皇后问题**：在8×8的棋盘上放置8个皇后，使得它们互不攻击
2. **图的着色问题**：用最少的颜色给图的顶点着色，使得相邻顶点颜色不同
3. **子集和问题**：找出集合中所有和为特定值的子集
4. **排列组合问题**：生成所有可能的排列或组合

**回溯法框架**：
```python
def backtrack(路径, 选择列表):
    if 满足结束条件:
        结果.append(路径)
        return
  
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

## 6.8 树的计数

树的计数问题研究具有特定性质的树的数量，这是组合数学和图论中的重要问题。

### 6.8.1 不同形态的二叉树计数
对于$n$个结点的二叉树，不同形态的数量由**卡特兰数**（Catalan Number）给出：
$$C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$$

其中，$C_n$表示$n$个结点可以构成的不同形态的二叉树的数量。

**卡特兰数的前几项**：
- $C_0 = 1$（空树）
- $C_1 = 1$（只有一个结点的二叉树）
- $C_2 = 2$
- $C_3 = 5$
- $C_4 = 14$
- $C_5 = 42$

### 6.8.2 不同形态的树计数
对于$n$个结点的树（无根树），不同形态的数量由**凯莱公式**给出：
$$T_n = n^{n-2}$$

其中，$T_n$表示$n$个标号顶点可以构成的不同形态的树的数量。

### 6.8.3 二叉搜索树计数
对于$n$个不同的关键字，可以构造的不同形态的二叉搜索树的数量也是卡特兰数$C_n$。

**证明思路**：
1. 选择根结点：有$n$种选择
2. 左子树：包含$i$个结点（$0≤i≤n-1$）
3. 右子树：包含$n-1-i$个结点
4. 递归关系：$C_n = \sum_{i=0}^{n-1} C_i × C_{n-1-i}$

### 6.8.4 树的同构计数
两个树$T_1$和$T_2$称为**同构**的，如果存在一个双射$f: V(T_1) → V(T_2)$，使得对于$T_1$中的任意两个顶点$u$和$v$，$u$和$v$在$T_1$中相邻当且仅当$f(u)$和$f(v)$在$T_2$中相邻。

**树同构的判断算法**：
1. **有根树同构**：可以通过比较树的括号表示或层次序列来判断
2. **无根树同构**：需要找到树的中心或重心，然后作为根进行判断

**树的计数在算法分析中的应用**：
1. **算法复杂度分析**：某些算法的运行时间与输入树的形态有关
2. **数据结构设计**：平衡树、堆等数据结构的性能分析与优化
3. **组合优化**：在通信网络、电路设计等领域有广泛应用

树的计数问题是计算机科学和组合数学的交叉领域，它不仅具有理论价值，也在实际应用中发挥着重要作用。