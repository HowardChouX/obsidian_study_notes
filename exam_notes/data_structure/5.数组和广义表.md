# 第5章 数组和广义表

## 5.1 数组的定义

**数组**是一个二元组（idx，value）的集合，对每个idx，都有一个value值与之对应[5]。idx称为下标，可以由一个整数、两个整数或多个整数构成，下标含有d（d≥1）个整数称为维数是d[5]。

**数组按维数分类**：
- **一维数组**：A是n（n>1）个相同特性元素a₀，a₁，…，aₙ₋₁构成的有限序列，其逻辑表示为A =（a₀，a₁，…，aₙ₋₁），其中，A是数组名，aᵢ（0≤i≤n-1）是数组A中序号为i的元素[5]
- **二维数组**：可以看作是每个数据元素都是相同特性的一维数组的一维数组[5]
- **多维数组**：以此类推

**数组的特点**[7]：
1. 数组中各元素都具有相同的特性
2. d（d≥1）维数组中的非边界元素具有d个前驱元素和d个后继元素
3. 数组维数确定后，数据元素个数和元素之间的关系不再发生改变，特别适合于顺序存储
4. 每个有意义的下标都存在一个与其相对应的数组元素值

**数组抽象数据类型**[7]：
```python
ADT Array {
    数据对象：D={数组中所有元素}
    数据关系：R={r₁，r₂，…，r_d}
        r_i={元素之间第i维的线性关系 | i=1，…，d}
    基本运算：
        Value(A，i₁，i₂，…，i_d)：A是已存在的d维数组，其运算结果是返回A[i₁，i₂，…，i_d]值
        Assign(A，e，i₁，i₂，…，i_d)：A是已存在的d维数组，其运算结果是置A[i₁，i₂，…，i_d]=e
        ...
}
```

## 5.2 数组的顺序表示和实现

### 5.2.1 一维数组的存储
**一维数组**的所有元素依逻辑次序存放在一片连续的内存存储单元中[7]。其起始地址为第一个元素a₀的地址即LOC(a₀)[7]。假设每个数据元素占用k个存储单元，则任一数据元素aᵢ的存储地址LOC(aᵢ)可由以下公式求出：
$$LOC(a_i)=LOC(a_0)+i×k \quad (1≤i<n)$$[7]

一维数组具有随机存储特性[7]。

在Python中长度为n的一维数组{a₀，a₁，…，aₙ₋₁}通常采用形如[a₀，a₁，…，aₙ₋₁]的列表表示[7]。例如，以下语句创建一个长度为MAXN的一维数组a，初始元素值均为None：
```python
MAXN=10
a=[None]*MAXN
```

### 5.2.2 二维数组的存储
**二维数组**以m行n列的二维数组Aₘ×ₙ=(aᵢ，ⱼ)为例讨论（二维数组也称为矩阵）[7]。

**按行优先存储**[4]：
- aᵢ，ⱼ前面有0～i-1共i行，每行n个元素，共有i×n个元素
- 在第i行中前面有a[i,0..j-1]，共j个元素
- 合起来，aᵢ，ⱼ前面有i×n+j个元素
$$LOC(a_{i,j})=LOC(a_{0,0})+(i×n+j)×k$$[4]

**按列优先存储**[4]：
- aᵢ，ⱼ前面有0～j-1共j列，每列m个元素，共有j×m个元素
- 在第j列中前面有a[0..i-1,j]，共i个元素
- 合起来，aᵢ，ⱼ前面有j×m+i个元素
$$LOC(a_{i,j})=LOC(a_{0,0})+(j×m+i)×k$$[4]

**更一般的情况**[4]：
对于数组A[c₁..d₁，c₂..d₂]，则该数组按行优先存储时有：
$$LOC(a_{i,j})=LOC(a_{c₁,c₂})+[(i-c₁)×(d₂-c₂+1)+(j-c₂)]×k$$
按列优先存储时有：
$$LOC(a_{i,j})=LOC(a_{c₁,c₂})+[(j-c₂)×(d₁-c₁+1)+(i-c₁)]×k$$

**示例**[1]：
设有二维数组a[1..50，1..80]，其a[1][1]元素的地址为2000，每个元素占2个存储单元：
- 按行优先存储：元素a[45][68]的存储地址为9174[1]
- 按列优先存储：元素a[45][68]的存储地址为8788[1]

在Python中m行n列的二维数组{{a₀,₀，a₀,₁，…，a₀,ₙ₋₁}，…，{aₘ₋₁,₀，aₘ₋₁,₁，…，aₘ₋₁,ₙ₋₁}}通常采用形如[[a₀,₀，a₀,₁，…，a₀,ₙ₋₁]，…，[aₘ₋₁,₀，aₘ₋₁,₁，…，aₘ₋₁,ₙ₋₁]]的嵌套列表表示[2]。

## 5.3 矩阵的压缩存储

### 5.3.1 特殊矩阵

#### 1. 对称矩阵的压缩存储
若一个n阶方阵A的元素满足aᵢ,ⱼ=aⱼ,ᵢ（0≤i，j≤n-1），则称其为n阶**对称矩阵**[3]。

对称矩阵的压缩存储：下三角+主对角线共n(n+1)/2个元素[3]。
$$B=(a_{0,0}，a_{1,0}，a_{1,1}，⋯，a_{n-1,0}，a_{n-1,1}，⋯，a_{n-1,n-1})$$

**地址映射公式**[3]：
$$k=\begin{cases}
\frac{i(i+1)}{2}+j & \text{当 }i≥j\text{ 时（下三角+主对角线的元素）}\\
\frac{j(j+1)}{2}+i & \text{当 }i<j\text{ 时（}a_{i,j}=a_{j,i}\text{）}
\end{cases}$$

#### 2. 三角矩阵的压缩存储
**上三角矩阵**[3]：
$$k=\begin{cases}
\frac{i(2n-i+1)}{2}+j-i & \text{当 }i≤j\text{ 时}\\
\frac{n(n+1)}{2} & \text{当 }i>j\text{ 时（存放常量c）}
\end{cases}$$

**下三角矩阵**[2]：
$$k=\begin{cases}
\frac{i(i+1)}{2}+j & \text{当 }i≥j\text{ 时}\\
\frac{n(n+1)}{2} & \text{当 }i<j\text{ 时（存放常量c）}
\end{cases}$$

#### 3. 对角矩阵的压缩存储
**半带宽为b的对角矩阵**压缩存储[4]。当b=1时称为**三对角矩阵**，其压缩地址计算公式如下：
$$k=2i+j$$[6]

### 5.3.2 稀疏矩阵

#### 1. 稀疏矩阵的定义
一个阶数较大的矩阵中的非零元素个数s相对于矩阵元素的总个数t十分小时，即st时，称该矩阵为**稀疏矩阵**[6]。例如一个100×100的矩阵，若其中只有100个非零元素，就可称其为稀疏矩阵[6]。

**稀疏矩阵和特殊矩阵的不同点**[6]：
- 特殊矩阵的特殊元素（值相同元素、常量元素）分布有规律
- 稀疏矩阵的特殊元素（非0元素）分布没有规律

#### 2. 稀疏矩阵的三元组表示
**三元组表示**中每个元素的类定义如下[6]：
```python
class TupElem:  # 三元组元素类
    def __init__(self,r1,c1,d1):  # 构造方法
        self.r=r1  # 行号
        self.c=c1  # 列号
        self.d=d1  # 元素值
```

**三元组表示类**[6]：
```python
class TupClass:  # 三元组表示类
    def __init__(self,rs,cs,ns):  # 构造方法
        self.rows=rs  # 行数
        self.cols=cs  # 列数
        self.nums=ns  # 非零元素个数
        self.data=[]  # 稀疏矩阵对应的三元组顺序表
```

其中，data列表用于存放稀疏矩阵中所有非零元素，通常**按行优先顺序排列**。这种有序结构可简化大多数稀疏矩阵运算算法[6]。

**基本运算方法**[6]：
- `CreateTup(A,m,n)`：由m行n列的稀疏矩阵A创建其三元组表示
- `Setvalue(i,j,x)`：利用三元组给稀疏矩阵的元素赋值即执行A[i][j]=x
- `GetValue(i,j)`：利用三元组取稀疏矩阵的元素值即执行x=A[i][j]
- `DispTup()`：输出稀疏矩阵的三元组表示

#### 3. 稀疏矩阵的十字链表表示
**十字链表表示**中每个非零元素对应一个结点[5]。

**结点结构**[12]：
- 非0元素结点结构：(a) i j value down right
- 头结点结构：(b) i j link down right

**十字链表的组织方式**[12]：
- 每行的所有结点链起来构成一个带行头结点的循环单链表。以h[i]（0≤i≤m-1）作为第i行的头结点[33]
- 每列的所有结点链起来构成一个带列头结点的循环单链表。以h[i]（0≤i≤m-1）作为第i列的头结点[33]
- 行、列头结点可以共享，行、列头结点个数=MAX(m，n)[12]
- 增加一个总头结点，并把所有行、列头结点链起来构成一个循环单链表，总的头结点个数=MAX(m,n)+1[12]

## 5.4 广义表的定义

广义表（Generalized List）是线性表的推广，也称为列表（Lists）。广义表是n（n≥0）个元素a₁，a₂，…，aₙ的有限序列，记作：
$$LS=(a₁，a₂，…，aₙ)$$

其中：
- aᵢ可以是单个元素（称为原子），也可以是一个广义表（称为子表）
- LS是广义表的名字，n是它的长度
- 若aᵢ是广义表，则称它为LS的子表
- 广义表的深度定义为广义表中括号嵌套的最大层数

**广义表的特点**：
1. **层次性**：广义表中的元素可以是子表，而子表中的元素还可以是子表
2. **共享性**：广义表可以被其他广义表共享
3. **递归性**：广义表可以是递归定义的，即广义表可以是其自身的子表

**广义表的示例**：
- A=()：空表，长度为0
- B=(e)：只含有一个原子的广义表，长度为1
- C=(a，(b，c，d))：长度为2，第二个元素是子表
- D=(A，B，C)=((), (e), (a，(b，c，d)))：长度为3
- E=(a，E)=(a，(a，(a，…)))：递归表，长度为2

## 5.5 广义表的存储结构

广义表通常采用链式存储结构，主要有两种表示方法：

### 1. 头尾表示法
在头尾表示法中，广义表中的每个元素用一个结点表示，结点有两种类型：
- **表结点**：表示子表，包含tag=1、指向表头的指针hp和指向表尾的指针tp
- **原子结点**：表示原子，包含tag=0和值value

**结点结构**：
```python
class GLNode:
    def __init__(self, tag):
        self.tag = tag  # 标志域：0表示原子，1表示子表
      
class AtomNode(GLNode):
    def __init__(self, value):
        super().__init__(0)
        self.value = value  # 原子值
      
class ListNode(GLNode):
    def __init__(self):
        super().__init__(1)
        self.hp = None  # 指向表头
        self.tp = None  # 指向表尾
```

### 2. 孩子兄弟表示法（长子兄弟链表示法）
在孩子兄弟表示法中，每个结点包含：
- 标志域tag：0表示原子，1表示子表
- 原子值value（当tag=0时）
- 指向第一个孩子（长子）的指针
- 指向下一个兄弟的指针

**结点结构**：
```python
class EBNode:  # 长子兄弟链中结点类
    def __init__(self, d=None):
        self.data = d  # 结点的值
        self.brother = None  # 指向兄弟
        self.eson = None  # 指向长子结点
```

孩子兄弟表示法的优点是结构统一，便于实现广义表的各种操作。

## 5.6 m元多项式的表示

m元多项式是指含有m个变元的多项式，例如二元多项式：
$$P(x,y)=∑_{i=0}^{m}∑_{j=0}^{n}a_{ij}x^iy^j$$

**m元多项式的表示方法**：

### 1. 线性表表示
可以将m元多项式表示为线性表，每个元素包含系数和指数向量。例如，三元多项式可以表示为：
$$P(x,y,z)=∑a_{ijk}x^iy^jz^k$$

对应的线性表元素为：(系数，i，j，k)

### 2. 广义表表示
m元多项式可以用广义表来表示，特别是当多项式稀疏时，使用广义表可以节省存储空间。

**示例**：三元多项式
$$P(x,y,z)=x^{10}y^3z^2+2x^6y^3z^2+3x^5y^2z^2+x^4y^4z+6x^3y^4z+2yz+15$$

可以用广义表表示为：
$$P=((x^{10}+2x^6+3x^5)y^3+(x^4+6x^3)y^4)z^2+((2y)z+15)$$

**存储结构设计**：
可以采用孩子兄弟表示法来存储m元多项式：
- 根结点表示整个多项式
- 中间结点表示变元
- 叶子结点表示系数和指数

**多项式抽象数据类型**[15]：
```python
ADT PolyClass {
    数据对象：PolyElem={(c_i，e_i) | 1≤i≤n，c_i∈float，e_i∈int}
    数据关系：rx_i，y_i> | x_i，y_i∈PolyElem，i=1，…，n-1}
    基本运算：
        Add(e)：将多项式项e添加到末尾
        CreateList(fname)：从fname文件中读取数据建立多项式
        getsize()：返回多项式的项数
        getitem(i)：返回序号为i的多项式项
        getdata()：返回多项式
        Sort()：对多项式按指数递减排序
        PolyAdd(B)：返回当前多项式与多项式B的相加结果
}
```

**多项式顺序表类**[15]：
```python
class PolyList:  # 多项式顺序表类
    def __init__(self):  # 构造方法
        self.data=[]  # 存放多项式项的列表
```

每个多项式项用一个列表[cᵢ，eᵢ]（其中cᵢ为系数，eᵢ为指数）存储，一个多项式顺序表用元素为列表[cᵢ，eᵢ]的列表data存储[15]。例如，多项式p(x)=2x³+3.2x⁵-6x+10的data列表为[[2.0, 3], [3.2, 5], [-6.0, 1], [10.0, 0]][15]。

**多项式相加算法**[28]：
用i、j分别遍历A和B的元素，先建立一个空多项式顺序表C，在i、j都没有遍历完时循环，取i指向的A中元素a，取j指向的B中元素b：
1. 若a元素的指数（a[1]）较大，将a元素添加到C中，i增加1
2. 若b元素的指数（b[1]）较大，将b元素添加到C中，j增加1
3. 此时a、b元素的指数相同（a[1]=b[1]），求出它们的系数和k（k=a[0]+b[0]），如果k≠0，由k和a[1]新建一个元素并添加到C中，否则不新建结点，并将i、j均增加1

上述循环过程结束后，若有一个多项式顺序表没有遍历完，说明余下的多项式项都是指数较小的多项式项，将它们均添加到C中，最后返回C[28]。