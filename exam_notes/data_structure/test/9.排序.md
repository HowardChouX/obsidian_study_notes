# 第9章 排序重要知识点测试题目

## 一、选择题（每题5分）

1. **排序基本概念题**
   所谓**排序**，就是要整理表中的元素，使之按关键字递增或递减有序排列，本章仅讨论递增排序的情况，在默认情况下所有的排序均指递增排序[3]。排序的输入输出如下：输入：n个元素序列为R₀、R₁、…、Rₙ₋₁，其相应的关键字分别为k₀、k₁、…、kₙ₋₁。输出：Rᵢ₀，Rᵢ₁，…，Rᵢₙ₋₁，使得kᵢ₀≤kᵢ₁≤…≤kᵢₙ₋₁[3]。以下哪项描述是正确的？
   A. 排序算法的性能由算法的时间和空间确定，而时间又是由比较和移动的次数确定的[3]
   B. 若待排序元素的关键字顺序正好和排序顺序相同，称此表中元素为**反序**[3]
   C. 若待排序元素的关键字顺序正好和排序顺序相反，称此表中元素为**正序**[3]
   D. 基于比较的排序算法的平均时间复杂度可以优于O(nlog₂n)

2. **排序稳定性题**
   当待排序元素的关键字均不相同时，排序的结果是唯一的，否则排序的结果不一定唯一。如果待排序的表中，存在有多个关键字相同的元素，经过排序后这些具有相同关键字的元素之间的相对次序保持不变，则称这种排序方法是**稳定的**。反之，若具有相同关键字的元素之间的相对次序发生变化，则称这种排序方法是**不稳定的**[12]。以下哪种排序算法是稳定的？
   A. 快速排序
   B. 希尔排序
   C. 堆排序
   D. 直接插入排序[12]

3. **希尔排序题**
   希尔排序的排序思路是：将n个元素分成d个组，相距d个位置的元素分为一组[17]。例如：将n个元素分成d个组：{R[0]，R[d]，R[2d]，…，R[kd]}，{R[1]，R[1+d]，R[1+2d]，…，R[1+kd]}，…，{R[d-1]，R[2d-1]，R[3d-1]，…，R[(k+1)d-1]}[17]。以下关于希尔排序的描述正确的是：
   A. 希尔排序是一种稳定的排序算法
   B. 希尔排序的时间复杂度为O(n²)
   C. 希尔排序中，当d=1时，对所有元素进行直接插入排序[17]
   D. 希尔排序的最好情况时间复杂度为O(n)

4. **快速排序题**
   快速排序的基本思路是：无序的记录序列→无序子序列①→无序子序列②→基准[22]。每趟使表的第1个元素放入适当位置（归位），将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为0或1（递归出口）[22]。以下关于快速排序的描述正确的是：
   A. 快速排序在最坏情况下的时间复杂度为O(nlog₂n)
   B. 快速排序是一种稳定的排序算法
   C. 快速排序中，如果初始数据序列正序或者反序，性能最差[23]
   D. 快速排序的平均时间复杂度为O(n²)

## 二、填空题（每题5分）

1. 在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为**内排序**。反之，若排序过程中要进行数据的内、外存交换，则称之为**外排序**[3]。

2. 直接插入排序的排序思路：有序区R[0]……R[i-1]，无序区R[i]……R[n-1]。初始时，有序区只有一个元素R[0]。i=1~n-1，共经过n-1趟排序[13]。

3. 冒泡排序的排序思路：初始有序区为空。i=0~n-2，共n-1趟使整个数据有序。R[i]为有序区R[0]……R[i-1]，无序区R[i]R[i+1]……R[n-1]。将无序区中最小元素放在R[i][2]。

4. 堆排序中，一个序列R[0..n-1]，关键字分别为k₀、k₁、…、kₙ₋₁。堆的定义：该序列满足如下性质（简称为堆性质）：kᵢ≤k₂ᵢ₊₁且kᵢ≤k₂ᵢ₊₂或kᵢ≥k₂ᵢ₊₁且kᵢ≥k₂ᵢ₊₂（0≤i≤⌊n/2⌋-1）。满足第①种情况的堆称为**小根堆**，满足第②种情况的堆称为**大根堆**[8]。

## 三、简答题（每题10分）

1. **排序算法分类**
   根据参考材料，内排序可以分为哪些类别？请说明基于比较的排序和不基于比较的排序各包括哪些算法[3]。

2. **直接插入排序过程**
   设待排序表有10个元素，其关键字序列为（9，8，7，6，5，4，3，2，1，0）。说明采用直接插入排序方法进行排序的过程[13]。请写出前5趟的排序结果。

3. **堆排序算法步骤**
   描述堆排序算法的基本步骤。设待排序的表有10个记录，其关键字分别为{6，8，7，9，0，1，3，2，4，5}，说明采用堆排序方法进行排序的过程[21]。

4. **基数排序思路**
   描述基数排序的基本思路。假设线性表由元素序列a₁、a₂、…、aₙ构成，每个结点aⱼ的关键字由d元组(kᵈ⁻¹，kᵈ⁻²，…，k⁰)组成，其中每个元素值在0到r-1之间[9]。说明最低位优先排序的过程。

## 四、算法分析题（每题15分）

1. **快速排序划分算法分析**
   分析以下快速排序划分算法的思路：
   ```python
   def Partition1(R,s,t):  # 划分算法1
       base = R[s]  # 以表首元素为基准
       i,j = s,t
       while i<j:  # 从表两端交替向中间遍历，直至i=j为止
           while i<j and R[j]>=base:  # 从后向前遍历，找一个小于基准的R[j]
               j -= 1
           while i<j and R[i]<=base:  # 从前向后遍历，找一个大于基准的R[i]
               i += 1
           if i<j:
               R[i],R[j] = R[j],R[i]  # 将R[i]和R[j]进行交换
       R[s],R[i] = R[i],R[s]  # 将基准R[s]和R[i]进行交换
       return i
   ```
   分析该算法的时间复杂度和空间复杂度[1]。

2. **归并排序时间复杂度分析**
   分析二路归并排序的时间复杂度。设R[0..n-1]排序的时间为T(n)，当n>1时，MergeSort21(0,n/2)和MergeSort21(n/2+1,n-1)两个子问题的时间均为T(n/2)，而Merge的时间为O(n)[5]。对应的递推式如下：
   - T(n)=1 当n=1时
   - T(n)=2T(n/2)+n 当n>1时
 
   请求解该递推式，得到归并排序的时间复杂度[5]。

## 五、程序设计题（20分）

**外排序-置换选择排序**
设计一个置换-选择排序算法生成初始归并段。要求：
1. 从待排文件F_in中按内存工作区WA的容量w读入w个元素
2. 从WA中选出关键字最小的元素R_min
3. 将R_min元素输出到当前归并段F_i
4. 若F_in不空，则从F_in中读入下一个元素x放在R_min所在的工作区位置代替R_min
5. 在工作区中所有≥R_min的元素中选择出最小元素作为新的R_min
6. 设i=i+1，开始一个新的归并段
7. 若工作区已空，则初始归并段已全部产生；否则转（2）[15]

请写出该算法的主要思路，并分析：
1. 算法的时间复杂度
2. 算法的空间复杂度
3. 与常规方法生成初始归并段的区别

**提示**：参考置换-选择排序方法[15]。

---

**参考答案要点：**

一、选择题：
1. A[3] 2. D[12] 3. C[17] 4. C[23]

二、填空题：
1. 内排序，外排序[3]
2. 有序区只有一个元素R[0]，n-1趟排序[13]
3. 将无序区中最小元素放在R[i][2]
4. 小根堆，大根堆[8]

三、简答题：
1. 内排序分类：基于比较的排序（插入排序、交换排序、选择排序、归并排序）和不基于比较的排序（基数排序）[3]。
2. 直接插入排序过程：[13]
   - 初始：[9] 8 7 6 5 4 3 2 1 0
   - i=1：[8 9] 7 6 5 4 3 2 1 0
   - i=2：[7 8 9] 6 5 4 3 2 1 0
   - i=3：[6 7 8 9] 5 4 3 2 1 0
   - i=4：[5 6 7 8 9] 4 3 2 1 0
3. 堆排序步骤：先建立初始大根堆，然后进行n-1趟排序，每趟将堆顶元素与无序区尾元素交换，再对无序区调整为大根堆[21]。
4. 基数排序思路：采用多关键字排序思想，将单个关键字分为多个位，每个位看成一个关键字。最低位优先排序：对i=0、1、…，d-1（从低位到高位），依次做一次"分配"和"收集"[9]。

四、算法分析题：
1. 时间复杂度：O(n)，每个元素最多被比较一次。空间复杂度：O(1)，只使用固定数量的变量[1]。
2. 递推式求解：T(n)=2T(n/2)+n，解得T(n)=O(nlog₂n)[5]。

五、程序设计题：
主要思路：使用工作区WA存放w个元素，每次选出最小元素输出到归并段，然后从输入文件读入新元素替换，继续选择≥当前最小值的元素。
1. 时间复杂度：O(nlogw)，每个元素需要logw次比较
2. 空间复杂度：O(w)，工作区大小
3. 与常规方法的区别：置换-选择排序可以生成长度大于w的初始归并段，而常规方法每个归并段长度最多为w[15]。