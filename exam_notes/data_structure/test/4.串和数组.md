# 第4章 串和数组重要知识点测试题目

## 一、选择题（每题5分）

1. **串的基本概念题**
   串是由零个或多个字符组成的有限序列[1]。设s是一个长度为n的串，其中的字符各不相同，则s中的所有子串个数是多少[1]？
   A. n(n+1)/2
   B. n(n-1)/2+1
   C. n(n+1)/2+1
   D. n²

2. **串的存储结构题**
   顺序串类SqString中，data数组的容量为MaxSize，size表示data数组中实际字符的个数[2]。以下关于顺序串的描述正确的是：
   A. data数组必须采用固定容量
   B. 可以模仿顺序表改为动态容量方式[2]
   C. size表示data数组的最大容量
   D. 顺序串只能存储字符类型数据

3. **模式匹配算法题**
   设有两个串s和t，串t定位操作就是在串s中查找与子串t相等的子串[3]。通常把串s称为目标串，把串t称为模式串[3]。BF算法在最坏情况下的时间复杂度为：
   A. O(n)
   B. O(m)
   C. O(n+m)
   D. O(n×m)[10]

4. **KMP算法题**
   在KMP算法中，设目标串s的长度为n，模式串t长度为m。求next数组的时间复杂度为O(m)，在匹配中因主串s的下标i不减即不回溯，比较次数可记为n[9]。KMP算法总的时间复杂度为：
   A. O(n×m)
   B. O(n+m)[9]
   C. O(log(n+m))
   D. O(nlogm)

## 二、填空题（每题5分）

1. 串的抽象数据类型ADT String中，数据关系r定义为：raᵢ，aᵢ₊₁> | aᵢ，aᵢ₊₁∈D，i=0，…，n-2}[2]。

2. BF算法（Brute-Force算法）也称为暴力匹配算法或朴素匹配算法或简单匹配算法[3]。

3. 在KMP算法中，next[j]的公式为：next[j]=MAX{k | 0k<j且"t₀t₁…tₖ₋₁"="tⱼ₋ₖtⱼ₋ₖ₊₁…tⱼ₋₁"}，当前缀非空时；当j=0时，next[j]=-1；其他情况，next[j]=0[9]。

4. 数组是一个二元组（idx，value）的集合，对每个idx，都有一个value值与之对应[18]。idx称为下标，可以由一个整数、两个整数或多个整数构成，下标含有d（d≥1）个整数称为维数是d[18]。

## 三、简答题（每题10分）

1. **串的比较算法**
   设计一个算法Strcmp(s，t)，以字典顺序比较两个英文字母串s和t的大小，假设两个串均以顺序串存储[1]。请描述算法的基本思路。

2. **顺序串求子串算法**
   描述顺序串求子串运算算法的实现过程。对于一个顺序串求序号i开始长度为j的子串，当参数正确时，s子串的字符序列为data[i..i+j-1]，共j个字符[4]。

3. **BF算法分析**
   以目标串s="aaaaab"，模式串t="aaab"为例，分析BF算法的匹配过程[4]。计算总共需要的关键字比较次数。

4. **KMP算法的改进**
   描述改进KMP算法（使用nextval数组）的基本思路。设主串s="aaabaaaab"，模式串t="aaaab"，说明基本KMP算法存在的问题[6]。

## 四、算法分析题（每题15分）

1. **KMP算法next数组计算**
   分析以下计算next数组算法的思路：
   ```python
   def GetNext(t,next):  # 由模式串t求出next值
       j,k=0,-1
       next[0]=-1
       while j<t.getsize()-1:
           if k==-1 or t[j]==t[k]:
               j,k=j+1,k+1
               next[j]=k
           else:
               k=next[k]
   ```
   以模式串t="abcac"为例，计算其next数组[6]。

2. **改进KMP算法nextval数组计算**
   分析以下计算nextval数组算法的思路：
   ```python
   def GetNextval(t,nextval):  # 由模式串t求出nextval值
       j,k=0,-1
       nextval[0]=-1
       while j<t.getsize()-1:
           if k==-1 or t[j]==t[k]:
               j,k=j+1,k+1
               if t[j]!=t[k]:
                   nextval[j]=k
               else:
                   nextval[j]=nextval[k]
           else:
               k=nextval[k]
   ```
   以模式串t="aaaab"为例，计算其nextval数组[7]。

## 五、程序设计题（20分）

**稀疏矩阵的十字链表表示**
设计稀疏矩阵的十字链表存储结构。每个非零元素对应一个结点[13]。要求：
1. 设计结点类型，包含行号、列号、值、向下指针、向右指针
2. 每行的所有结点链起来构成一个带行头结点的循环单链表[15]
3. 每列的所有结点链起来构成一个带列头结点的循环单链表[15]
4. 增加一个总头结点，并把所有行、列头结点链起来构成一个循环单链表[12]

请写出该存储结构的Python类定义，并分析：
1. 存储空间复杂度
2. 查找指定位置(i,j)元素的时间复杂度
3. 矩阵转置算法的实现思路

**提示**：参考稀疏矩阵的十字链表表示方法[13][15]。

---

**参考答案要点：**

一、选择题：
1. C[1] 2. B[2] 3. D[10] 4. B[9]

二、填空题：
1. raᵢ，aᵢ₊₁> | aᵢ，aᵢ₊₁∈D，i=0，…，n-2}[2]
2. 暴力匹配算法或朴素匹配算法或简单匹配算法[3]
3. next[j]=MAX{k | 0k<j且"t₀t₁…tₖ₋₁"="tⱼ₋ₖtⱼ₋ₖ₊₁…tⱼ₋₁"}，当j=0时，next[j]=-1[9]
4. 下标，维数是d[18]

三、简答题：
1. 先求s和t中最小长度minl，在共同长度内逐个字符比较，如果对应字符都相等时，比较长度[1]。
2. 先创建一个空串s，当参数正确时，s子串的字符序列为data[i..i+j-1]，共j个字符，当i和i+j-1不在有效序号0～size-1范围内时，则参数错误，此时返回空串[4]。
3. 第1趟匹配比较4次，第2趟匹配比较4次，第3趟匹配比较4次，共比较12次[4]。
4. 基本KMP算法存在的问题：当t[j]=t[next[j]]时，s[i]≠t[j]可以推出s[i]≠t[next[j]]，没有必要再做s[i]/t[next[j]]的比较[6]。

四、算法分析题：
1. 模式串t="abcac"的next数组：next[0]=-1, next[1]=0, next[2]=0, next[3]=0, next[4]=1[6]。
2. 模式串t="aaaab"的nextval数组：nextval[0]=-1, nextval[1]=-1, nextval[2]=-1, nextval[3]=-1, nextval[4]=3[7]。

五、程序设计题：
主要思路：设计结点类包含行号、列号、值、down、right指针；设计矩阵类包含行头结点数组、列头结点数组和总头结点。
1. 存储空间复杂度：O(t+max(m,n))，其中t为非零元素个数，m、n为矩阵行列数。
2. 查找指定位置(i,j)元素的时间复杂度：O(该行或该列非零元素个数)。
3. 矩阵转置：交换行和列的角色，重新建立十字链表结构[13][15]。