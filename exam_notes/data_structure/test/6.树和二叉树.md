# 第6章 树和二叉树重要知识点测试题目

## 一、选择题（每题5分）

1. **树的基本概念题**
   树是由n（n≥0）个结点组成的有限集合（记为T）[25]。如果n>0，这n个结点中存在（有仅存在）一个结点作为树的根结点（root），其余结点可分为m（m≥0）个互不相交的有限集T₁、T₂、…、Tₘ，其中每个子集本身又是一棵符合本定义的树，称为根结点的子树[25]。以下哪项描述是正确的？
   A. 树中每个结点可以有多个前驱结点
   B. 树是一种非线性数据结构，具有层次关系[25]
   C. 树中所有结点都必须有孩子结点
   D. 空树不是树的特例

2. **二叉树性质题**
   非空二叉树上叶结点数等于双分支结点数加1，即n₀=n₂+1[4]。设一棵二叉树有10个叶子结点，则度为2的结点个数是：
   A. 9
   B. 10
   C. 11
   D. 12

3. **完全二叉树性质题**
   完全二叉树（结点个数为n）层序编号后的性质中，若完全二叉树的根结点编号为1，对于编号为i（1≤i≤n）的结点有：若i≤⌊n/2⌋，即2i≤n，则编号为i的结点为分支结点，否则为叶子结点[4]。对于一棵有10个结点的完全二叉树，最后一个分支结点的编号是：
   A. 5
   B. 6
   C. 7
   D. 8

4. **哈夫曼树题**
   在n₀个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树（或最优二叉树）[23]。对于具有n₀个叶子结点的哈夫曼树，共有多少个结点？
   A. n₀
   B. n₀+1
   C. 2n₀-1[44]
   D. 2n₀+1

## 二、填空题（每题5分）

1. 具有n个结点的m次树的最小高度为$\lceil \log_m(n(m-1)+1) \rceil$[1]。

2. 二叉树也称为二分树，它是有限的结点集合，这个集合或者是空，或者由一个根结点和两棵互不相交的称为左子树和右子树的二叉树组成[2]。

3. 在二叉链存储结构中，每个结点包含三个域：数据元素域、指向左孩子的指针域和指向右孩子的指针域[27]。

4. 线索二叉树分为先序、中序和后序线索二叉树。对二叉树以某种方式遍历使其变为线索二叉树的过程称为线索化[6]。

## 三、简答题（每题10分）

1. **树与二叉树的区别**
   简述度为2的树与二叉树的主要区别[4]。

2. **二叉树的遍历序列**
   对于一棵二叉树，已知先序遍历序列和中序遍历序列能否唯一确定该二叉树？已知先序遍历序列和后序遍历序列能否唯一确定该二叉树？请说明理由[12][21]。

3. **哈夫曼树的构造**
   描述哈夫曼树的构造算法步骤[43]。给定4个叶子结点，权值分别为1、3、5、7，画出构造出的哈夫曼树。

4. **树与二叉树的转换**
   描述树转换为二叉树的规则[8]。一棵树转换为二叉树后，根结点有什么特点？

## 四、算法分析题（每题15分）

1. **二叉树高度算法分析**
   分析以下求二叉树高度算法的思路：
   ```python
   def Height(self):  # 求二叉树高度的算法
       return self._Height(self.b)
 
   def _Height(self,t):  # 被Height方法调用
       if t==None:
           return 0  # 空树的高度为0
       else:
           lh=self._Height(t.lchild)  # 求左子树高度lchildh
           rh=self._Height(t.rchild)  # 求右子树高度rchildh
           return max(lh,rh)+1
   ```
   设f(t)为以t为根结点二叉树的高度，空树高度为0，非空树高度为左、右子树中较大的高度加1[2]。请分析该算法的时间复杂度和空间复杂度。

2. **二叉树查找结点算法分析**
   分析以下查找值为x的结点算法的思路：
   ```python
   def FindNode(self,x):  # 查找值为x的结点算法
       return self._FindNode(self.b,x)
 
   def _FindNode(self,t,x):  # 被FindNode方法调用
       if t==None:
           return None  # t为空时返回None
       elif t.data==x:
           return t  # t所指结点值为x时返回t
       else:
           p=self._FindNode(t.lchild,x)  # 在左子树中查找
           if p!=None:
               return p  # 在左子树中找到p结点，返回p
           else:
               return self._FindNode(t.rchild,x)  # 返回在右子树中查找结果
   ```
   设f(t,x)在以t为根结点的二叉树中查找值为x的结点，找到后返回其地址，否则返回None[28]。请分析该算法的时间复杂度和空间复杂度。

## 五、程序设计题（20分）

**二叉树复制算法设计**
假设二叉树采用二叉链存储结构存储，设计一个算法将二叉树bt1复制到二叉树bt2[20]。

要求：
1. 采用基于先序遍历的递归算法
2. 写出递归模型
3. 实现Python代码
4. 分析算法的时间复杂度和空间复杂度

递归模型[20]：
```
f(t1，t2) ≡ t2=None 当t1=None
f(t1，t2) ≡ 由t1根结点复制产生t2根结点; 当t1≠None
           f(t1.lchild，t2.lchild);
           f(t1.rchild，t2.rchild);
```

请写出完整的算法实现，并分析：
1. 算法的时间复杂度
2. 算法的空间复杂度
3. 如果采用后序遍历思路，算法应如何修改？

---

**参考答案要点：**

一、选择题：
1. B[25] 2. A[4] 3. A[4] 4. C[44]

二、填空题：
1. $\lceil \log_m(n(m-1)+1) \rceil$[1]
2. 二分树，左子树，右子树[2]
3. 数据元素域，左孩子指针域，右孩子指针域[27]
4. 先序、中序、后序，线索化[6]

三、简答题：
1. 度为2的树至少有3个结点，而二叉树的结点数可以为0。度为2的树不区分子树的次序，而二叉树中的每个结点最多有两个孩子结点，且必须要区分左右子树，即使在结点只有一棵子树的情况下也要明确指出该子树是左子树还是右子树[4]。
2. 由先序遍历序列和中序遍历序列能够唯一确定一棵二叉树[12]。由先序遍历序列和后序遍历序列不能唯一确定一棵二叉树[21]。
3. 哈夫曼树构造步骤：（1）根据给定的n₀个权值对应结点构成n₀棵二叉树的森林；（2）在森林中选取两棵根结点权值最小的子树作为左、右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根的权值之和；（3）重复（2）直到只含一棵树为止[43]。
4. 树转换为二叉树的规则：加线、抹线、调整[8]。转换后根结点只有左子树而没有右子树[8]。

四、算法分析题：
1. 时间复杂度：O(n)，需要遍历所有结点。空间复杂度：O(h)，递归深度为树的高度h[2]。
2. 时间复杂度：O(n)，最坏情况下需要遍历所有结点。空间复杂度：O(h)，递归深度为树的高度h[28]。

五、程序设计题：
主要思路：基于先序遍历，先复制根结点，再递归复制左子树和右子树。
1. 时间复杂度：O(n)，需要遍历bt1的所有结点。
2. 空间复杂度：O(h)，递归深度为树的高度h。
3. 采用后序遍历思路：先递归复制左子树和右子树，再复制根结点[20]。