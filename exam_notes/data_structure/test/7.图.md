# 第7章 图重要知识点测试题目

## 一、选择题（每题5分）

1. **图的基本概念题**
   图G（Graph）由两个集合V（Vertex）和E（Edge）组成，记为G=(V，E)[6]。V是顶点的有限集合，记为V(G)。E是连接V中两个不同顶点（顶点对）的边的有限集合，记为E(G)[6]。以下哪项描述是正确的？
   A. 图中可以重复出现一条边
   B. 数据结构中的图一般不重复出现一条边，如果允许重复边出现，这样的图称为多重图[13]
   C. 有向图中边用圆括号表示
   D. 无向图中边用尖括号表示

2. **图的度计算题**
   在一个无向图中，顶点所关联的边的数目称为该顶点的度[13]。在有向图中，顶点i的度又分为入度和出度，以顶点i为终点的入边的数目，称为该顶点的入度。以顶点i为起点的出边的数目，称为该顶点的出度[13]。对于有向图邻接矩阵g，求顶点v的出度和入度的算法中，以下哪项是正确的？
   A. 出度统计第v行的非0非∞元素个数，入度统计第v列的非0非∞元素个数[8]
   B. 出度统计第v列的非0非∞元素个数，入度统计第v行的非0非∞元素个数
   C. 出度和入度都统计第v行的元素
   D. 出度和入度都统计第v列的元素

3. **最小生成树算法题**
   一个带权连通图G（假定每条边上的权值均大于零）可能有多棵生成树。每棵生成树中所有边上的权值之和可能不同。其中边上的权值之和最小的生成树称为图的最小生成树[3]。以下关于普里姆算法的描述正确的是：
   A. 普里姆算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法[5]
   B. 普里姆算法的时间复杂度为O(e log₂e)[5]
   C. 普里姆算法特别适合于稀疏图求最小生成树
   D. 普里姆算法中有两重for循环，所以时间复杂度为O(n²)，其中n为图的顶点个数[5]

4. **最短路径算法题**
   狄克斯特拉算法用于求带权有向图中某个源点到其他各顶点的最短路径。以下关于狄克斯特拉算法的描述正确的是：
   A. 狄克斯特拉算法适合含负权回路的图求最短路径
   B. 狄克斯特拉算法的时间复杂度为O(n³)
   C. 狄克斯特拉算法中，判断顶点i属于哪个集合，设置一个数组S，S[i]=1表示顶点i属于S集合，S[i]=0表示顶点i属于U集合[24]
   D. 狄克斯特拉算法可以求所有顶点对之间的最短路径

## 二、填空题（每题5分）

1. 图的抽象数据类型ADT Graph中，数据关系r定义为：r={aᵢ，aⱼ> | aᵢ，aⱼ∈D，0≤i≤n-1，0≤j≤n-1，其中aᵢ可以有零个或多个前驱元素，可以有零个或多个后继元素}[6]。

2. 图的遍历是指从给定图中任意指定的顶点（称为初始点）出发，按照某种搜索方法沿着图的边访问图中的所有顶点，使每个顶点仅被访问一次[2]。

3. 拓扑排序的过程如下：（1）从有向图中选择一个没有前驱（即入度为0）的顶点并且输出它。（2）从图中删去该顶点，并且删去从该顶点发出的全部有向边。（3）重复上述两步，直到剩余的图中不再存在没有前驱的顶点为止[9]。

4. 在AOE网中，活动a的最早开始时间e(a)指该活动起点x事件的最早开始时间，即：e(a)=ee(x)。活动a的最迟开始时间l(a)指终点y事件的最迟开始时间与该活动所需时间之差，即：l(a)=le(y)-c[20]。

## 三、简答题（每题10分）

1. **邻接矩阵与邻接表的比较**
   比较图的邻接矩阵和邻接表两种存储结构的优缺点，并说明各自适合的场景[1][6]。

2. **深度优先遍历与广度优先遍历**
   描述图的深度优先遍历（DFS）和广度优先遍历（BFS）的基本思路，并比较它们的特点[2][11]。

3. **克鲁斯卡尔算法**
   描述克鲁斯卡尔算法的基本步骤，并分析其时间复杂度[5]。为什么克鲁斯卡尔算法特别适合于稀疏图求最小生成树？

4. **关键路径算法**
   描述AOE网中求关键路径的基本步骤，包括如何计算事件的最早开始时间ee(v)和最迟开始时间le(v)，以及如何确定关键活动[19][20]。

## 四、算法分析题（每题15分）

1. **判断图中是否有路径算法**
   分析以下判断顶点u到顶点v是否有路径算法的思路：
   ```python
   def HasPath(G,u,v):  # 判断u到v是否有简单路径
       for i in range(G.n):
           visited[i]=0  # 初始化
       return HasPath1(G,u,v)
 
   def HasPath1(G,u,v):  # 被HasPath方法调用
       visited[u]=1
       for j in range(len(G.adjlist[u])):  # 处理顶点u的所有出边
           w=G.adjlist[u][j].adjvex  # 取顶点u的第j个邻接点w
           if w==v:  # 找到目标点后返回真
               return True  # 表示u到v有路径
           if visited[w]==0:
               if HasPath1(G,w,v)==True:
                   return True
       return False
   ```
   分析该算法的时间复杂度和空间复杂度[4][7]。

2. **求图中所有简单路径算法**
   分析以下求顶点u到顶点v的所有简单路径算法的思路：
   ```python
   def FindallPath1(G,u,v):  # 解法1：求u到v的所有简单路径
       path=[-1]*MAXV
       d=-1  # path[0..d]存放一条路径
       for i in range(G.n):
           visited[i]=0  # 初始化
       FindallPath11(G,u,v,path,d)
 
   def FindallPath11(G,u,v,path,d):  # 被Findapath1调用
       visited[u]=1
       d+=1; path[d]=u  # 顶点u加入到路径中
       if u==v:  # 找到一条路径后输出
           for i in range(d+1):
               print(' '+path[i],end='')
           print()  # 输出一条路径后不返回
       for j in range(len(G.adjlist[u])):  # 处理顶点u的所有出边
           w=G.adjlist[u][j].adjvex  # 取顶点u的第j个邻接点w
           if visited[w]==0:  # w没有访问过
               FindallPath11(G,w,v,path,d)  # 递归调用
       visited[u]=0  # 回溯，重置visited[u]为0
   ```
   分析该算法的时间复杂度和空间复杂度[16][17]。

## 五、程序设计题（20分）

**弗洛伊德算法求所有顶点对的最短路径**
设计一个算法采用弗洛伊德算法求带权有向图中所有顶点对之间的最短路径[37]。

要求：
1. 采用邻接矩阵存储图
2. 设计A数组和path数组
3. 实现弗洛伊德算法核心部分
4. 输出所有顶点对之间的最短路径长度和路径

算法设计要点[37]：
- 建立A数组和path数组
- 给数组A和path置初值即求A⁻¹[i][j]
- 通过三重循环求Aᵏ[i][j]
- 输出所有的最短路径和长度

请写出完整的算法实现，并分析：
1. 算法的时间复杂度
2. 算法的空间复杂度
3. 弗洛伊德算法与狄克斯特拉算法的区别

---

**参考答案要点：**

一、选择题：
1. B[13] 2. A[8] 3. D[5] 4. C[24]

二、填空题：
1. r={aᵢ，aⱼ> | aᵢ，aⱼ∈D，0≤i≤n-1，0≤j≤n-1，其中aᵢ可以有零个或多个前驱元素，可以有零个或多个后继元素}[6]
2. 初始点，每个顶点仅被访问一次[2]
3. 没有前驱（即入度为0），删去该顶点发出的全部有向边[9]
4. e(a)=ee(x)，l(a)=le(y)-c[20]

三、简答题：
1. 邻接矩阵：存储密度为1，适合稠密图；判断两点间是否有边O(1)；求顶点的度O(n)。邻接表：存储空间较小，适合稀疏图；求顶点的度需要遍历链表；判断两点间是否有边需要遍历链表[1][6]。
2. DFS：从起始点出发，沿着一条路径尽可能深地搜索，直到不能再继续为止，然后回溯继续搜索。BFS：从起始点出发，逐层向外扩展搜索。DFS使用栈（递归或显式栈），BFS使用队列[2][11]。
3. 克鲁斯卡尔算法步骤：（1）置U的初值等于V，TE的初值为空集。（2）将图G中的边按权值从小到大的顺序依次选取：若选取的边未使生成树T形成回路，则加入TE；否则舍弃，直到TE中包含n-1条边为止[5]。时间复杂度O(e log₂e)，适合稀疏图。
4. 关键路径算法步骤：（1）进行拓扑排序。（2）按拓扑顺序计算各事件的ee(v)。（3）按拓扑逆序计算各事件的le(v)。（4）计算各活动的e(a)、l(a)和d(a)。（5）d(a)=0的活动为关键活动[19][20]。

四、算法分析题：
1. 时间复杂度：最坏情况下需要遍历所有顶点和边，O(n+e)。空间复杂度：递归深度最多为n，O(n)[4][7]。
2. 时间复杂度：指数级，最坏情况下需要遍历所有路径。空间复杂度：递归深度最多为n，O(n)[16][17]。

五、程序设计题：
主要思路：使用三重循环，通过中间顶点k逐步优化所有顶点对之间的最短路径。
1. 时间复杂度：O(n³)，三重循环。
2. 空间复杂度：O(n²)，需要A数组和path数组。
3. 区别：狄克斯特拉算法求单源最短路径，时间复杂度O(n²)；弗洛伊德算法求所有顶点对最短路径，时间复杂度O(n³)[37]。