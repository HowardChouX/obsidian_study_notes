# 第8章 查找重要知识点测试题目

## 一、选择题（每题5分）

1. **查找基本概念题**
   查找表按照操作方式分为静态查找表和动态查找表两类[6]。静态查找表是只作查找操作的查找表，主要操作有查询某个"特定的"数据元素是否在查找表中，检索某个"特定的"数据元素及其属性[6]。动态查找表是在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素[6]。以下哪项描述是正确的？
   A. 顺序表是一种静态查找表[11]
   B. 树表属于动态查找表[8]
   C. 静态查找表支持插入和删除操作
   D. 动态查找表只能进行查找操作

2. **平均查找长度题**
   查找算法中的主要操作是关键字之间的比较，所以通常把查找过程中关键字平均比较次数也就是平均查找长度作为衡量一个查找算法效率优劣的依据[6]。以下关于平均查找长度的描述正确的是：
   A. ASL成功是指找到T中任一记录平均需要的关键字比较次数[6]
   B. ASL不成功是指查找失败（在T中未查找到）平均需要的关键字比较次数[6]
   C. 在等概率情况下，每个元素的查找概率相等，即$p_i=1/n$[6]
   D. 以上都正确

3. **顺序查找题**
   顺序查找的优点是算法简单，且对查找表的存储结构无特殊要求，无论是用顺序表还是用链表来存放元素，也无论是元素之间是否按关键字有序，它都同样适用[12]。顺序查找的缺点是查找效率低，因此，当n较大时不宜采用顺序查找[12]。假设所有不成功查找的情况为m种，它们的查找概率相同，即$q_i=0.5/m$，则顺序查找的时间复杂度为：
   A. O(1)
   B. O(log n)
   C. O(n)[12]
   D. O(n²)

4. **折半查找题**
   折半查找的基本思路是设R[low..high]是当前的非空查找区间（下界为low，上界为high），首先确定该区间的中点位置mid=⌊(low+high)/2⌋，然后将待查的k值与R[mid]比较[5]。以下关于折半查找的描述正确的是：
   A. 折半查找要求查找表必须有序[5]
   B. 折半查找的时间复杂度为O(log₂n)[10]
   C. 借助一棵二叉判定树很容易求得折半查找的平均查找长度[22]
   D. 以上都正确

## 二、填空题（每题5分）

1. 查找定义为：给定一个值k，在含有n个元素的查找表中找出关键字等于k的元素。若找到这样的元素，表示查找成功，返回该元素的信息或该元素在表中的位置；否则查找不成功或者查找失败，返回相应的指示信息[6]。

2. 顺序查找算法2中设置一个哨兵：R.append(k)在末尾添加一个哨兵，然后从表头往后找，当R[i]!=k时i++，直到找到或到达哨兵位置[11]。

3. 折半查找的递归算法BinSearch21中，当low≤high时，当前查找区间非空，求查找区间的中间位置mid=(low+high)//2，如果k==R[mid]则查找成功返回其序号mid[2]。

4. 分块查找的索引存储结构是在采用数据表存储数据的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式为（关键字，地址）[4]。

## 三、简答题（每题10分）

1. **顺序查找算法分析**
   分析顺序查找算法在仅考虑查找成功的情况下的平均查找长度。假设查找表中有n个元素，每个元素的查找概率相等[11]。

2. **折半查找判定树**
   描述如何构建折半查找的判定树。给定11个元素的有序表R[0..10]，画出对应的判定树，并说明内部结点和外部结点的含义[22]。

3. **分块查找过程**
   描述分块查找的基本过程。设有25个元素的关键字序列为：8,14,6,9,10,22,34,18,19,31,40,38,54,66,46,71,78,68,80,85,100,94,88,96,87，如何分块？查找关键字k=80的过程是怎样的[1]？

4. **折半查找算法正确性分析**
   分析以下两个折半查找算法的正确性，指出哪个算法是正确的，哪个是错误的，并说明原因[2]：
   ```python
   def BSearch1(R,k):
       n=len(R)
       low,high=0,n-1
       while low<=high:
           mid=(low+high)//2
           if k==R[mid]:
               return mid
           if k<R[mid]:
               high=mid-1
           else:
               low=mid
       return -1
 
   def BSearch2(R,k):
       n=len(R)
       low,high=0,n-1
       while lowhigh:
           mid=(low+high)//2
           if k==R[mid]:
               return mid
           if k<R[mid]:
               high=mid-1
           else:
               low=mid+1
       if R[low]==k:
           return low
       else:
           return -1
   ```

## 四、算法分析题（每题15分）

1. **折半查找扩展：查找插入点**
   分析以下在有序表R中查找插入点算法的思路：
   ```python
   def GOEk(R,k):  # 查找第一个大于或者等于k的序号即k的插入点
       n=len(R)
       low,high=0,n-1
       while low<=high:  # 当前区间非空时
           mid=(low+high)//2  # 求查找区间的中间位置
           if k<=R[mid]:  # 继续在R[low..mid-1]中查找
               high=mid-1
           else:  # k>R[mid]
               low=mid+1  # 继续在R[mid+1..high]中查找
       return high+1  # 返回high+1
   ```
   分析该算法的时间复杂度和空间复杂度[4]。

2. **分块查找算法分析**
   分析分块查找算法的时间复杂度。假设有n个元素，分为b个块，每块有s个元素。如果采用折半查找确定元素所在的块，则分块查找成功时的平均查找长度为[7]：
   $$ASL_{blk} = ASL_{bn} + ASL_{sq} ≈ \log_2(b+1)-1 + \frac{s+1}{2}$$
   当s越小时，ASL_blk的值越小。请解释为什么当采用折半查找确定块时，每块的长度越小越好[7]？

## 五、程序设计题（20分）

**查找与k最接近的元素**
有一个按整数关键字key递增有序的顺序表R，其中关键字可能重复出现。设计一个算法返回与k最接近的元素关键字，若有多个最接近的元素关键字时，返回较大的那一个[4]。

例如：
- R = (1,3,8,8,12)，k=6时最接近的元素是8
- R = (1,3,8,8,12)，k=10时最接近的元素是12

要求：
1. 写出算法的主要思路
2. 实现Python代码
3. 分析算法的时间复杂度和空间复杂度
4. 如果R中有多个相同的关键字，算法应如何处理？

**提示**：可以利用折半查找找到k的插入点，然后比较插入点前后的元素[4]。

---

**参考答案要点：**

一、选择题：
1. A[11] B[8] 2. D[6] 3. C[12] 4. D[5][10][22]

二、填空题：
1. 给定一个值k，在含有n个元素的查找表中找出关键字等于k的元素[6]
2. R.append(k)，哨兵[11]
3. low≤high，mid=(low+high)//2，k==R[mid][2]
4. 索引表，（关键字，地址）[4]

三、简答题：
1. 第1个元素即R[0]=k，1次关键字比较；第2个元素即R[1]=k，2次关键字比较；以此类推，第n个元素即R[n-1]=k，n次关键字比较c_i=i+1。共有n种查找成功的情况，在等概率时，p_i=1/n，ASL成功=(1+2+...+n)/n=(n+1)/2[11]。
2. 判定树T(low,high)定义为：当low>high时，T(low,high)为空树；当low≤high时，根结点为中间序号mid=(low+high)/2的元素，其左子树是R[low..mid-1]对应的判定树T(low,mid-1)，其右子树是R[mid+1,high]对应的判定树T(mid+1,high)。内部结点中的数字表示该元素在有序表中的下标，外部结点中的两个值表示查找不成功时关键字对应的元素序号范围[22]。
3. 将n=25个记录分为b=5块，每块中有s=5个元素。数据特性：数据整体无序，分块后按块有序[1]。查找k=80：首先在索引表中顺序查找块，比较4次找到块；然后在对应块中顺序查找，比较4次找到80，共比较8次[1]。
4. BSearch1算法错误：对于查找区间[low,high]，mid=(low+high)/2，若k>R[mid]执行low=mid，新查找区间为[mid,high]，若mid与查找区间的low相同（如low=high时），则新查找区间没有变化，从而陷入死循环[12]。BSearch2算法正确：将while语句改为循环到仅包含一个元素R[low]为止，再判断该元素的关键字是否为k[2]。

四、算法分析题：
1. 时间复杂度：O(log₂n)，每次将查找区间减半。空间复杂度：O(1)，只使用固定数量的变量[4]。
2. 当采用折半查找确定块时，ASL_blk = ASL_bn + ASL_sq ≈ log₂(b+1)-1 + (s+1)/2。其中ASL_bn是折半查找索引表的平均查找长度，ASL_sq是顺序查找块内元素的平均查找长度。当s越小时，ASL_sq越小，因此ASL_blk越小。所以采用折半查找确定块时，每块的长度越小越好[7]。

五、程序设计题：
主要思路：使用折半查找找到k的插入点，即第一个大于等于k的元素序号。然后比较插入点前后的元素，找到与k最接近的元素。
1. 时间复杂度：O(log₂n)
2. 空间复杂度：O(1)
3. 处理重复关键字：如果有多个相同的关键字，返回较大的那一个，即插入点位置的关键字[4]。