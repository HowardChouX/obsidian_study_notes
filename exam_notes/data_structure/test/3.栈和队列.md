# 第3章 栈和队列重要知识点测试题目

## 一、选择题（每题5分）

1. **栈的基本概念题**
   栈（stack）是一种只能在**同**一端进行插入或删除操作的线性表[7]。表中允许进行插入、删除操作的一端称为**栈顶**（top），表的另一端称为**栈底**（bottom）[7]。栈的插入操作通常称为**进栈**或**入栈**（push），栈的删除操作通常称为**退栈**或**出栈**（pop）[7]。以下哪项描述是正确的？
   A. 栈是先进先出的数据结构
   B. 每次进栈的元素都作为新栈底元素
   C. 栈也称为**后进先出表**或者**先进后出表**[7]
   D. 栈顶元素总是最先被访问的元素

2. **栈的出栈序列题**
   一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）[5]。
   A. edcba
   B. decba
   C. dceab
   D. abcde
 
   方法1：用栈模拟进行判断[5]。方法2：利用判断准则，判断准则：输入序列为1，2，…，n，（p₁，p₂，…，pₙ）是1，2，…，n的一种排列，利用一个栈得到输出序列（p₁，p₂，…，pₙ）的充分必要条件是不存在这样的i、j、k满足i<jk的同时也满足p_j<p_k<p_i[5]。

3. **顺序栈操作题**
   若一个栈用数组data[1..n]存储，初始栈顶指针top为1，则以下元素x进栈的正确操作是（ ）[6]。
   A. top++; data[top]=x;
   B. data[top]=x; top++;
   C. top--; data[top]=x;
   D. data[top]=x; top--;
 
   答：初始栈顶指针top为1，说明data[1]端作为栈底，在进栈时top应递增，由于存在data[1]的元素，所以在进栈时应先将x放在top处，再top递增（top指向栈顶元素的前一个位置！）[6]。答案为B。

4. **队列的基本概念题**
   队列（queue）是一种只能在**不同**端进行插入或删除操作的线性表[18]。进行插入的一端称做**队尾**（rear），进行删除的一端称做**队头**或**队首**（front）[18]。队列的插入操作通常称为**进队**或**入队**（push），队列的删除操作通常称为**出队**或**离队**（pop）[18]。以下哪项描述是正确的？
   A. 队列是后进先出的数据结构
   B. 每次进队的元素作为新队头元素
   C. 队列也称为**先进先出表**[18]
   D. 队尾元素总是最先被访问的元素

## 二、填空题（每题5分）

1. 栈抽象数据类型的基本运算包括：empty()判断栈是否为空，若空栈返回真；否则返回假。push(e)进栈操作，将元素e插入到栈中作为栈顶元素。pop()出栈操作，返回栈顶元素。gettop()取栈顶操作，返回当前的栈顶元素[5]。

2. 栈的主要特点是：**后进先出**，即后进栈的元素先出栈[7]。每次进栈的元素都作为新栈顶元素，每次出栈的元素只能是当前栈顶元素[7]。

3. 队列抽象数据类型的基本运算包括：empty()判断队列是否为空，若队列为空，返回真，否则返回假。push(e)进队，将元素e进队作为队尾元素。pop()出队，从队头出队一个元素。gethead()取队头，返回队头元素而不出队[9]。

4. 在循环队列中，队空条件是：**rear==front**[11]。队满条件是：**(rear+1)%MaxSize==front**（相当于试探进队一次，若rear达到front，则认为队满了）[11]。

## 三、简答题（每题10分）

1. **栈与队列的区别**
   简述栈和队列的主要区别，并举例说明它们在实际应用中的不同场景[7][18]。

2. **括号匹配算法**
   描述利用顺序栈检查用户输入的表达式中括号是否配对的算法基本思路[6]。假设表达式中可能含有圆括号、中括号和大括号。

3. **循环队列的设计**
   为什么循环队列中最多只能存放MaxSize-1个元素？如何设计循环队列的队空和队满条件[11]？

4. **表达式求值**
   描述中缀表达式转换为后缀表达式的基本思路，以及后缀表达式求值的过程[1]。例如表达式"(56-20)/(4+2)"的转换和求值过程。

## 四、算法分析题（每题15分）

1. **栈的出栈序列判断算法**
   分析以下判断出栈序列算法的思路：
   ```python
   from LinkStack import LinkStack
 
   def isSerial(a,b,n):  # 判断b是否为a的出栈序列算法
       st=LinkStack()    # 建立一个链栈
       i,j=0,0
       while i<n:        # 遍历a序列
           st.push(a[i])
           i+=1          # i后移
           while not st.empty() and st.gettop()==b[j]:
               st.pop()  # 出栈
               j+=1      # j后移
       return st.empty() # 栈空返回True否则返回False
   ```
   分析该算法的时间复杂度和空间复杂度[1]。

2. **迷宫求解算法比较**
   比较使用栈和使用队列求解迷宫问题的不同：
   - 使用栈求解迷宫问题的搜索过程：每次走到一个方块(i,j)，一次性试探所有相邻方块，将所有相邻可走方块进栈[23]。
   - 使用队列求解迷宫问题的搜索过程：每次走到一个方块(i,j)，一次性试探所有相邻方块，将所有相邻可走方块进队[4]。
 
   分析两种方法找到的路径特点，以及为什么使用栈找到的路径不一定是最短路径[1]？

## 五、程序设计题（20分）

**最小栈的设计**
设计最小栈。定义栈的数据结构，添加一个Getmin()方法用于返回栈中的最小元素。要求方法Getmin()、push以及pop的时间复杂度都是O(1)[14]。

例如：
- push(5); 栈元素：(5) 最小元素：5
- push(6); 栈元素：(6，5) 最小元素：5
- push(3); 栈元素：(3，6，5) 最小元素：3
- push(7); 栈元素：(7，3，6，5) 最小元素：3
- pop(); 栈元素：(3，6，5) 最小元素：3
- pop(); 栈元素：(6，5) 最小元素：5

请写出该栈类的Python实现，并分析：
1. 算法的时间复杂度
2. 算法的空间复杂度
3. 如果要求支持重复最小元素，算法应如何修改？

**提示**：参考最小栈的设计思路，使用两个栈：data栈和mindata栈[14][36]。

---

**参考答案要点：**

一、选择题：
1. C 2. C 3. B 4. C

二、填空题：
1. empty()、push(e)、pop()、gettop()
2. 后进先出
3. empty()、push(e)、pop()、gethead()
4. rear==front、(rear+1)%MaxSize==front

三、简答题：
1. 栈是后进先出(LIFO)，队列是先进先出(FIFO)。栈应用：函数调用、表达式求值、括号匹配；队列应用：消息队列、任务调度、广度优先搜索[7][18]。
2. 遍历表达式，遇到左括号进栈，遇到右括号时检查栈顶是否匹配，最后检查栈是否为空[6]。
3. 为了区分队空和队满状态，需要牺牲一个存储单元。队空：rear==front；队满：(rear+1)%MaxSize==front[11]。
4. 中缀转后缀：使用运算符栈，根据优先级处理；后缀求值：使用运算数栈，遇到运算符时出栈两个操作数计算[1]。

四、算法分析题：
1. 时间复杂度：O(n)，每个元素进栈一次，出栈一次。空间复杂度：O(n)，最坏情况下栈中可能存放所有元素[1]。
2. 栈求解：深度优先搜索，找到的路径不一定最短；队列求解：广度优先搜索，找到的路径是最短路径。使用栈可能找到绕远路的解，而队列按层次扩展，最先找到出口的路径最短[1][4]。

五、程序设计题：
主要思路：使用两个栈，data栈存放所有元素，mindata栈存放当前最小元素。push时如果x≤当前最小则同时进mindata栈；pop时如果出栈元素等于当前最小则mindata栈也出栈[14][36]。
1. 时间复杂度：所有操作O(1)
2. 空间复杂度：O(n)，最坏情况下两个栈都存放n个元素
3. 支持重复最小元素：mindata栈中存放最小元素及其出现次数，或允许重复元素进mindata栈。