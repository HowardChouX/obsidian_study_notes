# 第10章 内部排序

## 10.1 概述

**1. 排序的基本概念**
所谓**排序**，就是要整理表中的元素，使之按关键字递增或递减有序排列，本章仅讨论递增排序的情况[8]。排序的输入输出如下：
- **输入**：n个元素序列为R₀、R₁、…、Rₙ₋₁，其相应的关键字分别为k₀、k₁、…、kₙ₋₁
- **输出**：Rᵢ₀，Rᵢ₁，…，Rᵢₙ₋₁，使得kᵢ₀ ≤ kᵢ₁ ≤…≤ kᵢₙ₋₁[8]

**2. 内排序和外排序**
在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为**内排序**[8]。反之，若排序过程中要进行数据的内、外存交换，则称之为**外排序**[8]。

**3. 内排序的分类**[8]：
- **基于比较的排序**：插入排序、交换排序、选择排序、归并排序
- **不基于比较的排序**：基数排序

**4. 排序的稳定性**
当待排序元素的关键字均不相同时，排序的结果是唯一的，否则排序的结果不一定唯一[10]。如果待排序的表中，存在有多个关键字相同的元素，经过排序后这些具有相同关键字的元素之间的相对次序保持不变，则称这种排序方法是**稳定的**；反之，若具有相同关键字的元素之间的相对次序发生变化，则称这种排序方法是**不稳定的**[10]。

**5. 基于比较的排序算法的性能**
基于比较的排序算法中，主要进行以下两种基本操作[8]：
- **比较**：元素关键字之间的比较
- **移动**：元素从一个位置移动到另一个位置

排序算法的性能由算法的时间和空间确定，而时间又是由比较和移动的次数确定的[8]。

**6. 排序数据的组织**
以顺序表作为排序表的存储结构（除基数排序采用单链表外）。假设关键字为int类型，待排序的顺序表直接采用Python列表R[0..n-1]表示[1][17]。如10个整数关键字序列表示为：R=[1,6,2,5,3,7,4,8,2,4]（存在相同的关键字）[4]。

若待排序表中每个元素除整数关键字外还有其他数据项，可以采用嵌套列表表示[4]。如3个学生元素，每个元素由学号和姓名组成，R表示为：R=[[1,"Mary"],[3,"John"],[2,"Smith"]][4]。

## 10.2 插入排序

### 10.2.1 直接插入排序

**1. 排序思路**
- 初始时，有序区只有一个元素R[0]
- i=1~n-1，共经过n-1趟排序[4]
- 一趟直接插入排序：在有序区中插入R[i]的过程[4]

**有序区与无序区**[4]：
```
有序区 R[0] …… R[i-1]  无序区 R[i] …… R[n-1]
```

**2. 排序算法**[10]：
```python
def InsertSort(R):  # 对R[0..n-1]按递增有序进行直接插入排序
    for i in range(1, len(R)):  # 从元素R[1]开始
        if R[i] R[i-1]:  # 反序时
            tmp = R[i]  # 取出无序区的第一个元素
            j = i-1  # 有序区R[0..i-1]中向前找R[i]的插入位置
            while True:
                R[j+1] = R[j]  # 将大于tmp的元素后移
                j -= 1  # 继续向前比较
                if j0 or R[j] <= tmp:  # 若j0或者R[j]<=tmp，退出循环
                    break
            R[j+1] = tmp  # 在j+1处插入tmp
```

**3. 算法分析**
- **最好情况**：初始数据序列正序，时间复杂度为O(n)[3]
- **最坏情况**：初始数据序列反序，时间复杂度为O(n²)[3]
- **平均情况**：时间复杂度为O(n²)[3]

**4. 示例**[4]：
设待排序表有10个元素，其关键字序列为(9,8,7,6,5,4,3,2,1,0)。采用直接插入排序的过程：
```
初始: [9] 8 7 6 5 4 3 2 1 0
i=1:  [8 9] 7 6 5 4 3 2 1 0
i=2:  [7 8 9] 6 5 4 3 2 1 0
...
i=9:  [0 1 2 3 4 5 6 7 8 9]
```

### 10.2.2 其他插入排序

**1. 折半插入排序**
折半插入排序采用折半查找方法在有序区找到插入的位置[3]。

**排序思路**[19]：
有序区R[0]……R[i-1] 无序区R[i]……R[n-1]，采用折半查找在有序区找到插入的位置。

**排序算法**[19]：
```python
def BinInsertSort(R):  # 对R[0..n-1]按递增有序进行折半插入排序
    for i in range(1, len(R)):
        if R[i] R[i-1]:  # 反序时
            tmp = R[i]  # 将R[i]保存到tmp中
            low, high = 0, i-1
            while low <= high:  # R[low..high]折半查找插入位置high+1
                mid = (low+high)//2  # 取中间位置
                if tmp R[mid]:
                    high = mid-1  # 插入点在左区间
                else:
                    low = mid+1  # 插入点在右区间
            for j in range(i-1, high, -1):  # 元素集中后移
                R[j+1] = R[j]
            R[high+1] = tmp  # 插入原来的R[i]
```

**2. 算法分析**
在任何情况下排序中元素移动的次数与直接插入排序的相同，不同的仅是变分散移动为集中移动[19]。平均情况的时间复杂度为O(n²)[19]。

### 10.2.3 希尔排序

**1. 排序思路**
希尔排序是一种改进的插入排序算法[3]。将排序序列分为d个组，在各组内进行直接插入排序[3]。

**分组方法**[3]：
将n个元素分成d个组：
- {R[0]，R[d]，R[2d]，…，R[kd]}
- {R[1]，R[1+d]，R[1+2d]，…，R[1+kd]}
- ...
- {R[d-1]，R[2d-1]，R[3d-1]，…，R[(k+1)d-1]}

**排序过程**[3]：
1. d=n/2，将排序序列分为d个组，在各组内进行直接插入排序
2. 递减d=d/2，重复步骤1，直到d=0为止

**2. 排序算法**[6]：
```python
def ShellSort(R):  # 对R[0..n-1]按递增有序进行希尔排序
    d = len(R)//2  # 增量置初值
    while d > 0:
        for i in range(d, len(R)):  # 对所有相隔d位置的元素组采用直接插入排序
            if R[i] R[i-d]:  # 反序时
                tmp = R[i]
                j = i-d
                while True:
                    R[j+d] = R[j]  # 将大于tmp的元素后移
                    j = j-d  # 继续向前找
                    if j0 or R[j] <= tmp:  # 若j0或者R[j]<=tmp，退出循环
                        break
                R[j+d] = tmp  # 在j+d处插入tmp
        d = d//2  # 递减增量
```

**3. 算法分析**
希尔算法的时间复杂度难以分析，一般认为其平均时间复杂度为O(n¹·⁵⁸)[6]。希尔排序的速度通常要比直接插入排序快[6]。

**4. 示例**[6]：
设待排序的表有10个元素，其关键字分别为(9,8,7,6,5,4,3,2,1,0)。希尔排序过程：
```
初始序列: 9 8 7 6 5 4 3 2 1 0
d=5:     4 3 2 1 0 9 8 7 6 5
d=2:     2 1 0 3 4 7 6 5 9 8
d=1:     0 1 2 3 4 5 6 7 8 9
```

**5. 稳定性**
希尔排序是一种不稳定的排序算法[3]。例如，相距位置较大的两个元素发生交换可能导致相对位置发生改变[3]。

## 10.3 快速排序

**1. 排序思路**
快速排序是一种分治算法，基本思路是[28]：
- 无序的记录序列 → 无序子序列① + 基准 + 无序子序列②
- 每趟使表的第1个元素放入适当位置（归位），将表一分为二
- 对子表按递归方式继续这种划分，直至划分的子表长为0或1（递归出口）

**2. 划分算法**
**划分算法1**[1]：
```python
def Partition1(R, s, t):  # 划分算法1
    base = R[s]  # 以表首元素为基准
    i, j = s, t
    while i j:  # 从表两端交替向中间遍历，直至i=j为止
        while i j and R[j] >= base:  # 从后向前遍历，找一个小于基准的R[j]
            j -= 1
        while i j and R[i] <= base:  # 从前向后遍历，找一个大于基准的R[i]
            i += 1
        if i j:
            R[i], R[j] = R[j], R[i]  # 将R[i]和R[j]进行交换
    R[s], R[i] = R[i], R[s]  # 将基准R[s]和R[i]进行交换
    return i
```

**划分算法2**[19]：
```python
def Partition2(R, s, t):  # 划分算法2
    i, j = s, t
    base = R[s]  # 以表首元素为基准
    while i != j:  # 从表两端交替向中间遍历，直至i=j为止
        while j > i and R[j] >= base:  # 从后向前遍历，找一个小于基准的R[j]
            j -= 1
        if j > i:
            R[i] = R[j]  # R[j]前移覆盖R[i]
            i += 1
        while i j and R[i] <= base:  # 从前向后遍历，找一个大于基准的R[i]
            i += 1
        if i j:
            R[j] = R[i]  # R[i]后移覆盖R[j]
            j -= 1
    R[i] = base  # 基准归位
    return i  # 返回归位的位置
```

**3. 快速排序算法**[14]：
```python
def QuickSort(R):  # 对R[0..n-1]的元素按递增进行快速排序
    QuickSort1(R, 0, len(R)-1)

def QuickSort1(R, s, t):  # 对R[s..t]的元素进行快速排序
    if s t:  # 表中至少存在两个元素的情况
        i = Partition3(R, s, t)  # 可以使用前面3种划分算法中的任意一种
        QuickSort1(R, s, i-1)  # 对左子表递归排序
        QuickSort1(R, i+1, t)  # 对右子表递归排序
```

**4. 算法分析**
- **最好情况**：如果初始数据序列随机分布，使得每次划分恰好分为两个长度相同的子表，此时递归树的高度最小，性能最好，时间复杂度为O(nlog₂n)[20]
- **最坏情况**：如果初始数据序列正序或者反序，使得每次划分的两个子表中一个为空一个长度为n-1，此时递归树的高度最高，性能最差，时间复杂度为O(n²)[20]
- **平均情况**：时间复杂度为O(nlog₂n)[20]

**5. 示例**[20]：
设待排序的表有10个元素，其关键字分别为(6,8,7,9,0,1,3,2,4,5)。快速排序过程：
```
快速排序过程 → 递归树
6 8 7 9 0 1 3 2 4 5
```

## 10.4 选择排序

### 10.4.1 简单选择排序

**1. 排序思路**[9]：
- 全局有序区为空
- i=0~n-2，共n-1趟使整个数据有序
- 采用简单选择方法选出最小元素

**有序区与无序区**[23]：
```
全局有序区 R[0] …… R[i-1]  无序区 R[i] …… R[n-1]
```

**2. 排序算法**[23]：
```python
def SelectSort(R):  # 对R[0..n-1]元素进行简单选择排序
    for i in range(len(R)-1):  # 做第i趟排序
        minj = i  # minj先置为区间中的首元素序号
        for j in range(i+1, len(R)):  # 从R[i..n-1]中选最小元素R[minj]
            if R[j] R[minj]:  # 与区间中其他元素比较
                minj = j
        if minj != i:  # R[minj]不是无序区首元素
            R[i], R[minj] = R[minj], R[i]  # 交换R[i]和R[minj]
```

**3. 算法分析**
无论初始数据序列的状态如何，在第i趟排序中选出最小元素，内for循环需做n-1-(i+1)+1=n-i-1次比较[23]。因此，总的比较次数为：
$$\sum_{i=0}^{n-2}(n-i-1)=\frac{n(n-1)}{2}$$

最好、最坏和平均情况的时间复杂度均为O(n²)[23]。

**4. 稳定性**
简单选择排序是一种不稳定的排序方法[24]。例如，(5,5,1)无序区交换后变为(1,5,5)，相对位置发生改变[24]。

### 10.4.2 树形选择排序
树形选择排序（锦标赛排序）是通过构建一棵完全二叉树来进行选择排序的方法。每次比较后，胜者（较小者）上升到父结点，最终根结点为最小元素。

### 10.4.3 堆排序

**1. 排序思路**[9]：
- 全局有序区为空，无序区为整个序列
- 采用堆方法选出最小元素
- 选出最小元素R[k]

**堆的定义**[9]：
一个序列R[0..n-1]，关键字分别为k₀、k₁、…、kₙ₋₁。该序列满足如下性质（简称为堆性质）：
1. kᵢ ≤ k₂ᵢ₊₁且kᵢ ≤ k₂ᵢ₊₂ 或
2. kᵢ ≥ k₂ᵢ₊₁且kᵢ ≥ k₂ᵢ₊₂（0 ≤ i ≤ ⌊n/2⌋-1）

满足第1种情况的堆称为**小根堆**，满足第2种情况的堆称为**大根堆**[9]。

**2. 堆排序算法**[25]：
```python
def HeapSort(R):  # 对R[0..n-1]按递增进行堆排序
    n = len(R)
    for i in range(n//2-1, -1, -1):  # 从最后一个分支结点开始建立初始堆
        siftDown(R, i, n-1)  # 对R[i..n-1]进行筛选
    for i in range(n-1, 0, -1):  # 进行n-1趟排序
        R[0], R[i] = R[i], R[0]  # 将无序区尾元素↔R[0]，有序区为R[i..n-1]
        siftDown(R, 0, i-1)  # 对无序区R[0..i-1]继续筛选
```

**向下筛选算法**[13]：
```python
def siftDown(R, low, high):  # R[low..high]的自顶向下筛选
    i = low
    j = 2*i+1  # R[j]是R[i]的左孩子
    tmp = R[i]  # tmp临时保存根结点
    while j <= high:  # 只对R[low..high]的元素进行筛选
        if j high and R[j] R[j+1]:
            j += 1  # 若右孩子较大，把j指向右孩子
        if tmp R[j]:  # tmp的孩子较大
            R[i] = R[j]  # 将R[j]调整到双亲位置上
            i, j = j, 2*i+1  # 修改i和j值，以便继续向下筛选
        else:
            break  # 若孩子较小，则筛选结束
    R[i] = tmp  # 原根结点放入最终位置
```

**3. 算法分析**
堆排序的时间复杂度为O(nlog₂n)，空间复杂度为O(1)，不稳定[16]。

**4. 示例**[25]：
设待排序的表有10个记录，其关键字分别为{6,8,7,9,0,1,3,2,4,5}。堆排序过程：
```
排序序列：6,8,7,9,0,1,3,2,4,5
调整成初始大根堆：9,8,7,6,5,1,3,2,4,0
第1趟排序：输出9（归位）
第2趟排序：输出8（归位）
...
最终结果：0,1,2,3,4,5,6,7,8,9
```

## 10.5 归并排序

**1. 基本思路**[26]：
归并排序是将两个或多个有序表合并成一个有序表的过程。主要的归并排序方法是二路归并排序。

**2. 自底向上的二路归并排序**
**排序思路**[26]：
将排序表看作n个长度为1的有序子表，然后两两归并，得到⌈n/2⌉个长度为2的有序子表，再两两归并，如此重复，直到得到一个长度为n的有序表为止。

**一趟二路归并排序算法**[26]：
```python
def MergePass(R, length):  # 一趟二路归并排序
    n = len(R)
    i = 0
    while i+2*length-1 n:  # 归并length长的两相邻子表
        Merge(R, i, i+length-1, i+2*length-1)
        i = i+2*length
    if i+length n:  # 余下两个子表，后者长度小于length
        Merge(R, i, i+length-1, n-1)  # 归并这两个子表
```

**二路归并排序算法**[26]：
```python
def MergeSort1(R):  # 对R[0..n-1]按递增进行二路归并算法
    length = 1
    while length len(R):  # 进行⌈log₂n⌉趟归并
        MergePass(R, length)
        length = 2*length
```

**3. 自顶向下的二路归并排序**
**排序思路**[26]：
排序区间是R[s..t]（为大问题），当其长度为0或者1时，本身就是有序的，不做任何处理。否则，取其中间位置m，采用相同方法对R[s..m]和R[m+1..t]排好序（分解为两个小问题），再调用二路归并算法Merge(s,m,t)得到整个有序表（合并）。

**递归二路归并排序算法**[11]：
```python
def MergeSort2(R):  # 对R[0..n-1]按递增进行二路归并算法
    MergeSort21(R, 0, len(R)-1)

def MergeSort21(R, s, t):  # 被MergeSort2调用
    if s >= t:  # R[s..t]的长度为0或者1时返回
        return
    m = (s+t)//2  # 取中间位置m
    MergeSort21(R, s, m)  # 对前子表排序
    MergeSort21(R, m+1, t)  # 对后子表排序
    Merge(R, s, m, t)
```

**4. 二路归并算法**[26]：
```python
def Merge(R, low, mid, high):  # R[low..mid..high]归并为R[low..high]
    R1 = [None]*(high-low+1)  # 分配临时归并空间R1
    i, j, k = low, mid+1, 0  # k是R1的下标，i、j分别为第1、2段的下标
    while i <= mid and j <= high:  # 在第1段和第2段均未扫描完时循环
        if R[i] <= R[j]:  # 将第1段中的元素放入R1中
            R1[k] = R[i]
            i, k = i+1, k+1
        else:  # 将第2段中的元素放入R1中
            R1[k] = R[j]
            j, k = j+1, k+1
    while i <= mid:  # 将第1段余下部分复制到R1
        R1[k] = R[i]
        i, k = i+1, k+1
    while j <= high:  # 将第2段余下部分复制到R1
        R1[k] = R[j]
        j, k = j+1, k+1
    R[low:high+1] = R1[0:high-low+1]  # 将R1复制回R中
```

**5. 算法分析**
二路归并排序中，长度为n的排序表需做⌈log₂n⌉趟，对应的归并树高度为⌈log₂n⌉，每趟归并时间为O(n)[32]。时间复杂度的最好、最坏和平均情况都是O(nlog₂n)[32]。空间复杂度为O(n)[32]。

**6. 示例**[2]：
设排序序列有5个元素，其关键字分别为(3,5,1,2,4)。自顶向下二路归并排序过程：
```
(1) 分解 3 5 1 2 4
(2) 分解 3 5 1 | 2 4
(3) 分解 3 | 5 1 | 2 | 4
(4) 合并 3 | 1 5 | 2 | 4
(5) 合并 1 3 5 | 2 4
(6) 合并 1 2 3 4 5
```

## 10.6 基数排序

### 10.6.1 多关键字的排序

**1. 排序思路**[2]：
基数排序是一种借助于**多关键字排序**的思想对单关键字排序的方法。所谓多关键字是指讨论元素中含有多个关键字，假设多个关键字分别为k₁、k₂、…、k_d，称k₁是第一关键字，k_d是第d个关键字[2]。

基数排序就是利用多关键字排序思路，只不过将元素中的单个关键字分为多个位，每个位看成一个关键字[2]。

**2. 基数排序的基本概念**
假设元素关键字均为十进制（r=10）正整数，最大位数为d[7]。一般地，在基数排序中元素R[i]的关键字R[i].key是由d位数字组成，即k_{d-1}k_{d-2}…k₀，每一个数字表示关键字的一位，其中k_{d-1}为最高位，k₀是最低位，每一位的值都在0≤k_ir范围内，其中，r称为基数[2]。

假设k_{d-1}是最重要位，k₀是最不重要位，应该从最低位开始排序，称为**最低位优先（LSD）**。反之，若k_{d-1}是最不重要位，k₀是最重要位，应该从最高位开始排序，称为**最高位优先（MSD）**[2]。

### 10.6.2 链式基数排序

**1. 排序思路**[7]：
最低位优先排序假设线性表由元素序列a₁、a₂、…、a_n构成，每个结点a_j的关键字由d元组组成，其中每个元素值在0到r-1之间。在排序过程中使用r个队列Q₀，Q₁，…，Q_{r-1}[7]。

对i=0、1、…，d-1（从低位到高位），依次做一次"分配"和"收集"[7]：
- **分配**：开始时，把Q₀、Q₁、…、Q_{r-1}各个队列置成空队列，然后依次考察线性表中的每一个元素a_j（j=1、2、…、n），如果a_j的关键字位=k，就把a_j插入到Q_k队列中
- **收集**：将Q₀、Q₁、…、Q_{r-1}各个队列中的元素依次首尾相接，得到新的元素序列，从而组成新的线性表

**2. 排序算法**[12]：
```python
def RadixSort(L, d, r):  # 最低位优先基数排序算法
    front = [None]*r  # 建立链队队头数组
    rear = [None]*r  # 建立链队队尾数组
    for i in range(d):  # 从低位到高位循环
        for j in range(r):  # 初始化各链队首、尾指针
            front[j] = rear[j] = None
        p = L.head.next  # p指向单链表L的首结点
        while p != None:  # 分配：对于原链表中每个结点循环
            k = geti(p.data, r, i)  # 提取结点关键字的第i个位k
            if front[k] == None:  # 第k个链队空时，队头队尾均指向p结点
                front[k] = rear[k] = p
            else:  # 第k个链队非空时，p结点进队
                rear[k].next = p
                rear[k] = p
            p = p.next  # 取下一个结点
        t = L.head  # 重新收集所有结点
        for j in range(r):  # 收集：对于每一个链队循环
            if front[j] != None:  # 若第j个链队是第一个非空链队
                t.next = front[j]
                t = rear[j]
        t.next = None  # 尾结点的next置空
    return L
```

**3. 算法分析**
基数排序的时间复杂度为O(d(n+r))，其中分配为O(n)，收集为O(r)（r为"基数"），d为"分配-收集"的趟数[5]。基数排序的空间复杂度为O(r)[5]。

**4. 示例**[5]：
例如(369,367,167,239,237,138,230,139)→基数排序：
```
第1趟排序（按个位）：
分配：f[0]←r[0], f[7]←r[7], f[8]←r[8], f[9]←r[9]
收集：→230→367→167→237→138→369→239→139

第2趟排序（按十位）：
分配：f[3]←r[3], f[6]←r[6]
收集：→230→237→138→139→239→367→167→369

第3趟排序（按百位）：
分配：f[1]←r[1], f[2]←r[2], f[3]←r[3]
收集：→138→139→167→230→237→239→367→369
```

## 10.7 各种内部排序方法的比较讨论

**各种内排序方法的比较**[5]：

| 排序方法 | 平均情况时间复杂度 | 最坏情况时间复杂度 | 最好情况时间复杂度 | 空间复杂度 | 稳定性 |
|---------|------------------|------------------|------------------|-----------|--------|
| 直接插入排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 折半插入排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 希尔排序 | O(n¹·⁵) | O(n²) | O(n¹·³) | O(1) | 不稳定 |
| 冒泡排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 快速排序 | O(nlog₂n) | O(n²) | O(nlog₂n) | O(log₂n) | 不稳定 |
| 简单选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 堆排序 | O(nlog₂n) | O(nlog₂n) | O(nlog₂n) | O(1) | 不稳定 |
| 二路归并排序 | O(nlog₂n) | O(nlog₂n) | O(nlog₂n) | O(n) | 稳定 |
| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(r) | 稳定 |

**选择排序方法的考虑因素**：
1. **待排序的元素个数n**：n较小时可采用简单排序方法，n较大时采用改进的排序方法
2. **元素本身信息量的大小**：元素本身信息量较大时，为避免耗费大量时间移动元素，可用链表作为存储结构
3. **关键字的结构及其分布情况**
4. **对排序稳定性的要求**
5. **语言工具的条件**：存储结构及所能采用的操作
6. **时间复杂度和空间复杂度的要求**

**不同场景下的排序方法选择**：
1. **若n较小**：可采用直接插入排序或简单选择排序
2. **若文件初始状态基本有序**：应选用直接插入排序、冒泡排序或随机的快速排序
3. **若n较大**：应采用时间复杂度为O(nlog₂n)的排序方法：快速排序、堆排序或归并排序
4. **若n很大，记录的关键字位数较少且可分解**：采用基数排序
5. **当记录本身信息量较大时**：为避免耗费大量时间移动记录，可用链表作为存储结构

**稳定性总结**：
- **稳定的排序方法**：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序
- **不稳定的排序方法**：希尔排序、快速排序、简单选择排序、堆排序

**空间复杂度总结**：
- **O(1)**：直接插入排序、折半插入排序、希尔排序、冒泡排序、简单选择排序、堆排序
- **O(log₂n)**：快速排序
- **O(n)**：归并排序
- **O(r)**：基数排序