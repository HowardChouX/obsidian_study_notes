# 第9章 查找

## 9.1 静态查找表

### 9.1.1 顺序表的查找

**1. 顺序查找算法**[9]
基本思路：从顺序表的一端开始依次遍历，将遍历的元素关键字和给定值k相比较，若两者相等，则查找成功，返回该元素的序号[9]。若遍历结束后，仍未找到关键字等于k的元素，则查找失败，返回-1[9]。

**算法实现**[9]：
```python
def SeqSearch1(R,k):  # 顺序查找算法1
    n=len(R)
    i=0
    while i<n and R[i]!=k:  # 从表头往后找
        i+=1
    if i>=n:
        return -1  # 未找到返回-1
    else:
        return i   # 找到后返回其序号i
```

**2. 顺序查找算法分析**[11]
- **查找成功情况**：第i个元素需要i+1次关键字比较，在等概率时，ASL成功 = (n+1)/2
- **查找不成功情况**：总是需要n次比较才能确定查找失败，ASL不成功 = n[11]
- **时间复杂度**：O(n)[18]

**3. 顺序查找的特点**[18]
- **优点**：算法简单，对查找表的存储结构无特殊要求，无论用顺序表还是链表，无论元素是否有序都适用
- **缺点**：查找效率低，当n较大时不宜采用顺序查找

### 9.1.2 有序表的查找

**1. 折半查找算法**[20]
基本思路：设R[low..high]是当前的非空查找区间，首先确定该区间的中点位置mid=⌊(low+high)/2⌋，然后将待查的k值与R[mid]比较[20]：
1. 若k = R[mid]，则查找成功并返回该元素的序号mid
2. 若k R[mid]，则在左子表R[low..mid-1]中查找
3. 若k > R[mid]，则在右子表R[mid+1..high]中查找

**算法实现**[22]：
```python
def BinSearch1(R,k):  # 折半查找非递归算法
    n=len(R)
    low,high=0,n-1
    while low<=high:  # 当前区间非空时
        mid=(low+high)//2  # 求查找区间的中间位置
        if k==R[mid]:      # 查找成功返回其序号mid
            return mid
        if k<R[mid]:       # 继续在R[low..mid-1]中查找
            high=mid-1
        else:              # k>R[mid]
            low=mid+1      # 继续在R[mid+1..high]中查找
    return -1              # 当前查找区间空时返回-1
```

**2. 折半查找判定树**[27]
具有n个元素的有序表可用一棵判定树来表示。当n=2^h-1时，判定树是高度为h=log₂(n+1)的满二叉树[28]。

**3. 折半查找性能分析**[28]
- **查找成功情况**：ASL成功 ≈ log₂(n+1)-1
- **查找不成功情况**：ASL不成功 ≈ log₂(n+1)
- **时间复杂度**：O(log₂n)

**4. 折半查找的扩展算法**[15]
- **查找插入点**：在有序表R中查找插入点，插入点就是第一个大于等于k的元素序号[15]
- **查找最接近元素**：返回R中与k最接近的元素关键字[15]
- **查找元素区间**：查找关键字为k的第一个和最后一个元素序号[15]

### 9.1.3 静态树表的查找

**1. 静态树表的概念**
静态树表是在查找过程中树结构不发生变化，主要用于处理查找概率不相等的情况。

**2. 次优查找树**
当查找表中各记录的查找概率不相等时，折半查找的性能不是最优的。次优查找树是在查找概率不相等时的一种优化方法，它使查找树的带权路径长度最小。

### 9.1.4 索引顺序表的查找

**1. 索引存储结构**[1]
索引存储结构是在采用数据表存储数据的同时，还建立附加的**索引表**[1]。索引表中的每一项称为索引项，索引项的一般形式为（关键字，地址），其中关键字唯一标识一个元素，地址为该关键字元素在数据表中的存储地址，整个索引表按关键字有序排列[1]。

**索引表元素类型定义**[1]：
```python
class IdxType:  # 索引表元素类型
    def __init__(self,j=None,k=None):  # 构造方法
        self.key=k  # 关键字（对应块中的最大关键字）
        self.link=j  # 该索引块在数据表中的起始下标
```

**2. 分块查找**[1]
分块查找又称为索引顺序查找，是顺序查找的一种改进方法。其基本思想是：
1. 将查找表分为若干块，块内元素可以无序，但块间有序
2. 建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中第一个元素的地址

**分块查找算法**[21]：
```python
def BlkSearch(R,I,b,k):  # 在R[0..n-1]+I[0..b-1]中查找k
    n=len(R)
    low,high=0,b-1
    while low<=high:  # 索引表中折半查找找到块号high+1
        mid=(low+high)//2
        if k<=I[mid].key:
            high=mid-1
        else:
            low=mid+1
    if high+1>=b:
        return -1  # 块号超界，查找失败
    i=I[high+1].link  # 求所在块的起始位置
    s=(n+b-1)//b  # 求每块的元素个数s
    if i==b-1:  # 第i块是最后块，元素个数可能少于s
        s=n-s*(b-1)
    while i<=I[high+1].link+s-1 and R[i]!=k:  # 在第i块中顺序查找
        i+=1
    if i<=I[high+1].link+s-1:
        return i  # 查找成功，返回该元素的序号
    else:
        return -1  # 查找失败，返回-1
```

**3. 分块查找性能分析**[18]
- **用顺序查找确定块**：ASL'blk = (b+1)/2 + (s+1)/2，当s=√n时，ASL'blk取极小值√n+1
- **用折半查找确定块**：ASLblk ≈ log₂(b+1) + s/2，当s越小时，ASLblk的值越小

## 9.2 动态查找表

### 9.2.1 二叉排序树和平衡二叉树

**1. 二叉排序树（BST）**[24]
二叉排序树或者是空树，或者是满足如下性质的二叉树：
1. 若它的左子树非空，则左子树上所有结点值均小于根结点值
2. 若它的右子树非空，则右子树上所有结点值均大于根结点值
3. 左、右子树本身又各是一棵二叉排序树

**BST结点类型定义**[24]：
```python
class BSTNode:  # 二叉排序树结点类
    def __init__(self,k,d=None,l=None,r=None):  # 构造方法
        self.key=k  # 存放关键字，假设关键字为int类型
        self.data=d  # 存放其他数据项
        self.lchild=l  # 存放左孩子指针
        self.rchild=r  # 存放右孩子指针
```

**BST查找算法**[20]：
```python
def SearchBST(self,k):  # 在二叉排序树中查找关键字为k的结点
    return self._SearchBST(self.r,k)  # r为二叉排序树的根结点

def _SearchBST(self,p,k):  # 被SearchBST方法调用
    if p==None:
        return None  # 空树返回None
    if p.key==k:
        return p  # 找到后返回p
    if k<p.key:
        return self._SearchBST(p.lchild,k)  # 在左子树中递归查找
    else:
        return self._SearchBST(p.rchild,k)  # 在右子树中递归查找
```

**2. 平衡二叉树（AVL树）**[27]
AVL树是高度平衡的二叉排序树，树中每个结点的左、右子树的高度至多相差1[27]。

**AVL树类定义**[7]：
```python
class AVLTree:  # AVL树类
    def __init__(self):
        self.r=None  # 根结点
  
    def getht(self,p):  # 返回结点p的子树高度
        if p==None:
            return 0  # 空树高度为0
        return p.ht
  
    def right_rotate(self,a):  # 以结点a为根做右旋转
        b=a.lchild
        a.lchild=b.rchild
        b.rchild=a
        a.ht=max(self.getht(a.rchild),self.getht(a.lchild))+1
        b.ht=max(self.getht(b.rchild),self.getht(b.lchild))+1
        return b
```

**AVL树的调整类型**[27]：
1. **LL型调整**：在左孩子的左子树上插入导致不平衡
2. **RR型调整**：在右孩子的右子树上插入导致不平衡
3. **LR型调整**：在左孩子的右子树上插入导致不平衡
4. **RL型调整**：在右孩子的左子树上插入导致不平衡

### 9.2.2 B_树和B+树

**1. B树**[38]
B树是一种外查找的数据组织结构，所有结点的最大子树个数称为B树的阶，通常用m表示[38]。

**m阶B树的定义**[38]：
1. 树中每个内部结点至多有m棵子树（即至多含有m-1个关键字）
2. 若根结点不是叶子结点，则根结点至少有两棵子树
3. 除根结点外，所有内部结点至少有⌈m/2⌉棵子树（即至少含有⌈m/2⌉-1个关键字）

**B树的查找**[10]：
在B树中查找给定关键字的方法类似于二叉排序树上的查找，不同的是在每个结点上确定向下查找的路径不一定是二路的，而是n+1路的（n为该结点的关键字个数）[10]。

**B树的高度分析**[10]：
含有N个关键字的m阶B树可能达到的最大高度h满足：h ≤ log⌈m/2⌉((N+1)/2)+1 = O(logₘN)

**2. B+树**[32]
B+树是B树的一种变形，广泛应用于索引文件组织中[32]。

**m阶B+树与m阶B树的主要差异**[32]：
1. 在B+树中，具有n个关键字的结点对应n棵子树，而在B树中对应n+1棵子树
2. 在B+树中，每个结点（除根结点外）中的关键字个数n的取值范围是⌈m/2⌉ ≤ n ≤ m
3. B+树中的叶子结点层包含全部关键字，而在B树中所有关键字是不重复的
4. B+树中所有非叶子结点仅起到索引的作用，而B树中每个结点的关键字都含对应的记录

### 9.2.3 键树

**1. 键树的概念**
键树又称为数字查找树或Trie树，是一种特殊的查找树，用于处理字符串集合的查找问题。

**2. 键树的特点**
- 键树的每个结点只包含组成关键字的字符，而不是整个关键字
- 从根结点到叶子结点的路径上所有字符连接起来构成一个关键字
- 键树可以有效地支持前缀匹配查找

## 9.3 哈希表

### 9.3.1 什么是哈希表

**1. 哈希表的基本概念**[4]
设要存储的元素个数为n，设置一个长度为m（m≥n）的连续内存单元。以每个元素的关键字kᵢ（0≤i≤n-1）为自变量，通过一个哈希函数h把kᵢ映射为内存单元的地址h(kᵢ)，并把该元素存储在这个内存单元中[4]。

**2. 哈希冲突**[16]
对于两个不同的关键字kᵢ和kⱼ（i≠j）出现h(kᵢ)=h(kⱼ)，这种现象称为**哈希冲突**。将具有不同关键字而具有相同哈希地址的元素称为"同义词"，这种冲突也称为**同义词冲突**[16]。

### 9.3.2 哈希函数的构造方法

**1. 直接定址法**[16]
以关键字k本身或关键字加上某个数值常量c作为哈希地址的方法，即h(k)=k+c。这种哈希函数计算简单，并且不可能有冲突发生[16]。

**2. 除留余数法**[16]
用关键字k除以某个不大于哈希表长度m的数p所得的余数作为哈希地址的方法。除留余数法的哈希函数h(k)为：h(k)=k mod p（mod为求余运算，p≤m），p最好是质数（素数）[16]。

**3. 数字分析法**[6]
提取关键字中取值较均匀的数字位作为哈希地址的方法。适合于所有关键字值都已知的情况，并需要对关键字中每一位的取值分布情况进行分析[6]。

### 9.3.3 处理冲突的方法

**1. 开放定址法**[22]
发生冲突时查找周围一个空位置存放元素。设置一个查找周围一个空位置的函数[22]。

**线性探测法**[14]：
从发生冲突的地址（设为d）开始，依次循环探测d的下一个地址（当到达下标为m-1的哈希表表尾时，下一个探测的地址是表首地址0），直到找到一个空闲单元为止[14]。描述公式为：d₀=h(k)，dᵢ=(dᵢ₋₁+1) mod m（1≤i≤m-1）[14]。

**平方探测法**[6]：
发生冲突时前后查找空位置。描述公式为：d₀=h(k)，dᵢ=(d₀±i²) mod m（1≤i≤m-1）[6]。

**2. 拉链法**[17]
拉链法是把所有的同义词用单链表链接起来的方法。在这种方法中，哈希表每个单元中存放的不再是记录本身，而是相应同义词单链表的头指针[17]。

**拉链法实现**[13]：
```python
class HNode:  # 单链表结点类
    def __init__(self,k,v):  # 构造方法
        self.key=k
        self.v=v
        self.next=None

class HashTable2:  # 哈希表（除留余数法+拉链法）
    def __init__(self,m):  # 构造方法
        self.n=0  # 哈希表中元素个数
        self.m=m  # 桶地址为[0..m-1]
        self.ha=[None]*m  # 分配哈希表的m个桶
```

### 9.3.4 哈希表的查找及其分析

**1. 哈希表查找算法**[4]
```python
def search(self,k):  # 查找关键字k，成功时返回其位置，否则返回-1
    d=k % self.p  # 求哈希函数值
    while self.ha[d]!=NULLKEY and self.ha[d][0]!=k:
        d=(d+1) % self.m  # 线性探测法查找空位置
    if self.ha[d][0]==k:  # 查找成功返回其位置
        return d
    else:  # 查找失败返回-1
        return -1
```

**2. 哈希表性能分析**[5]
**平均情况下的平均查找长度**：n个关键字的构造顺序不同得到的哈希表不同，平均查找长度ASL也不同[5]。

**不同解决冲突方法的ASL比较**[5]：
- **线性探测法**：ASL成功和ASL不成功都较高
- **平方探测法**：可以避免出现堆积问题，但不能探测到哈希表上的所有单元
- **拉链法**：ASL成功和ASL不成功都较低

**3. Python中的哈希表实现**[2]
Python语言中的字典和集合都是采用哈希表实现的，具有非常好的查找性能，可以认为按关键字查找的时间复杂度为O(1)[2]。