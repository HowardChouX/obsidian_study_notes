
# 初始化列表

```c++
[[include]] <iostream>  
[[include]] <string>  
  
class Entity  
{  
private:  
    int m_Score = 0;  
    std::string m_Name;  
public:  
    Entity()  
        : m_Score(1), m_Name("Unknown"){}//C++标准规定成员变量的初始化顺序严格按照类中声明顺序执行,如果调换初始化列表中的顺序（比如先写m_Name），编译器可能会产生警告 

	//初始化列表（高效方式，直接构造）
    Entity(const std::string& name)  
        : m_Name(name) {}  
  
    const std::string& Getname() const {return m_Name;}  
  
};  
  
int main()  
{  
    Entity e0;  
    std==cout << e0.Getname() << std==endl;  
  
  
    Entity e1("LuoXiaoHei");  
    std==cout << e1.Getname() << std==endl;  
  
    std::cin.get();  
}
```

> 初始化列表顺序应与声明顺序一致

## 执行顺序与底层机制

#### 执行优先级（从高到低）：

1. **类内初始化** → 2. **初始化列表** → 3. **构造函数体内赋值**

#### 性能关键案例
```c++
// 低效方式（隐含两次构造）：
class BadExample {
    std::vector<int> data;
public:
    BadExample(int size) {
        data = std::vector<int>(size);  // 1. 默认构造空vector 2. 赋值操作
    }
};

// 高效方式（直接构造）：
class GoodExample {
    std::vector<int> data;
public:
    GoodExample(int size) : data(size) {}  // 直接调用带参构造函数
};
```




```c++

//使用构造函数体内赋值的浪费案例
[[include]] <iostream>  
[[include]] <string>  
class Example  
{  
public:  
    Example()  
    {  
        std==cout << "Created Entity" << std==endl;  
    }  
    Example(int x)  
    {  
        std==cout << "Created Entity with " << x << std==endl;  
    }  
};  
class Entity  
{  
private:  
    std::string m_Name;  
    Example m_Example;  
public:  
    Entity()  
    {  
        m_Name = std::string("Unknown");  //(3)
        m_Example = Example(8);  //(4)
    }  
  
    Entity(const std::string& name)  
        : m_Name(name) {}  
  
    const std::string& Getname() const {return m_Name;}  
  
};  
  
int main()  
{  
    Entity e0;  
  
  
    std::cin.get();  
}
```

```c++
Entity()
{
    m_Name = std::string("Unknown"); // (3)
    m_Example = Example(8);          // (4)
}
```

```c++
//优化后的构造函数
// 优化后的构造函数
Entity() 
    : m_Name("Unknown")  // (1) 直接构造
    , m_Example(8)       // (2) 直接构造
{
}
```
## 类内初始化、初始化列表和构造函数体内赋值区别
| **方式**       | **语法形式**     | **本质**     |
| ------------ | ------------ | ---------- |
| **类内初始化**    | 类声明中直接赋值     | 编译期提供的默认值  |
| **初始化列表**    | 构造函数后的`:`语法  | 真正的初始化操作   |
| **构造函数体内赋值** | 在构造函数`{}`内赋值 | 赋值操作（非初始化） |


```c++
class Widget 
{
private:
    // 类内初始化（C++11+）
    int m_Data = 10;  
    std::string m_Name;
    
public:
    // 初始化列表
    Widget() : m_Name("Default") {}  //真正的初始化
    
    
    // 构造函数体内赋值
    Widget(int val) 
    { 
        m_Data = val;  // 实际是赋值操作
    }
};
```

#### 必须使用场景

1. **const成员**
    
    ```cpp
    class ConstMember {
        const int ID;
    public:
        ConstMember(int id) : ID(id) {}  // 必须初始化列表
    };
    ```
    
2. **引用成员**
    
    ```cpp
    class RefHolder {
        int& ref;
    public:
        RefHolder(int& src) : ref(src) {}  // 必须初始化列表
    };
    ```
    
3. **无默认构造的类成员**
    
    ```cpp
    class NoDefault {
    public:
        NoDefault(int);  // 没有默认构造函数
    };
    
    class Container {
        NoDefault obj;
    public:
        Container() : obj(42) {}  // 必须初始化列表
    };
    ```

