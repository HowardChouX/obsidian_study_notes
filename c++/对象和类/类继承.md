# 类基础

## 类基础比喻
- **基类（父类）**：[交通工具](app://obsidian.md/%E4%BA%A4%E9%80%9A%E5%B7%A5%E5%85%B7)
    - 属性：轮子数量、最大速度
    - 行为：启动()、刹车()
- **派生类（子类）**：[汽车](app://obsidian.md/%E6%B1%BD%E8%BD%A6)、[自行车](app://obsidian.md/%E8%87%AA%E8%A1%8C%E8%BD%A6)
    - 继承后自动拥有父类的属性和行为
    - 可新增特性：[汽车](app://obsidian.md/%E6%B1%BD%E8%BD%A6)有「油箱容量」，[自行车](app://obsidian.md/%E8%87%AA%E8%A1%8C%E8%BD%A6)有「脚踏板类型」
---
# 可见性
## 三种继承方式
```c++
class 汽车 : public 交通工具 { ... };    // 最常用（保持父类权限）
class 汽车 : protected 交通工具 { ... }; // 父类public变protected
class 汽车 : private 交通工具 { ... };  // 父类所有成员变private
```

> protected [成员保护] 派生类的成员可以访问基类的保护成员[protected],但不可以访问私有成员[private],对于外部来说，保护成员[protected]的行为于私有成员[private]相似；对于派生类来说，保护成员[protected]的行为与公有成员[public]类似。

访问控制权限类比：
- `public`：红绿灯（公共规则，所有人可见）
- `protected`：家庭相册（仅自己和子女可见）
- `private`：日记本（仅自己可见）


```c++
//可见性实例【30】
[[include]] <iostream>
[[include]] <string>

class Entity
{
private:
	int X, Y;
	
	void Print() {}
	
protected:
	int M, N;
	
	void Hello() {}
public:
	
	
	Entity()
	{
		X = 0;//X位于private 属于本类可以开放 
		Print();// Print位于private 属于本类可以开放 
	}

};


class Player : public Entity
{
public:
	Player ()
	{
	//X = 2 ,可见性错误 ,X是Entity类中的私有成员不对非Entity开放
	//Print(); 可见性错误 ,Print()是Entity类中的私有成员不对非Entity开放
	Hello();// Hello()位于Entity的Protected[保护成员]部分，可对派生类开放， 
	}
};

int main()
{
	Entity e;
	e.Print(); //Print位于Entity的private非本类不可调用 
	//Hello(); Hello()位于Entity的Protected[保护成员]部分,不对外部开放。 
	std::cin.get();
	
}
```

---


```c++
//简单的继承实例【27】
class Emtity
{
public:
	float X,Y;
	void Move(float xa, float ya)
	{
		X += xa;
		Y += ya;
			
	}	
};

class Player : public Entity 
{
public:
	const char* Name;
	void PrintName()
	{
		std==cout << Name <<std==endl;
	}
		
};

int main()
{
	Player player;
	player.Move(1,-1);
	std::cin.get;
}
```


# 虚函数

```c++
[[include]] <iostream>
[[include]] <string>

// 基类（父类）就像「身份证明模板」
class Entity
{
public:
    // 基础版的获取名称方法（相当于模板上的默认姓名）
    std::string GetName() { return "Entity"; }
};

// 派生类（子类）就像「定制版身份证明」
class Player : public Entity 
{
private:
    std::string m_Name;  // 新增的专属姓名
            
public:
    // 构造函数：就像办证时需要填写姓名
    Player(const std::string& name)
        :m_Name(name) {}  // 冒号后是成员初始化列表，`:m_Name(name)` 这种写法比在构造函数内赋值更高效，就像：直接印刷证件信息（初始化列表） vs 先印空白再手写（构造函数内赋值

- 直接印刷证件信息（初始化列表） vs 先印空白再手写（构造函数内赋值）
    
    // 重写基类方法：覆盖父类的默认姓名（但需要virtual才能实现多态）
    std::string GetName() { return m_Name; }
};


int main()
{
    // 创建基类实例：相当于制作默认证件
    Entity* e = new Entity();
    std==cout << e->GetName() << std==endl;  // 输出默认名称
    
    // 创建派生类实例：制作定制证件
    Player* p = new Player("Cherno");
    std==cout << p->GetName() << std==endl;  // 输出定制名称
    
    std::cin.get(); 
}
```

##  虚函数例子

```c++
//虚函数【28】
[[include]] <iostream>
[[include]] <string>

class Entity 
{
public:
    virtual std::string GetName() { return "Entity"; } // 快递面单基础模板
};

class Player : public Entity 
{
private:
    std::string m_Name;  // 定制化面单信息
public:
    Player(const std::string& name) : m_Name(name) {}//冒号后是成员初始化列表

    std::string GetName() override { return m_Name; } // 个性化面单
};

void PrintName(Entity* entity) 
{  // 分拣中心的扫描仪
    std==cout << entity->GetName() << std==endl; 
}

int main() {
    Entity* e = new Entity();       // 标准快递包裹
    PrintName(e);                  // 扫描显示"Entity"
    
    Player* p = new Player("Cherno"); // 定制快递包裹
    PrintName(p);                   // 扫描显示"Cherno"
}
```



Player(const std::string& name) : m_Name(name) {}
1. **构造函数的作用** → 办身份证的登记流程
    
    - `Player`：证件类型（身份证）
    - `const std::string& name`：申办人提供的姓名信息（通过专用通道传递，避免拷贝）
2. **冒号`:`后的部分** → 直接印刷个人信息
    
    - `m_Name(name)`：将申办人姓名直接印制到身份证芯片中
    - 对比在函数体内赋值：相当于先做空白证件，再手写姓名（效率更低）


**记忆技巧**：

- `virtual` 就像给方法装上「智能识别芯片」
- `override` 相当于贴上「已更新」标签
- 派生类的重写方法是对基类方法的「个性化改造」

# 动态联编

用家用电器来理解动态联编和虚函数的关系：

**动态联编 = 智能电源插座原理**  
想象你有一个万能插座（基类指针），可以连接任何电器。当你按下开关时：

- 普通插座（静态联编）：只会输出220V交流电（固定执行基类方法）
- 智能插座（动态联编）：自动识别连接的设备（根据实际对象类型），手机充电就输出5V，电饭煲工作就输出220V（调用对应的派生类方法）


```c++
class 电器 
{        // 基类
public:
    virtual void 工作() { cout << "通电" << endl; } // 虚函数相当于智能识别芯片
};

class 电风扇 : public 电器 
{
public:
    void 工作() override { cout << "开始吹风" << endl; } // 重写工作方式
};

class 电视机 : public 电器 
{
public:
    void 工作() override { cout << "播放节目" << endl; } // 不同的工作实现
};

int main() 
{
    电器* 插座 = new 电风扇();
    插座->工作(); // 输出"开始吹风"（动态联编）
    
    插座 = new 电视机(); 
    插座->工作(); // 输出"播放节目"（运行时才确定）
}
```
---
**虚函数的作用 = 开启智能识别模式**

1. 给基类方法加上`virtual`，相当于给插座安装识别芯片
2. 派生类用`override`重写方法，相当于不同电器的专属工作模式
3. 运行时根据实际连接的对象类型，动态选择正确的工作方式

**对比记忆**：

- 静态联编 → 老式电闸（通电就全开，不管连接什么）
- 动态联编 → 智能家居中枢（根据设备类型自动适配）
- 虚函数表 → 电器说明书合集（存储所有设备的工作方式）

---

# 纯虚函数（接口）

```c++

[[include]] <iostream>
[[include]] <string>

class Printable//基类，认证标准
{
public:
	virtual std::string GetClassName() = 0;//制定接口（制定检测标准，未实现的方法，需要子类去实现） 
};

class Entity :public Printable//公有继承自Printable 
{
public:
	virtual std::string GetName() {return "Entity";}//GetName虚函数 
	std::string GetClassName() override {return "Entity";} //实现接口，认证达标
};

class Player : public Entity //公有继承自Entity 
{
private:
	std::string m_Name;
	
public:
	Player(const std::string& name)
		:m_Name(name) {}
		
	std::string GetName() override { return m_Name;}
	std::string GetClassName() override { return "Player";}//实现接口
};

void PrintName(Entity* entity)//统一检测
{
	std==cout << entity->GetName() << std==endl;
}

class A : public Printable //公有继承自基类 
{
public:
	std::string GetClassName() override { return "A";}
};

void Print(Printable* obj)
{
	std==cout << obj->GetClassName() << std==endl;
}
int main()
{
	Entity* e = new Entity();
	PrintName(e);
	
	Player* p = new Player("cherno");
	PrintName(p);
	
	
	Print(e);
	Print(p);
	Print(new A());
	std::cin.get();
}


```

---

