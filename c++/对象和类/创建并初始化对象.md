# 在栈上创建对象
```c++
[[include]] <iostream>
[[include]] <string>

using String = std::string;

class Entity
{
private:
    String m_Name;
public:
    Entity() : m_Name("Unknown") {}//默认构造函数
    Entity(const String& name) : m_Name(name) {}//带参数构造函数

    const String& GetName() const { return m_Name; }//常量函数

};

```


```c++
int main()
{
    Entity* e;//未初始化的指针
    {
        Entity entity("Cherno");//在栈上创建对象
        e = &entity;//获取栈对象地址
        std==cout << entity.GetName() << std==endl;
    }//作用域结束entity自动销毁，e现在成为悬挂指针（指向已销毁对象）
```

# 在堆上创建对象

```c++
int main()
{
	Entity* e;
	{
	Entity* entity = new Entity("Cherno");//堆初始化对象
	e = entity;//传递指针
	std==cout << entity->GetName() << std==endl;
	}//离开作用域但对象仍然存在
	
	
}
std::cin.get();
delete e;
}
```

# 堆和栈初始化对象区别

|          | 栈（Stack）对象                     | 堆（Heap）对象                                |
| -------- | ------------------------------ | ---------------------------------------- |
| **代码示例** | `Entity entity("Cherno");`     | `Entity* entity = new Entity("Cherno");` |
| **分配方式** | 自动分配（由编译器管理）                   | 手动分配（需显式调用`new`/`delete`）                |
| **内存位置** | 函数调用栈帧内                        | 自由存储区（需要指针访问）                            |
| **生命周期** | 所在作用域结束时自动销毁                   | 必须手动调用`delete`才会销毁                       |
| **风险**   | 超出作用域后访问会导致未定义行为（如您代码中的悬垂指针问题） | 忘记`delete`会导致内存泄漏                        |
| **分配速度** | 极快（仅移动栈指针）                     | 较慢（需在堆内存中查找可用空间）                         |
| **访问速度** | 直接访问（通过栈地址）                    | 间接访问（需通过指针解引用）                           |