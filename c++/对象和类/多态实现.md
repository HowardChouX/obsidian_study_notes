
# 多态实现
> 在[[类继承]]纯虚函数代码例子中存在多态实现我们用「万能遥控器」的比喻来解释这段代码中的多态实现：


```c++
// 基类：所有电器的通用遥控协议（抽象接口）
class Printable 
{
public:
    virtual std::string GetClassName() = 0; // 纯虚函数=必须实现的遥控指令
};

// 电视机制造标准（具体类实现协议）
class Entity : public Printable 
{
public:
    virtual std::string GetName() { return "Entity"; }      // 基础功能键
    std::string GetClassName() override { return "Entity"; } // 实现遥控指令
};

// 智能电视定制协议（子类扩展）
class Player : public Entity 
{
private:
    std::string m_Name;
public:
    Player(const std::string& name) : m_Name(name) {}
    std::string GetName() override { return m_Name; }        // 重写功能键
    std::string GetClassName() override { return "Player"; } // 更新遥控指令
};

// 空调制造标准（另一个实现类）
class A : public Printable {
public:
    std::string GetClassName() override { return "A"; }      // 实现空调的指令
};

// 万能遥控器的打印功能
void Print(Printable* obj)
{
    std==cout << obj->GetClassName() << std==endl;  // 按同一按钮，执行不同操作
}
```

# 多态三要素实现
**多态的三要素实现**（对应你的代码）：

1. **继承体系** → 电器生产标准
    
    - `Printable` 是工信部制定的遥控器协议
    - `Entity` 和 `A` 是不同的电器生产标准
    - `Player` 是升级版电视标准
2. **虚函数重写** → 不同电器的响应逻辑
    
    ```c++
    // 基类定义标准操作
    virtual std::string GetClassName() = 0;
    
    // 子类实现具体操作
    std::string GetClassName() override { return "Player"; } // 电视返回开机动画
    std::string GetClassName() override { return "A"; }     // 空调返回温度状态
    ```
    
3. **统一接口调用** → 遥控器按钮
    
    ```c++
    void Print(Printable* obj) {
        obj->GetClassName(); // 同一按钮，不同电器有不同反应
    }
    ```

**动态运行示例**：

```c++
Print(new Entity());    // 按下按钮→显示"Entity"（老式电视）
Print(new Player(""));  // 按下按钮→显示"Player"（智能电视）
Print(new A());         // 按下按钮→显示"A"（空调）
```
