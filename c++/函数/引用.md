# 定义
> 引用（Reference）是变量的别名，相当于给现有变量起一个新名字。
> 运算符为& ，运算符重载；
> 引用可以看作是语法糖，它**不提供新功能**，但能让代码更易读/写。

```c++
int a = 1;
int& ref = a;
```

---

# 特性 
- 必须初始化
```c++
int x = 10;
int& ref = x;  // ✅ 正确,引用x进行初始化
int& bad_ref;  // ❌ 编译错误
```


- 不可重新绑定
```c++
int y = 20;
ref = y;      // 实际是 x = y，不是改变引用目标
```

- 空引用不存在
```c++
int& null_ref = nullptr;  // ❌ 编译错误
```

---

# 与指针比较

| 特性   | 引用      | 指针         |
| ---- | ------- | ---------- |
| 初始化  | 必须立即初始化 | 可延迟初始化     |
| 空值   | 不允许     | 允许 nullptr |
| 重定向  | 不可      | 可以改变指向     |
| 访问方式 | 自动解引用   | 需要 * 操作符   |
| 内存占用 | 通常无额外存储 | 占用指针大小内存   |

---

# 常用场景
- 函数参数传递（避免拷贝）

```c++
void processBigData(const BigClass& data) 
{
    // 避免拷贝构造
}
```


```c++
//值传递
void Increment(int value)
{
    value++;

}
int main()
{
    int a = 5;
    Increment(a);
    std==cout << a << std==endl;//不可修改原值，a输出为5
    
    std::cin.get;
    return 0;
}

```

```c++

//指针传递参数
void Increment(int* value)
{
    (*value)++;

}
int main()
{
    int a = 5;
    Increment(&a);
    std==cout << a << std==endl;//可修改原值，a输出为6
    
    std::cin.get;
    return 0;

}
```

```c++
//引用传递参数
void Increment(int& value)
{
    value++;

}
int main()
{
    int a = 5;
    Increment(a);
    std==cout << a << std==endl;//可修改原值，a输出为6;
    
    std::cin.get;
    return 0;

}


```

### 三种参数传递方式对比

| 方式   | 示例               | 内存使用  | 可修改原值 | 空值风险 |     |
| ---- | ---------------- | ----- | ----- | ---- | --- |
| 值传递  | `void f(int x)`  | 副本拷贝  | 否     | 无    |     |
| 指针传递 | `void f(int* x)` | 4/8字节 | 是     | 有    |     |
| 引用传递 | `void f(int& x)` | 无副本   | 是     | 无    |     |


- 返回值优化(链式调用)
```c++
class Logger 
{
public:
    Logger& operator<<(const string& msg) 
    {
        cout << msg;
        return *this;
    }
};
```

- 范围for循环修改元素

```c++
vector<int> vec{1,2,3};
for(auto& num : vec) 
{
    num *= 2;  // 直接修改容器元素
}
```
