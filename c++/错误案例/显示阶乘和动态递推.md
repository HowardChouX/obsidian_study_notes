
### **一、错误版本的问题根源**

**错误代码示例**：

```cpp
long t = 1;
for (int i = 1; i < 101; i++) {
    t *= i;         // 显式计算阶乘，导致溢出
    e += 1.0 / t;
}
```

**核心问题**：

1. **数值溢出**：
    
    - `long` 类型存储阶乘，当 `i=21` 时，`21! = 51090942171709440000` 超过 `long` 的最大值（`9223372036854775807`）
    - 溢出后 `t` 变为负数或零，导致后续计算 `1.0/t` 出现 `inf` 或 `nan`，破坏结果
2. **无效循环次数**：
    
    - 当 `i>20` 时，`1.0/i!` 的值低于双精度浮点数的精度极限（≈1e-19），无法影响 `e` 的结果
    - 循环到 `i=100` 浪费计算资源，甚至引入错误

---

### **二、当前版本的正确性保障**

**修正后代码**：

```cpp
double term = 1.0;
for (int i = 1; i < 101; i++) {
    term /= i;      // 递推计算项值，避免溢出
    e += term;
}
```

**核心优势**：

1. **规避溢出**：
    
    - 通过 `term /= i` 递推计算项值，而非显式计算阶乘
    - `term` 的值始终为浮点数，随着 `i` 增大迅速趋近于零，但不会溢出
2. **数值稳定性**：
    
    - 即使 `i` 很大（如 `i=100`），`term` 最终会下溢（Underflow）为 `0.0`，但不会产生错误值
    - `e` 的累加在 `i=20` 后已接近极限精度，后续项无贡献但不影响结果正确性
3. **浮点特性适配**：
    
    - 双精度浮点数 (`double`) 的精度足以容纳 `term` 的递推计算过程

---

### **三、对比总结**

|特性|错误版本（显式阶乘）|正确版本（递推项值）|
|---|---|---|
|**数值溢出风险**|必然溢出（`i>20` 时）|无溢出（浮点下溢为0）|
|**计算效率**|低效（重复计算大数阶乘）|高效（每次循环仅一次除法）|
|**代码复杂度**|高（需处理阶乘逻辑）|低（逻辑简洁）|
|**适用性**|仅适用于极小 `i`|可安全计算到任意 `i`|

---

### **四、延伸验证**

1. **输出不同 `i` 的 `e` 值**：
    
    - `i=10` → `e ≈ 2.718281801146385`
    - `i=20` → `e ≈ 2.7182818284590455`（双精度极限）
    - `i=100` → 结果与 `i=20` 相同（后续项贡献被双精度忽略）
2. **数值稳定性测试**：  
    将 `i` 设为 `1000`，结果仍为 `2.7182818284590455`，证明后续计算无害。
    

---
