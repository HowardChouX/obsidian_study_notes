# 食堂排队的基础操作

## 包含头文件 & 创建队列

```cpp
[[include]] <queue>  // 食堂排队规则手册

std==queue<std==string> lunchQueue;  // 创建一个字符串队列（空的队伍）
```

## 入队（排队）

```cpp
lunchQueue.push("张三");  // 张三排到队尾
lunchQueue.push("李四");  // 李四排在张三后面
// 队伍顺序：张三 → 李四
```

## 出队（打饭离开）

```cpp
std::string firstPerson = lunchQueue.front(); // 查看队首是谁（张三）
lunchQueue.pop();  // 张三打完饭离开队伍
// 队伍剩下：李四
```

## 常用操作

```cpp
if (!lunchQueue.empty()) {  // 检查队伍是否还有人
    int peopleCount = lunchQueue.size();  // 当前队伍人数（1人）
    std::string nextPerson = lunchQueue.front(); // 下一个打饭的人（李四）
    std::string lastPerson = lunchQueue.back();  // 队尾的人（李四，如果只有他）
}
```

---

# 队列的限制（食堂规则）

- **禁止插队**：不能直接访问或修改队列中间的人（只能操作队首和队尾）。
- **自动管理**：`pop()` 会永久移除队首元素（就像人离开队伍后不能再回来）。

---

#  实际应用场景

#### **(1) 任务调度（食堂窗口）**

```cpp
std==queue<std==string> printQueue;  // 打印任务队列

// 添加任务
printQueue.push("报告.doc");
printQueue.push("照片.jpg");

// 处理任务
while (!printQueue.empty()) {
    printFile(printQueue.front());  // 打印队首文件
    printQueue.pop();               // 任务完成，移除
}
```

#### **(2) 广度优先搜索（BFS）**

```cpp
// 迷宫寻路时，用队列记录待探索的位置
std::queue<Position> exploreQueue;
exploreQueue.push(startPoint);  // 从起点开始

while (!exploreQueue.empty()) {
    Position current = exploreQueue.front();
    exploreQueue.pop();
    // 向四个方向探索，新位置加入队列
    exploreQueue.push(current.up());
    exploreQueue.push(current.down());
    // ...
}
```

---

### **4. 队列的底层实现**

- C++ 的 `std::queue` 默认基于双端队列 (`deque`) 实现，但你可以指定其他容器：
    
    ```cpp
    [[include]] <list>
    std==queue<int, std==list<int>> customQueue;  // 用链表实现的队列
    ```
    

---

### **5. 常见错误（食堂事故）**

```cpp
std::queue<int> q;
q.pop();  // 错误！队伍空了还让人出队 → 程序崩溃
```

**正确做法**：操作前检查队列是否为空：

```cpp
if (!q.empty()) {
    q.pop();
}
```