# 传统数组

## 数组基础概念
```cpp
int 快递柜[5] = {10, 20, 30, 40, 50}; // 5个固定格子
```

1. **基本特性**
    
    - 同类型元素集合 → 所有格子存放同规格包裹
    - 连续内存分配 → 格子紧密排列无间隔
    - 固定容量 → 货架尺寸建造时确定
2. **内存布局**
    
    ```
    地址       索引   值
    0x1000 → [0] → 10
    0x1004 → [1] → 20
    0x1008 → [2] → 30
    0x100C → [3] → 40
    0x1010 → [4] → 50
    ```


> 数组和指针关系：若将数组比作快递柜，指针就可以比作取件码纸条

- **实实在在的快递柜**（有固定容量）
- 指针是 **取件码纸条**（可以指向不同快递柜）
- 数组名在大多数表达式里 **自动变成取件码**（首元素地址）

## 初始化数组
### 数组申明
```c++
char months[12];//数组申明包括 值类型int 数组名months 数组元素[12]
months[5] = "may";
```

---

### 初始化

```c++
int weekendays[2] {6,7};
```


> notice !
> 初始化禁止缩窄转换 eg. long-> double
---
# 数组与循环

```c++
int main()
{
	int example[5];
	example[0] = 0;
	example[1] = 1;
	example[2] = 2;
	example[3] = 3;
	example[4] = 4;
	
	for (int i = 0; i < 5; i++)
		example[i] = 2;
		
	std::cin.get();
	 
}
```


#  简介寻址(索引访问原理-内存偏移量)


```c++
#include <iostream>

int main()
{
	int example[5];
	int* ptr = example;//指针，将数组example的第一个元素的位置储存到ptr
	example[2] = 5;//将第二个元素的值赋值为5； 
	*(ptr + 2) = 6;//解引用运用偏移量来使第二个元素的值改变为6（寻址）；	
		
	std::cin.get();
	 
}

```


## 用快递柜存取快递的过程来解释索引访问的内存偏移原理：

```cpp
int 快递柜[5] = {10, 20, 30, 40, 50}; // 5个柜子，每个柜子存放1个int（4字节）
```

## 内存布局示意图

```
地址        柜号  存储的值
0x1000  → [0] → 10
0x1004  → [1] → 20 
0x1008  → [2] → 30
0x100C  → [3] → 40
0x1010  → [4] → 50
```

## 访问原理（以快递柜[2]为例）

```cpp
int 包裹 = 快递柜[2]; // 取出第3个柜子的快递
```

1. **基地址计算**  
    快递柜的起始地址 = `0x1000`（数组首地址）
    
2. **偏移量计算**  
    每个柜子大小 = `sizeof(int)` = 4字节  
    目标偏移 = 索引 × 元素大小 = `2 × 4 = 8字节`
    
3. **最终地址**  
    目标地址 = 基地址 + 偏移量 = `0x1000 + 8 = 0x1008`
    
4. **内存访问**  
    从`0x1008`地址读取4字节数据 → 得到30




# 标准数组（std::array）

```c++
#include <array> // 必须包含头文件

// 传统快递柜（原生数组）
int 老式快递柜[5] = {1,2,3}; // 容量固定，越界危险

// 现代智能快递柜
std::array<int,5> 智能快递柜 = {1,2,3}; // 自带安全系统
```

# 动态数组（std::vector)
### **一、初始化**

```cpp
#include <vector>

// 空vector
std::vector<int> vec1;  

// 含5个默认值0的vector
std::vector<int> vec2(5);  

// 含5个值42的vector
std::vector<int> vec3(5, 42);  

// 列表初始化 (C++11)
std::vector<int> vec4 = {1, 3, 5};  
```

---

### **二、添加元素**

#### 1. **尾部追加**

```cpp
vec.push_back(10);   // 传统方法
vec.emplace_back(20); // C++11起，更高效（避免临时对象复制）
```

#### 2. **任意位置插入**

```cpp
auto it = vec.begin() + 2;  // 定位到第3个元素前
vec.insert(it, 99);         // 在位置2插入99
vec.emplace(it, 100);       // C++11，直接构造元素
```

---

### **三、访问元素**

#### 1. **下标访问**

```cpp
int a = vec[0];    // 快速访问，不检查越界
int b = vec.at(2); // 检查越界，越界时抛出std::out_of_range
```

#### 2. **首尾元素**

```cpp
int first = vec.front();  // 首元素
int last = vec.back();    // 尾元素
```

---

### **四、遍历元素**

#### 1. **传统循环**

```cpp
for (size_t i = 0; i < vec.size(); ++i) {
    std::cout << vec[i] << " ";
}
```

#### 2. **范围循环 (C++11)**

```cpp
for (const auto& num : vec) {
    std::cout << num << " ";
}
```

#### 3. **迭代器**

```cpp
for (auto it = vec.begin(); it != vec.end(); ++it) {
    std::cout << *it << " ";
}
```

---

### **五、常用方法**

|方法|功能描述|时间复杂度|
|---|---|---|
|`vec.size()`|返回元素数量|O(1)|
|`vec.empty()`|判断是否为空|O(1)|
|`vec.clear()`|清空所有元素|O(n)|
|`vec.pop_back()`|删除尾部元素|O(1)|
|`vec.erase(it)`|删除迭代器指向元素|O(n)|
|`vec.resize(n)`|调整大小为n，新增元素默认初始化|O(n)|
|`vec.reserve(n)`|预分配n个元素的内存（避免频繁扩容）|O(n)|

---

### **六、性能优化技巧**

1. **预分配内存**
    
    ```cpp
    vec.reserve(100);  // 提前分配100元素空间，避免多次扩容
    ```
    
2. **移动语义 (C++11)**
    
    ```cpp
    std::vector<std::string> vec;
    std::string s = "data";
    vec.push_backmove(s);  // 移动而非复制，s变为空
    ```
    
3. **交换容器**
    
    ```cpp
    std::vector<int> tmp;
    vec.swap(tmp);  // 快速清空vec并释放内存
    ```
    

---

### **七、典型应用场景**

1. **动态数据集合**
    
    ```cpp
    std::vector<int> scores;
    while (/* 读取输入 */) {
        int num;
        std::cin >> num;
        scores.push_back(num);
    }
    ```
    
2. **替代C风格数组**
    
    ```cpp
    // 传统数组
    int arr[5] = {1,2,3,4,5};  
    
    // vector替代方案
    std::vector<int> vec(arr, arr + 5);  // 用迭代器范围初始化
    ```
    
3. **二维动态数组**
    
    ```cpp
    std::vector<std::vector<int>> matrixvector<int>(3);  // 5行3列
    matrix[2][1] = 42;
    ```
    

---

### **八、注意事项**

1. **迭代器失效**
    
    - 添加/删除元素可能导致迭代器、指针、引用失效
    
    ```cpp
    auto it = vec.begin();
    vec.push_back(10);  // 可能导致it失效！
    ```
    
2. **越界访问**
    
    - 使用 `[]` 时需自行确保索引有效
    - 调试阶段可用 `.at()` 辅助检查


## 标准数组与动态数组的比较

| 特性     | 内置数组 / `std::array`  | `std::vector`  |     |
| ------ | -------------------- | -------------- | --- |
| 容量是否固定 | ✅ 固定                 | ❌ 动态扩展         |     |
| 内存位置   | 栈（内置数组）或静态存储         | 堆              |     |
| 越界检查   | 仅 `std::array::at()` | `.at()` 方法提供检查 |     |
| 适用场景   | 已知固定容量的轻量级数据         | 需动态增删数据        |     |