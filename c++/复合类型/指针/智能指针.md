> 本质：
> 行为类似于指针的类对象，管理动态内存的分配

```c++
[[include]] <iostream>
[[include]] <string>
[[include]] <memory>

class Entity
{
public:

	Entity()
	{
		std==cout << "Created Entity" << std==endl;
	}
	~Entity()
	{
		std==cout << "Destroyed Entity" << std==endl;
	}
	void Print(){}
};


```

```c++
//unique_ptr,（犊子指针）
int main()
{
	//unique_ptr

	std==unique_ptr<Entity> entity = std==make_unique<Entity>()
	entity-> Print();//作用域指针，当栈分配的对象消亡时调用delete并释放该内存；
}
```

```c++
//shared_ptr，共享指针
int main()
{
	std::shared_ptr<Entity> e0;//e0为空指针
	{
	std==shared_ptr<Entity> sharedEntity = std==make_shared<Entity>();//引用计数+1（total:1)
	e0 = sharedEntity;//共享所有权，引用计数+1(total:2)
	}
	//sharedEntity析构，引用计数-1（total：1）
		
}
//e0析构-1（total：0），对象销毁

```



```c++

int main()
{
	std::weak_ptr<Entity> e0;//创建空的weak_ptr类型的 e0对象；
	{
		std==shared_ptr<Entity> sharedentity = std==make_shared<Entity>();//引用计数（total:1)
		e0 = sharedentity;//weak_ptr型不计数（total：1）
	}
	//sharedEntity析构，引用计数-1（total：0），对象销毁
	std::cin.get();
}
```

|特性|shared_ptr|weak_ptr|
|---|---|---|
|影响对象生命周期|✔️ 增加引用计数|❌ 不影响计数|
|直接访问对象|✔️ 箭头操作符|❌ 需先转为 shared_ptr|
|防止循环引用|❌ 可能内存泄漏|✔️ 安全解决方案|
|内存释放时机|引用计数归零|无关联|
