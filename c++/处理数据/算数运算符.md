> 变量常量都可以进行操作,%的操作数只能为整数

- /用于两整数相除仅保留整数,两浮点数相除保留小数
- % 用于取模

---

## 运算规则

- 由于字符可以与整数通用，整数浮点数可以相加
- 大多数算术运算符的结合方向为“先左后右”，即左结合性
- 有些运算符（例如赋值运算符“=”）的结合方向为“自右向左”，即右结合性
- C++语言的自增自减运算符“++”和“--”的作用是使变量的值加1或减1，
- `++i，--i`（在使用i之前，使i的值加/减1）；
- `i++，i--`（在使用i之后，使i的值加/减1)。
- ++”和“--”的结合方向是自右向左。(++i和i++的作用相当于i=i+1，但它们的不同之处在于++i是执行i=i+1后再使用i的值，而i++是使用i的值后再执行i=i+1.
---


### 类型转换

##### 1.初始化和赋值进行的转换
```c++
short thirty;
long so_long;
so_long = thirty;//将thirty的值扩展为long值

```

---

###### 2.以{}方式初始化进行的转换
> 列表初始化不允许进行缩窄，变量的类型可能无法表示赋给它的值，不允许整数转为浮点数，反过来有可能实现

```c++
const int code = 66;  // ✅ 合法，定义一个常量整数 66
int x = 66;           // ✅ 合法，普通整数变量
char c1 {31325};  // ❌ 错误，char 只能存储 -128 到 127 (或 0-255, 取决于是否无符号)
char c2 {66};     // ✅ 合法，66 可以安全存入 char
char c3 {code};   // ✅ 合法，code 是 66，可以安全存入 char
char c4 {x};      // ❌ 错误，x 不是常量，可能导致数据丢失
                  
x = 31325;        // ✅ 合法，int 可以存储 31325
char c5 = x;      // ⚠️ 可能导致数据丢失，x 可能超出 char 的存储范围
```
---

##### 3.表达式中的转换
---

##### 4参数传递时转换
```c++
#include <iostream>

void func(int a) {
    std==cout << "int version: " << a << std==endl;
}

void func(double a) {
    std==cout << "double version: " << a << std==endl;
}

int main() {
    // 隐式转换
    func(5);        // 调用int版本
    func(5.0);      // 调用double版本
    func(5.5);      // 隐式转换为double，调用double版本

    // 显式转换
    func(static_cast<int>(5.5)); // 强制转换为int，调用int版本

    return 0;
}
```


---

##### 5.强制类型转换


```c++
func(static_cast<int>(5.5)); // 强制转换为int，调用int版本
```


