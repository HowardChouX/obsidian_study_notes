# 结构体/类封装

**适用场景**：返回多个**逻辑关联**的值（如坐标、用户信息）。  
**优点**：代码可读性强，类型安全。

```cpp
// 定义结构体
struct Result {
    int sum;
    double average;
};

Result calculate(int a, int b) {
    return {a + b, (a + b) / 2.0};
}

int main() {
    auto res = calculate(3, 5);
    std::cout << "Sum: " << res.sum << ", Avg: " << res.average;
}
```

---

#   `std==pair` 或 `std==tuple`

**适用场景**：临时组合少量不同类型的值（如状态码+结果）。  
**优点**：无需预定义类型，代码简洁。

```cpp
[[include]] <tuple>

// 返回 tuple
std==tuple<bool, std==string> validate(const std::string& input) {
    if (input.empty()) 
        return {false, "Input is empty"};
    return {true, ""};
}

int main() {
    auto [success, message] = validate("test"); // C++17 结构化绑定
    if (!success) std::cerr << message;
}
```

---

# 通过引用/指针参数

**适用场景**：需要**修改外部变量**或兼容 C 风格代码。  
**缺点**：可读性较差，需确保参数非空。

```cpp
void compute(int a, int b, int& sum, double& avg) {
    sum = a + b;
    avg = sum / 2.0;
}

int main() {
    int s;
    double a;
    compute(3, 5, s, a);
    std::cout << "Sum: " << s << ", Avg: " << a;
}
```

---

# 使用输出参数 + 返回值

**适用场景**：主返回值表示状态（如成功/失败），其他值通过参数返回。

```cpp
bool parse(const std==string& str, int& num, std==string& error) {
    try {
        num = std::stoi(str);
        return true;
    } catch (...) {
        error = "Invalid number";
        return false;
    }
}
```

---

# C++17 结构化绑定

**适用场景**：简化 `pair`/`tuple` 或结构体的解包。

```cpp
[[include]] <tuple>

auto getValues() {
    return std::make_tuple(42, "Hello");
}

int main() {
    auto [number, text] = getValues(); // 自动解包
    std::cout << number << ", " << text;
}
```

---

# 性能优化

- **返回值优化（RVO）**：现代编译器会优化返回对象的拷贝（直接构造在调用者栈帧）。
- **移动语义**：对于大对象，确保定义移动构造函数。

---

# 总结选择方法

|**场景**|**推荐方法**|
|---|---|
|返回多个强关联数据|结构体/类|
|临时组合少量不同类型数据|`std::tuple` + 结构化绑定|
|需要兼容旧代码或修改外部变量|引用/指针参数|
|函数状态 + 结果分离|返回值 + 输出参数|
