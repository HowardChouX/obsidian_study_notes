# 11.3 可比性

子类型多态的重要应用

---

#### 最大值函数

假设我们需要编写一个`max`函数，该函数可以接受任意类型的数组并返回数组中的最大元素。

**练习 4.3.1.** 请判断以下代码中存在多少处编译错误。

```java
public static Object max(Object[] items) {
    int maxDex = 0;
    for (int i = 0; i < items.length; i += 1) {
        if (items[i] > items[maxDex]) {
            maxDex = i;
        }
    }
    return items[maxDex];
}

public static void main(String[] args) {
    Dog[] dogs = {new Dog("Elyse", 3), new Dog("Sture", 9), new Dog("Benjamin", 15)};
    Dog maxDog = (Dog) max(dogs);
    maxDog.bark();
}
```

在上方代码中，仅存在 1 处错误：

```java
if (items[i] > items[maxDex]) {
```

该行出现编译错误的原因是：`>` 运算符无法应用于任意 Object 类型。事实上，Java 的 `>` 运算符仅支持基本数据类型。

我们可以通过在 Dog 类中定义专门的 `maxDog` 函数来暂时解决问题，但这样就无法实现通用的"最大值函数"：

```java
public static Dog maxDog(Dog[] dogs) {
    if (dogs == null || dogs.length == 0) {
        return null;
    }
    Dog maxDog = dogs[0];
    for (Dog d : dogs) {
        if (d.size > maxDog.size) {
            maxDog = d;
        }
    }
    return maxDog;
}
```

这种解决方案虽然可行，但需要为每个新定义的类（如 Cat、Penguin 等）重复编写相似代码，导致冗余和维护困难。

核心问题在于：Java 无法直接使用 `>` 比较对象。不同对象的比较标准可能不同（如字符串按字典序，Dog 按体型等）。为此我们需要接口继承的帮助。

---

### 解决方案：可比接口

我们创建包含比较方法 `compareTo` 的接口：

![](https://cs61b-2.gitbook.io/~gitbook/image?url=https%3A%2F%2Fjoshhug.gitbooks.io%2Fhug61b%2Fcontent%2Fassets%2Fdog_comparable.png&width=768&dpr=4&quality=100&sign=bc247610&sv=2)

接口定义如下：

```java
public interface OurComparable {
    public int compareTo(Object o);
}
```

方法约定：
- 返回 -1 表示当前对象小于参数对象
- 返回 0 表示相等
- 返回 1 表示当前对象大于参数对象

**练习 4.3.2.** 请为 Dog 类实现 `compareTo` 方法。

自定义接口存在三个问题：
1. 需要进行繁琐的对象类型转换
2. 非标准接口导致现有类无法兼容
3. 缺少使用该接口的库函数

解决方案：使用 Java 内置的 `Comparable<T>` 接口：

![](https://cs61b-2.gitbook.io/~gitbook/image?url=https%3A%2F%2F2316889115-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FCLYj7ccqvV6l4Pt9R0w5%252Fuploads%252FupH1F2E72Zx3PgCXgtGs%252Fcomparable_interface.png%3Falt%3Dmedia%26token%3D40d10df7-5c3c-42a1-ac8b-30e564359069&width=768&dpr=4&quality=100&sign=eb5ce512&sv=2)

改进后的 Dog 类实现：

```java
public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }
}
```

通过泛型类型声明 `Comparable<Dog>`，我们可以避免强制类型转换。以下是完整实现示例：

```java
public class Dog implements OurComparable {
    private String name;
    private int size;

    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public void bark() {
        System.out.println(name + " says: bark");
    }

    public int compareTo(Object o) {
        Dog uddaDog = (Dog) o;
        return this.size - uddaDog.size;
    }
}
```

通用最大值函数实现：

```java
public static OurComparable max(OurComparable[] items) {
    int maxDex = 0;
    for (int i = 0; i < items.length; i += 1) {
        int cmp = items[i].compareTo(items[maxDex]);
        if (cmp > 0) {
            maxDex = i;
        }
    }
    return items[maxDex];
}
```

该方法优势：
- 避免为每个类重复实现最大值函数
- 实现多类型数据的统一处理

---

#### 接口测验

**练习 4.3.3.** 若从 Dog 类中移除 `compareTo()` 方法，哪些文件会编译失败？

```java
public class DogLauncher {
    public static void main(String[] args) {
        ...
        Dog[] dogs = new Dog[]{d1, d2, d3};
        System.out.println(Maximizer.max(dogs));
    }
}

public class Dog implements OurComparable {
    ... // 缺少 compareTo 实现
}

public class Maximizer {
    public static OurComparable max(OurComparable[] items) {
        ...
        int cmp = items[i].compareTo(items[maxDex]);
        ...
    }
}
```

此时 Dog 类将编译失败，因其声明实现 OurComparable 接口却未提供 `compareTo` 方法。若移除 `implements OurComparable` 声明，则 DogLauncher 中调用 `Maximizer.max(dogs)` 会因类型不匹配而报错。

最终我们采用 Java 标准库的 `Comparable` 接口，其实现方式如下：

![](https://cs61b-2.gitbook.io/~gitbook/image?url=https%3A%2F%2Fjoshhug.gitbooks.io%2Fhug61b%2Fcontent%2Fassets%2Fcomparable.png&width=768&dpr=4&quality=100&sign=f3f4ea1f&sv=2)