## 基础知识题

### 1. Iterable接口的必要方法

```java
public interface Iterable<T> {
    Iterator<T> iterator();
}
```

> **答案**：实现Iterable接口必须重写`iterator()`方法，返回一个Iterator对象

### 2. Set与List接口特性

```java
// 正确选项分析：
- ✅ 向Set和List添加相同元素时，Set大小总≤List（因Set元素唯一）
- ✅ ArrayList是List接口的实现类
- ✅ Set和List接口继承自Iterable接口（支持增强for循环）
- ❌ Set/List不继承Iterator接口
```

### 3. Iterator接口必须实现的方法

```java
public interface Iterator<T> {
    boolean hasNext();
    T next();
}
```

> **答案**：必须实现`hasNext()`和`next()`方法

---

## 概念理解题

### 1. 重写equals方法的原因

|**比较方式**|内存地址|内容相等|
|---|---|---|
|`Object.equals()`|✅|❌|
|重写后的equals()|❌|✅|

> **示例**：Stone类比较重量

```java
@Override
public boolean equals(Object o) {
    return this.weight == ((Stone) o).weight;
}
```

---

## 思维提升题

### 1. 迭代器改造（Comparator应用）

**原始代码**：

```java
private class ArraySetIterator implements Iterator<T> {
    private int pos;
    public ArraySetIterator() { pos = 0; }
    public boolean hasNext() { return pos < size; }
    public T next() {
        T returnItem = items[pos];
        pos += 1;
        return returnItem;
    }
}
```

**修改后代码**：

```java
public class ArraySetGreaterIterator implements Iterator<T> {
    private int pos;
    private T ref;        
    private Comparator<T> comp;

    public ArraySetGreaterIterator(T ref, Comparator<T> comp) {
        this.ref = ref;
        this.comp = comp;
    }

    @Override
    public boolean hasNext() {
        // 新增循环跳过不满足条件的元素
        while (pos < size && comp.compare(items[pos], ref) <= 0) {
            pos++;
        }
        return pos < size;
    }

    @Override
    public T next() {
        return items[pos++];
    }
}
```