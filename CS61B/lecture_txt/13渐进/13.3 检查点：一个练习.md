
一些必要的练习。

练习：对dup2应用技巧2A和2B。

计算以下代码中每个操作相对于N的计数。
预测每个操作的粗略量级。

```java
for (int i = 0; i < A.length - 1; i += 1){
  if (A[i] == A[i + 1]) { 
    return true; 
  }
}
return false;
```

解决方案：
注意：稍有偏差是可以接受的——如前所述，我们只需要粗略估计。

操作 | 符号化计数 | 计数（N=10000时）
--- | --- | ---
i = 0 | 1 | 1
j = i+1 | 0到N | 0到10,000
< | 0到N−1 | 0到9,999
== | 1到N−1 | 1到9,999
数组访问 | 2到2N−2 | 2到19998

"我还有个问题要考考你( ͡° ͜ʖ ͡°)..." - Josh Hug
让我们比较dup1和dup2的表格：

dup1表格：

操作 | 符号化计数 | 计数（N=10000时）
--- | --- | ---
i = 0 | 1 | 1
j = i+1 | 1到N | 1（最佳情况）到10000（最差情况）
< | 2到(N²+3N+2)/2 | 2到50,015,001
+= 1 | 0到(N²+N)/2 | 0到50,005,000
== | 1到(N²−N)/2 | 1到49,995,000
数组访问 | 2到N²−N | 2到99,990,000

dup2表格：

操作 | 符号化计数 | 计数（N=10000时）
--- | --- | ---
i = 0 | 1 | 1
j = i+1 | 0到N | 0到10,000
< | 0到N−1 | 0到9,999
== | 1到N−1 | 1到9,999
数组访问 | 2到2N−2 | 2到19998

可以看出在最坏情况下，dup2的性能明显优于dup1！

一种解释是dup2用更少的操作完成了与dup1相同的目标。

更好的理解是dup2算法在最坏情况下扩展性更好（例如(N²+3N+2)/2 vs N）

更深入的理解是：抛物线（N²）的增长速度总是快于直线（N）。