
### 计算成本的测量技术

我们需要对之前提到的两种算法进行运行时特征分析。换句话说，我们希望找到一种能够清晰传达两种算法整体性能的代理指标。

在分析运行时特征时，我们有两个目标：
- 方法应简洁且数学严谨。
- 若某一算法更优，应能明确展示其优势。

我们已将朴素算法和优化算法转换为Java代码。其中`dup1`对应朴素算法，`dup2`对应优化算法。

```
// 朴素算法：逐一比较所有元素
public static boolean dup1(int[] A) {  
  for (int i = 0; i < A.length; i += 1) {
    for (int j = i + 1; j < A.length; j += 1) {
      if (A[i] == A[j]) {
         return true;
      }
    }
  }
  return false;
}
```

```
// 优化算法：仅比较相邻元素
public static boolean dup2(int[] A) {
  for (int i = 0; i < A.length - 1; i += 1) {
    if (A[i] == A[i + 1]) { 
      return true; 
    }
  }
  return false;
}
```

---

### 技术1：直接计时测量

第一种方法是使用客户端程序直接测量以秒为单位的执行时间。实施方式包括：
- 使用物理秒表（不推荐）
- 使用Unix内置的`time`命令
- 使用普林斯顿标准库的`stopwatch`类

通过这些方法可以发现：随着输入规模增大，`dup1`耗时显著增加，而`dup2`保持相对稳定。虽然这种方法直观易懂，但存在严重缺陷：
- 大规模输入时耗时过长
- 运行时间受机器性能、编译器、输入数据等因素影响

这些缺陷使得该方法无法满足我们的分析目标——虽然简单但缺乏数学严谨性，且无法明确展示算法间的优劣关系。

---

### 技术2A：操作计数分析

该方法通过统计算法执行的总操作次数进行比较。以输入规模`N=10000`的`dup1`算法为例：

| 操作类型          | 执行次数（N=10000）          |
|-------------------|-----------------------------|
| `i = 0`           | 1                          |
| `j = i+1`         | 1（最佳情况）~10000（最差情况）|
| `<`比较           | 2~50,015,001               |
| `+= 1`            | 0~50,005,000               |
| `==`比较          | 1~49,995,000              |
| 数组访问          | 2~99,990,000              |

此方法解决了机器依赖性，但存在明显不足：
- 手工统计繁琐
- 输入规模选择具有任意性
- 无法反映实际耗时

---

### 技术2B：符号计数分析

通过使用输入规模`N`的符号表达式进行计算，可以观察算法的规模扩展性：

| 操作类型          | 符号表达式              | N=10000时的数值范围      |
|-------------------|-----------------------|-------------------------|
| `i = 0`           | 1                     | 1                       |
| `j = i+1`         | 1~N                  | 1~10000                 |
| `<`比较           | 2~(N² + 3N + 2)/2    | 2~50,015,001           |
| `+= 1`            | 0~(N² + N)/2         | 0~50,005,000           |
| `==`比较          | 1~(N² - N)/2         | 1~49,995,000          |
| 数组访问          | 2~N²-N               | 2~99,990,000          |

符号计数法虽能揭示算法随输入规模的变化趋势，但统计过程更加复杂，且仍无法提供实际时间信息。